## 第10章  待办事项程序

在Flask程序中，为了获得更好的页面交互，有些功能我们不得不使用JavaScript实现。这一章要编写的待办事项应用Todoism则是将这种趋势发展到极致：我们将基于jQuery（JavaScript）实现一个简单的单页程序（Single Page Application，SPA），像是Gmail的Web程序那样。和以前的传统Web程序不同的是，单页程序将使用AJAX技术处理大部分甚至是所有的请求，也就是说，整个程序不再需要通过重新渲染模板来更新程序状态。这会使Web程序更像是桌面程序或是移动端程序那样，拥有流畅的操作体验。

我们前面介绍的示例程序中的文本都使用了英文，你可以在一开始就使用中文，但是另一个更完善的方式是支持多种语言，尤其是在你的程序可能会被不同国家的人使用的情况下。这一章我们还会学习为程序添加多语言支持。

在本章的后半部分，我们会为程序编写Web API。这样我们可以完全分离程序的客户端和服务器端代码，服务器端的Flask程序只负责处理数据，你可以自由选用其他的框架和语言来实现客户端程序。

本章新涉及的Python包如下所示：

·Flask-Babel（0.11.2）：

·主页： [https://github.com/python-babel/flask-babel](https://github.com/python-babel/flask-babel) 。 

·文档： [https://pythonhosted.org/Flask-Babel/](https://pythonhosted.org/Flask-Babel/) 。 

·Babel（2.5.3）：

·主页： [https://github.com/python-babel/babel](https://github.com/python-babel/babel) 。 

·文档： [http://babel.pocoo.org](http://babel.pocoo.org) 。 

·pytz（2018.4）：

·主页： [https://pypi.python.org/pypi/pytz/](https://pypi.python.org/pypi/pytz/) 。 

·文档： [http://pythonhosted.org/pytz/](http://pythonhosted.org/pytz/) 。 

·Flask-CORS（3.0.4）：

·主页： [https://github.com/corydolphin/flask-cors](https://github.com/corydolphin/flask-cors) 。 

·文档： [http://flask-cors.readthedocs.io](http://flask-cors.readthedocs.io) 。 

·Webargs（3.0.0）：

·主页： [https://github.com/sloria/webargs](https://github.com/sloria/webargs) 。 

·文档： [http://webargs.readthedocs.io](http://webargs.readthedocs.io) 。 

·Httpie（0.9.9）：

·主页： [https://httpie.org/](https://httpie.org/) 。 

·源码： [https://github.com/jakubroztocil/httpie/](https://github.com/jakubroztocil/httpie/) 。 

·文档： [https://httpie.org/doc](https://httpie.org/doc) 。 

打开一个新的命令行窗口，切换到合适的目录，然后使用下面的命令将示例程序仓库复制到本地：

------

```
$ git clone https://github.com/greyli/todoism.git

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20225.png)
提示

如果你在Todoism的GitHub页面（ [https://github.com/greyli/todoism](https://github.com/greyli/todoism) ）页面单击了Fork按钮，那么可以使用你自己的GitHub用户名来替换上面的greyli，这将复制一份属于你自己的派生仓库，你可以自由修改和提交代码。 

接着，切换进项目目录，创建虚拟环境并安装依赖，然后激活虚拟环境：

------

```
$ cd todoism
$ pipenv install --dev
$ pipenv shell

```

------

在虚拟环境中运行程序：

------

```
$ flask run

```

------

现在访问 [http://localhost:5000](http://localhost:5000) 即可体验我们即将一步步编写的最终版本的程序，通过单击登录表单下方的按钮即可获取测试账户。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2088.png)
注意

（1）本书所有的示例程序都运行在本地机的5000端口，即 [http://localhost:5000](http://localhost:5000) ，确保没有其他程序同时在运行。 

（2）因为所有示例程序的CSS文件名称、JavaScript文件名称以及Favicon文件名称均相同，为了避免浏览器对不同示例程序中同名的文件进行缓存，请在第一次运行新的示例程序后按下Crtl+F5或Shift+F5清除缓存。

你可以在本地使用文本编辑器阅读源码，或是访问Github上的程序仓库（ [https://github.com/greyli/todoism](https://github.com/greyli/todoism) ）查看。在本地阅读时，请使用下面的命令签出程序的初始版本： 

------

```
$ git checkout spa

```

------

在GitHub上则使用分支下拉列表选择spa标签。在本地使用git tag-n命令可以列出项目包含的所有标签，在对应的章节中我会给出签出提示。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 10.1  使用JavaScript和AJAX编写单页程序

在这一小节，我们会介绍Todoism的主要代码。程序本身很简单，所以这里不会详细介绍它的编写过程，而是把重点放在实现单页效果上。另外，大部分的程序功能都将使用jQuery（JavaScript）实现，我们不会详细介绍，具体可以到源码仓库中查看。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20133.png)
附注

因为JavaScript代码会在用户接收到响应后在浏览器中执行，所以我们后面经常会将JavaScript代码称为客户端JavaScript。

Todoism由程序包todoism组成，程序的项目结构使用功能式结构，程序包的目录结构如下所示：

------

```cmd
todoism/
    static/
        css/
            - style.css  CSS样式文件
        js/
            - script.js  JavaScript脚本
        favicon.ico
        demo.png 用于在首页展示的示例图片
    templates/
        - base.html 基模板
        - index.html 根页面
        - _intro.html 介绍页面
        - _login.html 登录页面
        - _app.html 程序页面
        - _item.html 条目页面
        - errors.html 错误页面
    blueprints/
            - __init__.py
        - home.py 主页蓝本
        - app.py 程序蓝本
        - auth.py 认证蓝本
    - __init__.py
    - models.py
    - extensions.py
    - settings.py

```

------

Todoism由三个蓝本组成，分别为实现主页功能的home蓝本、处理用户认证的auth蓝本以及实现程序功能的todo蓝本。为了保持简单，程序没有实现管理后台。

因为程序中的表单比较简单，所以表单直接在模板中定义，不用再编写表单类。缺点是我们需要手动处理验证，为了让验证更加动态，在客户端会首先使用JavaScript验证表单，提交后在服务器端进行二次验证。

在数据库方面，Todoism只创建了User和Item两个模型类，分别用来存储用户和待办条目，用户和条目之间建立了一对多关系，如代码清单10-1所示。

代码清单10-1 todoism/models.py：建立数据库模型

------

```
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(20), unique=True, index=True)
    password_hash = db.Column(db.String(128))
    items = db.relationship('Item', back_populates='author', cascade='all')

class Item(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    body = db.Column(db.Text)
    done = db.Column(db.Boolean, default=False)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    author = db.relationship('User', back_populates='items')

```

------

在Todoism中，除了用户首次访问程序和手动刷新外，所有的请求和操作都由客户端Java-Script代码控制，数据的交互通过AJAX处理。因此，在Flask程序中，除了主页视图（home.index）返回完整的HTML页面（即我们的根页面index.html）外，其他的视图在程序中只会接收AJAX请求，所以都仅返回局部HTML或JSON数据，以便使用JavaScript进行操作。

#### 10.1.1  单页程序的模板组织

在这个单页程序中，模板的组织稍稍有些不同。在传统的Flask程序中，大部分视图都需要返回完整的HTML文件，而单页程序中只需要加载一次完整的HTML文件，其余的请求都只需返回“局部数据”。

1.根页面

在Todoism中，因为执行页面切换和相关操作时不需要重载页面，所以模板所需要的CSS和JavaScript只需要在根页面（index.html）加载一次，这也是除错误页面以外唯一包含完整HTML结构的页面，也就是我们的“单页”。根页面中包含一个id为main的div元素（后面简称为main元素），这个div会用来填充页面主体内容。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20226.png)
提示

因为HTTP错误在服务器端处理，所以我们需要返回完整的HTML页面，错误页面模板单独定义完整的HTML结构。另外，因为错误页面比较简单，所有错误类型使用同一个errors.html模板，在错误处理函数中通过变量code和info传入错误状态码和错误提示。

为了简化CSS样式的定义，Todoism使用了基于Google Material Design（ [https://material.io/](https://material.io/) ）的Materialize（ [http://materializecss.com](http://materializecss.com) ）框架。我们需要在根页面中加载相应的Materialize资源，同时被加载的还有我们自己编写的CSS和JavaScript文件，以及依赖的jQuery库，如代码清单10-2所示。 

代码清单10-2 todoism/templates/index.html：根页面

------

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta charset="utf-8"/>
    <title>Todoism</title>
    <link href="{{ url_for('static', filename='css/materialize.min.css') }}" rel= "stylesheet">
    <link href="{{ url_for('static', filename='css/style.css') }}" rel= "style-sheet">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type= "image/ x-icon">
    <link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel= "stylesheet">
</head>
<body>
<div id="main"></div>  <!-- 用来插入子页面的div元素 -->
<script src="{{ url_for('static', filename='js/jquery.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/materialize.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/script.js') }}" type="text/javascript"></script>
<script type="text/javascript">
    var csrf_token = "{{ csrf_token() }}";
</script>
</body>
</html>

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20134.png)
附注

Material Design（材料设计）是Google在2014年开发的一门跨设备的用户界面视觉设计语言。

因为程序中使用了Materialize图标，所以我们还需要加载图标字体。Materialize使用Google提供的开源图标集Material Design Icons（ [https://material.io/icons/](https://material.io/icons/) ），一般情况下，我们可以直接使用Google字体服务器提供的资源，在根页面的<head>标签内添加下面这行代码： 

------

```
<link href="http://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20135.png)
附注

Google目前在北京建立了字体服务器，暂时不会出现无法访问或是访问速度过慢的情况。如果你想手动在本地加载字体资源，可以直接从Google Material Icons的Github仓库（ [https://github.com/google/material-design-icons/tree/master/iconfont](https://github.com/google/material-design-icons/tree/master/iconfont) ）中下载图标字体文件，在static文件夹中新建一个font子文件夹存放它们，然后在基模板中加载这些文件，并创建material-icons样式类，具体可以访问 [http://google.github.io/material-design-icons/#setup-method-2-self-hosting](http://google.github.io/material-design-icons/#setup-method-2-self-hosting) 查看。 

在HTML中，我们只需要在<i>标签中写出图标的名称即可渲染出对应名称的图标，这种特性被称为ligatures：

------

```
<i class="material-icons">face</i>

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20227.png)
提示

Google Material Icons图标集中共有900多个图标可供使用，完整的列表可以在其官方网站（ [https://material.io/icons/](https://material.io/icons/) ）获取。不过需要注意的是，material.io中的图标名称在使用时需要将单词之间的空格使用下划线代替。 

2.子页面

虽然是单页程序，并不意味着我们只能使用一个页面。程序中实际包含三个页面：介绍页、登录页和程序页，这三个页面分别在局部模板_intro.html、_login.html和_app.html中定义。这三个模板不会直接加载，而是通过AJAX请求获取并动态插到根页面中。为了便于在AJAX中发送请求到对应的URL，我们在根页面中定义了多个JavaScript变量，分别存储指向这三个页面的URL。另外，我们程序中的所有操作都通过JavaScript发送AJAX请求实现，像登录、注册、注销等这类不包含URL变量的URL，也在这里定义：

------

```
...
<script type="text/javascript">
    var login_page_url = "{{ url_for('auth.login') }}";
    var app_page_url = "{{ url_for('todo.app') }}";
    var intro_page_url = "{{ url_for('home.intro') }}";
    var new_item_url = "{{ url_for('todo.new_item') }}";
    var clear_item_url = "{{ url_for('todo.clear_item') }}";
    var login_url = "{{ url_for('auth.login') }}";
    var register_url = "{{ url_for('auth.register') }}";
    var logout_url = "{{ url_for('auth.logout') }}";
</script>

```

------

另外，为了方便组织这三个局部模板，我们也定义了一个包含导航栏和页脚部分的基模板（base.html），基模板中仅包含一个用于填充页面主体内容的content块，具体可在源码仓库中查看。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20228.png)
提示

因为没有使用Bootstrap，所以也无法使用Bootstrap-Flask扩展。这就意味着，如果CSS框架没有对应的Flask扩展可以使用，我们就需要手动编写大部分的HTML代码，或是自己编写宏。如果你积累了足够多的辅助宏，或许可以考虑实现一个扩展，关于扩展的编写我们会在第15章进行介绍。

3.条目模板

待办条目的具体HTML代码在局部模板_item.html中定义，如代码清单10-3所示。

代码清单10-3 todoism/templates/_item.html：条目模板

------

```
<div class="row item card-panel hoverable" data-href="{{ url_for('.edit_item', item_id=item.id) }}"
     data-id="{{ item.id }}" data-body="{{ item.body }}" data-done={{ item.done|tojson }}>
    <span class="item-body">
        <a class="button done-btn" data-href="{{ url_for('.toggle_item', item_id=item.id) }}">
            <i class="material-icons left">{% if item.done %}check_box{% else %}check_box_outline_blank{% endif %}</i>
        </a>
        <span class="{% if item.done %}inactive-item{% else %}active-item{% endif %}" id="body{{ item.id }}">{{ item.body }}</span>
    </span>
    <span class="hide edit-btns right">
        <a class="right button delete-btn" data-href="{{ url_for('.delete_item', item_id=item.id) }}">
            <i class="material-icons small-icon left">clear</i>
        </a>
        <a class="right button edit-btn"><i class="material-icons small-icon left">mode_edit</i></a>
    </span>
</div>

```

------

对于不同状态的条目，我们需要渲染出不同的样式。如果item.done为True，即表示已完成，那么就使用inactive-item类渲染出完成的样式，并且显示一个对号标记（check_box）；如果item.done为False，即表示未完成，这时使用active-item，同时也会显示勾选框图标（check_box_outline_blank）。两者的区别如图10-1所示。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAW-EEwnUAAAAAE-6gJ0115924159.jpg)
图10-1 根据完成状态显示不同的条目样式

另外，为了让JavaScript可以操控条目，我们需要提供每个条目的详细信息，比如条目的状态、id、编辑URL、删除URL。这些信息使用data-*属性渲染在每个条目的顶层标签内，其中表示条目是否完成的item.done属性后使用了Flask内置的tojson过滤器，因为Python中的布尔值和JavaScript中的布尔值（全小写形式的true和false）不同，所以需要使用tojson过滤器将变量值转换为JSON格式。

#### 10.1.2  在根页面内切换子页面

在Todoism中，用户首次访问程序后会加载index.html页面，之后除非用户手动刷新，我们不再需要重载页面。index.html就是我们创建的“单页”，所有的请求都使用AJAX在后台处理，所有的页面元素的更新和切换都在这个基础页面上使用JavaScript进行。也就是说，Flask的视图函数的功能退化为提供数据的内部接口，而真正的视图处理则转移到了客户端JavaScript中。

在单页程序中，我们需要确保用户刷新页面后仍然会显示上一个状态。也就是说，在单页面中切换子页面时，我们希望这些子页面变化时也产生一个可以被保存为书签并且添加到浏览器历史的URL，而且使浏览器的前进、后退按钮发挥作用。为了让程序的状态在URL中表现出来，我们通过在URL后面添加hash（即URL中#后面的部分）来记录状态。程序中的三个主要页面使用对应的hash标签表示，比如导航栏上的登录按钮：

------

```
<a class="waves-effect waves-light btn red" href="#login">Login</a>

```

------

单击这个按钮，会访问#login，产生的URL类似 [http://example.com#login](http://example.com#login) ，表示登录页面。 

在URL中添加hash不会产生请求，而我们可以通过监听hash的变化来设置回调函数来更新页面。我们创建一个hashchange事件的监听函数，用于在hash值改变时执行对应的函数，如代码清单10-4所示。

代码清单10-4 todoism/static/js/script.js：hashtag监听函数

------

```
$(window).bind("hashchange", function () {
    // 有些浏览器不返回#，这里统一去掉#
    var hash = window.location.hash.replace('#', '');
    var url = null;
    // 根据hash值的不同，选择对应的页面URL
    if (hash === 'login') {
        url = login_page_url  // 这些变量存储对应页面的URL，在根页面定义
    } else if (hash === 'app') {
        url = app_page_url
    } else {
        url = intro_page_url
    }
    // 向对应的页面URL发送GET请求，服务器端会返回对应的局部模板
    $.ajax({
        type: 'GET',
        url: url,
        success: function (data) {
            $('#main').hide().html(data).fadeIn(800);  // 插入子页面
            activeM();  // 激活新插入的页面中的Materialize组件
        }  // 错误回调已经统一设置，不需要定义error回调
    });
});

```

------

当URL中的hash改变时，就根据hash的值选择对应的URL，然后向这个URL发起AJAX GET请求，获取到数据后替换到main元素中，起到动态切换页面的效果。比如，当单击登录按钮时，URL中会添加#login，这时会触发这个监听函数，login对应的URL定义在login_page_url变量，对应的值即/login。这个函数发送GET请求到/login，在Flask程序中触发login视图，这个视图返回渲染后的局部模板_login.html。接收到成功响应会触发success回调函数，然后把返回值插到main元素中，页面切换为登录页面。

我们需要使用下面的代码初始化程序：

------

```
if (window.location.hash === '') {
    window.location.hash = "#intro"; // 显示主页
} else {
    $(window).trigger("hashchange"); // 触发hashchange事件，重新加载页面
}

```

------

当用户第一次访问程序时，如果hash值为空则默认添加一个#intro标签，这会将介绍页面的内容加载到main元素中。如果hash不为空（比如用户刷新页面），则保存原标签不变。触发hashchange事件，在重载后仍然会显示当前页面。

当我们执行其他操作后需要切换页面时，通过切换URL中的hash（通过window.location.hash）即可切换页面。比如，当用户单击登录按钮时，如果验证通过，我们在发送AJAX请求的success回调函数中将hash设为对应程序页面的App，就可以切换到App页面：

------

```
success: function (data) {
    window.location.hash = "#app";
    ...

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20229.png)
提示

因为程序非常简单，除了错误页面外只包含三个独立页面，而待办条目不需要设置hash，所以我们使用JavaScript手动处理hash。在大型程序中，面对更复杂的需求可以使用插件jQuery BBQ（ [http://benalman.com/projects/jquery-bbq-plugin/](http://benalman.com/projects/jquery-bbq-plugin/) ）解决该问题。比如，相册程序使用AJAX切换图片，使用jQuery BBQ可以非常容易地为每一张图片设置一个包含hash的URL。 

#### 10.1.3  生成测试账户

因为Todoism非常简单，编写它主要是为了作为讲解相关内容的示例，大部分功能都做了简化。比如，我没有为它添加账户注册功能。为了方便想要体验程序功能的用户登录，在处理注册的register视图中，我们生成了一个测试账户和虚拟待办条目数据，如代码清单10-5所示。

代码清单10-5 todoism/blueprints/auth.py：生成虚拟账户

------

```
@auth_bp.route('/register')
def register():
    username = fake.user_name()
    # 确保生成的随机用户名不重复
    while User.query.filter_by(username=username).first() is not None:
        username = fake.user_name()
    password = fake.word()
    user = User(username=username)
    user.set_password(password)
    db.session.add(user)
    db.session.commit()
    # 添加几个待办条目作为示例
    item = Item(body=_('Witness something truly majestic'), author=user)
    item2 = Item(body=_('Help a complete stranger'), author=user)
    item3 = Item(body=_('Drive a motorcycle on the Great Wall of China'), author=user)
    item4 = Item(body=_('Sit on the Great Egyptian Pyramids'), done=True, author=user)
    db.session.add_all([item, item2, item3, item4])
    db.session.commit()
    return jsonify(username=username, password=password, message='Generate success.')

```

------

在register视图中，我们生成了一个用户记录，用户名和密码随机生成。同时为了方便测试，我们添加了4个待办条目，其中1个被标记为完成状态，最后将这些数据保存到数据库中。需要注意的是，这个视图函数既不使用render_template()函数渲染模板，也不使用redirect()进行重定向。取而代之的是，使用jsonify()函数返回JSON格式的用户名、密码和提示消息。

在_login.html模板中，我们添加一个链接用来获取随机生成的测试账户：

------

```
<p><a class="blue-text link button" id="register-btn">Get a test account</a></p>

```

------

当这个按钮被单击时，会触发一个JavaScript回调函数。在这个函数中，我们发送一个AJAX GET请求到register视图，register视图的URL存储在根页面定义的register_url变量中，如代码清单10-6所示。

代码清单10-6 todoism/static/js/script.js：获取虚拟账户信息

------

```
function register() {
    $.ajax({
        type: 'GET',
        url: register_url,
        success: function (data) {
            $('#username-input').val(data.username);  // 将用户名插入用户名字段
            $('#password-input').val(data.password);  // 将密码插入密码字段
            M.toast({html: data.message})  // 弹出提示消息
        }
    });
}

$(document).on('click', '#register-btn', register);

```

------

当服务器端返回2XX响应时，success回调函数被调用，这个回调函数的第一个参数即为服务器端返回的数据，因为服务器端返回JSON格式的数据，这个参数值会被解析为JSON对象。在这个函数中，我们从服务器端返回的数据中获取用户名和密码，然后填充到对应的表单字段中；当服务器端返回4XX和5XX响应时，error回调函数被调用。和Albumy类似，我们使用$.ajaxError()方法设置了统一的AJAX错误处理函数，它使用Materialize提供的M.toast()函数弹出错误提示。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20230.png)
提示

M.toast()是Materialize提供的消息闪现方法，我们使用它来向用户显示消息。常用的三个选项为html、displayLength和classes。html选项用来设置显示的文本；displayLength选项用来设置消息的停留时间，单位为毫秒；classes选项可以设置额外的CSS类，比如，通过传入值“rounded”可以将消息的外观设为椭圆形边框。更多用法可以访问 [http://materializecss.com/toasts.html](http://materializecss.com/toasts.xhtml) 查看。 

#### 10.1.4  添加新待办条目

待办条目的创建、编辑、标记完成和删除都在程序页面完成，主要逻辑都通过客户端JavaScript代码实现，这里不再详细讲解，仅以添加条目为例。在Flask程序中，用于添加新待办条目的new_item视图的实现如下所示：

------

```
@todo_bp.route('/items/new', methods=['POST'])
@login_required
def new_item():
    data = request.get_json()
    if data is None or data['body'].strip() == '':
        jsonify(message='Invalid item body.'), 400
    item = Item(body=data['body'], author=current_user._get_current_object())
    db.session.add(item)
    db.session.commit()
    return jsonify(html=render_template('_item.html', item=item), message='+1')

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20231.png)
提示

这个视图使用methods参数设置为仅监听POST方法的请求。顺便说一句，AJAX支持发送DELETE、PATCH等类型的请求，删除操作就使用了DELETE请求，在对应的delete_item视图，我们通过methods参数设置仅监听DELETE请求。

我们使用request.get_json()方法从请求对象中获取并解析客户端发送的JSON数据，解析后的JSON数据会是一个Python字典，我们可以通过在客户端JavaScript代码中定义的键来获取对应的值。虽然我们在客户端可以使用JavaScript验证表单数据，但是为了确保安全，我们还需要在服务器端对数据进行验证。如果body为None或为空，我们会返回400错误响应，传入JSON格式的错误消息。

当数据通过验证，我们创建新的待办条目并保存到数据库，然后渲染表示待办条目的局部模板（_item.html），并传入该待办条目对象，最后返回与该待办条目对应的HTML代码。客户端获取返回值后可以直接将其插入页面中，不需要做任何处理。

在客户端的JavaScript代码中，我们创建了一个监听函数，当在创建新条目的输入框中按下按键时会触发new_item()函数：

------

```
var ENTER_KEY = 13;
$(document).on('keyup', '#item-input', new_item.bind(this));

```

------

new_item()函数的实现如代码清单10-7所示。

代码清单10-7 todoism/static/js/script.js：创建新条目

------

```
function new_item(e) {
    var $input = $('#item-input');
    var value = $input.val().trim();  // 获取输入值
    if (e.which !== ENTER_KEY || !value) {
        return;  // 如果Enter键没有按下或输入值为空，就什么都不做
    }
    $input.focus().val('');  // 聚焦到输入框并清空内容
    $.ajax({
        type: 'POST',
        url: new_item_url,
        data: JSON.stringify({'body': value}),  // 用输入值生成JSON字符串
        contentType: 'application/json;charset=UTF-8',
        success: function (data) {
            M.toast({html: data.message, classes: 'rounded'});
            $('.items').append(data.html);  // 把返回条目的HTML代码插入页面
            activeM();  // 激活新插入HTML的Materialize组件
            refresh_count();  // 更新页面上的各个计数
        }
    });
}

```

------

在new_item()函数中，我们首先对输入框中的数据以及触发的按钮进行验证，如果按下的按键不是Enter键或输入数据为空，就什么都不做。如果验证通过，那么就发送一个AJAX POST请求到new_item视图。$.ajax()函数中的参数和发送GET请求时的基本相同，只不过把type参数值换为“POST”，并使用data参数指定请求主体。和我们在视图函数中返回JSON数据的jsonify类似，JavaScript中的JSON.stringify()方法也可以将JavaScript中的数据对象转换为标准的JSON字符串。

因为我们在视图函数中使用request.get_json()方法获取数据，所以在客户端发送POST请求时必须设置正确的Content-Type首部。在ajax()函数中，Content-Type首部使用contentType参数设置，JSON对应的值为'application/json；charset=UTF-8'。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20136.png)
附注

我们在第4章介绍过数据类型。当数据以GET方法提交时，会和往常一样以查询字符串的形式附加在请求URL中。在视图函数中，我们可以通过request.args属性获取。而在提交POST请求时，如果你没有指定内容类型为JSON，那么数据会以默认的表单类型（即application/x-www-form-urlencoded）提交，在视图函数中需要从request.form属性中获取数据。

在success回调函数中显示提示消息，然后调用refresh_count()函数更新页面上的计数。当创建成功时，视图函数会返回包含新创建待办条目的HTML代码，我们使用append()方法将数据追加到与页面items类对应元素的末尾，这会将新条目添加到条目列表的结尾。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 10.2  国际化与本地化

在编程中，国际化（Internationalization）和本地化（Localization）是指为程序添加对不同区域（locale）的支持，而且可以根据某个特定的区域而进行转换。这样可以让我们基于World Wide Web的程序真正做到Worldwide。根据单词的长度和首尾字母，这两个单词通常分别被缩写为I18n和L10n。具体来说，这两个名词分别表示两个不同的过程：

·国际化：国际化指设计和修改程序以便让程序支持多种语言或区域，而不是固定于某一个语言或区域。国际化为本地化做了程序上的准备。

·本地化：本地化指为程序添加某些资源（比如翻译文件）以便支持某个特定的语言或区域。本地化通常会进行多次，比如要支持10种语言，那么就要进行10次本地化处理。

这一节我们将为程序添加更完整的国际化和本地化支持，这次的重点是为程序添加多语言支持。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20232.png)
提示

如果你从GitHub上复制了示例程序，可以执行git checkout i18n签出程序的新版本。程序的新版本添加了多区域支持。

#### 10.2.1  使用Flask-Babel集成Babel

我们将使用Babel来实现程序的国际化和本地化。Babel是Pocoo团队开发的为Web程序实现国际化和本地化的Python工具集。它基于Python标准库的gettext模块以及用于转换时区的pytz库实现。另外，它基于Common Locale Data Repository（ [http://unicode.org/cldr/](http://unicode.org/cldr/) ）内置了语言名称、日期时间、时区等多种语言的翻译数据，这些特性极大简化了对程序进行国际化和本地化处理的过程。 

我们将使用集成了Babel的扩展Flask-Babel来简化操作，首先使用Pipenv对其进行安装：

------

```
$ pipenv install flask-babel

```

------

然后在程序中初始化扩展，首先在extensions模块中实例化扩展类Babel：

------

```
from flask_babel import Babel
babel = Babel()

```

------

然后在工厂函数中调用init_app()初始化扩展：

------

```
from todoism.extensions import babel

def create_app():
    app = Flask(__name__)
    ...
    register_extensions(app)
    return app

def register_extensions(app):
    ...
    babel.init_app(app)

```

------

#### 10.2.2  区域和语言

在开始编写相关代码前，我们要先了解两个重要的概念——区域（locale）和语言（language）。这里之所以单独列出一节介绍区域和语言，是因为很多教程和资料都混淆了这两者。在国际化和本地化概念中，我们是为程序添加多个区域的支持，而不仅仅是多语言的支持。区域包括某个国家地区的语言、文字、时区、时间格式、计量单位、货币、标志等，是一个更广泛的概念。

1.语言代码和区域代码

我们使用语言代码（language code/tag/ID）和区域代码（locale code/locale ID）来区分不同的区域和语言。我们最常见到的语言代码有zh和en，分别表示中文和英文，这种由两个字母组成的语言代码在ISO 639？1中定义。为了覆盖这些语言大类下的各种分支，IETF在BCP 47中定义了更系统的语言标签形式，通过添加各种子标签，我们可以更具体地描述某种语言。比如，添加语言的脚本（script）标签，zh-Hans和zh-Hant分别表示简体中文和繁体中文；通过添加国家/地区标签，en-US，en-GB分别表示美国英语和英国英语；类似的，zh-CN、zh-TW和zh-HK则分别表示中国大陆简体中文，中国台湾繁体中文和中国香港繁体中文。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20233.png)
提示

（1）关于中文各地区版本的语言代码存在较多争议，主要认为zh、zh-CN等用法表意不明，但目前这些用法仍然被广泛使用。

（2）关于语言代码的语法细节可以参考IETF发布的BCP 47（ [http://www.rfc-editor.org/rfc/bcp/bcp47.txt](http://www.rfc-editor.org/rfc/bcp/bcp47.txt) ）或访问W3C（ [https://www.w3.org/International/articles/language-tags/](https://www.w3.org/International/articles/language-tags/) ）。BCP即Best Current Practice（当前最佳实践），是由多个RFC组成的文档。 

区域代码（locale code）则用来表示某一个区域的语法形式和语言代码类似。最简单的形式即使用ISO 639-1中定义的两个字母组成的语言代码表示，比如zh、en等。另外一种常见的形式是附加了国家/地区代码的形式，其使用下划线将语言代码与国家/区域连接起来，比如en_US，zh_CN、zh_TW，另外还有添加语言脚本的形式，比如zh_Hans_CN、zh_Hant_TW等。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2089.png)
注意

语言代码中添加国家/区域代码时的连接符是连接线（hyphen），而区域代码使用下划线（underscore）。

在程序中使用Babel实现i18n时，要根据Babel支持的区域来设置区域代码，通过下面的命令查看Babel支持的区域代码：

------

```
$ pybabel --list-locales
...
zh               Chinese
zh_Hans         Chinese (Simplified)
zh_Hans_CN      Chinese (Simplified, China)
zh_Hans_HK      Chinese (Simplified, Hong Kong SAR China)
zh_Hans_MO      Chinese (Simplified, Macau SAR China)
zh_Hans_SG      Chinese (Simplified, Singapore)
zh_Hant         Chinese (Traditional)
zh_Hant_HK      Chinese (Traditional, Hong Kong SAR China)
zh_Hant_MO      Chinese (Traditional, Macau SAR China)
zh_Hant_TW      Chinese (Traditional, Taiwan)

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2090.png)
注意

Babel中的区域码从1.0版本开始采用添加语言脚本（script）子标签（subtags）的形式，去掉了zh_CN和zh_TW。

在输出的列表的最后可以看到多个关于中文的区域代码，我们根据需要可以选用其中表示简体中文的zh_Hans_CN。

为了表示我们要在程序中支持的区域，需在配置文件中创建一个LOCALES变量，存储要支持的区域代码列表，区域代码使用包含了国际/地区代码的形式：

------

```
TODOISM_LOCALES = ['en_US', 'zh_Hans_CN']

```

------

作为一个简单的示例程序，我打算只让它支持两种区域，在现实的程序中，你可以添加更多区域。

2.设置区域

为了能够支持用户设置自己的区域，我们在数据库User模型中创建了一个locale字段，用来存储区域代码。我们希望登录后的用户和匿名用户都可以设置区域，所以用来设置区域的视图在home蓝本中创建，匿名用户的locale设置保存到cookie中，如代码清单10-8所示。

代码清单10-8 todoism/blueprints/home.py：设置区域

------

```
@home_bp.route('/set-locale/<locale>')
def set_locale(locale):
    if locale not in current_app.config['TODOISM_LOCALES']:
        return jsonify(message='Invalid locale.'), 404

    response = make_response(jsonify(message='Setting updated.'))
    if current_user.is_authenticated:
        current_user.locale = locale
        db.session.commit()
    else:
        response.set_cookie('locale', locale, max_age=60 * 60 * 24 * 30)
    return response

```

------

这个视图的实现和我们在第8章为程序添加主题切换功能时的set_theme视图基本相同，只不过因为要接收AJAX请求所以需要做一些跳转。区域代码通过URL变量获取。我们首先判断区域代码是否在我们设置的LOCALES列表中，如果出错就返回JSON格式的错误响应。登录的用户会把区域代码存储在User数据库模型的locale字段中，匿名用户的区域代码则存储到cookie中，这样用户下次访问时仍然会使用上一次选择的区域。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20234.png)
提示

在客户端JavaScript中，我们在发送切换语言的AJAX请求的success回调函数中使用$（window）.trigger（"hashchange"）；触发hashchange事件，这样可以实现对原页面的动态更新，具体可以到源码仓库中查看。

3.显示区域列表

在页面上，有很多方式可以实现区域选择功能。比如，你可以创建一个新的页面或模态框渲染所有可用的区域选项，也可以在程序登录页面添加相应的按钮，或是在设置页面、导航栏、页脚添加下拉列表。因为我们的程序比较简单，所以可通过在导航栏上添加一个下拉列表来实现，如代码清单10-9所示。

代码清单10-9 todoism/templates/base.html：语言下拉列表

------

```
<li><a class="waves-effect waves-light dropdown-button" href="#!" data-activates= "locale-dropdown"><i class="material-icons">language</i></a></li>
...
<ul id="locale-dropdown" class="dropdown-content">
    <li><a class="lang-btn" data-href="{{ url_for('home.set_locale', locale='zh_Hans_CN') }}">简体中文</a></li>
    <li><a class="lang-btn" data-href="{{ url_for('home.set_locale', locale='en_US') }}">English</a></li>
</ul>

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20235.png)
提示

Materializecss使用JavaScript实现下拉列表。在HTML中，普通的下拉列表使用select标签和option标签实现。

因为程序比较简单，这里没有从配置变量迭代选项，而是直接手动写出。如果有大量的区域可供选择，比如你的程序支持30个区域，这时手动渲染就不是个好办法了。Babel提供了一个Locale类，可以用来解析一个区域，并使用它来获取各种区域数据，下面是一些使用示例：

------

```
>>> from babel import Locale
>>> l = Locale.parse('zh_Hans_CN')  # 解析zh_Hans_CN创建区域对象l
>>> l
Locale(u'zh', territory='CN', script=u'Hans')
>>> l.get_display_name()  # 区域显示名称
u'中文 (简体, 中国)'
>>> l.get_display_name('en_US')  # 该区域在en_US区域中的显示名称
u'Chinese (Simplified, China)'
>>> l.get_language_name()  # 语言名称
u'中文'
>>> l.get_language_name('de_DE')  # 该语言在de_DE区域中的名称
u'Chinesisch'
>>> l.get_territory_name()  # 地区名称
u'中国'
>>> l.get_territory_name('it_IT')  # 该地区在it_IT区域中的名称
u'Cina'

```

------

在上面的代码中，调用Locale.parse()方法来解析一个区域代码并获得对应的区域实例，对这个区域实例调用get_display_name()可以获取与区域对应的国家/地区的名称，你可以通过传入区域代码来显示不同区域的对应名称。类似的，调用get_language_name()方法可以获取对应的语言名称。除此之外，你还可以通过这个区域实例的诸多属性和方法获取时间日期名称、月份名称、格式、货币格式等，这里不再展开介绍，具体可以参考Babel的官方文档（ [http://babel.pocoo.org/en/latest/locale.html](http://babel.pocoo.org/en/latest/locale.xhtml) ）。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20236.png)
提示

我们可以将这个Locale类通过模板处理函数添加到模板上下文中，然后在模板中迭代我们的TODOISM_LOCALES列表中的区域代码，然后渲染对应的名称和语言。

通过上面介绍的这些方法，你可以迭代所有支持的区域列表，并且让每个区域都使用各自的语言来显示区域所在国家/地区的名称和语言。

4.获取区域

当程序进行完国际化和本地化处理后，它就可以在不同的区域内转换对应的语言、时间、单位。以文本为例，当我们对程序中文本进行处理并添加了翻译后，Flask-Babel会根据区域来选择对应的翻译文本。为此我们需要使用Flask-Babel的Babel实例提供的localeselector装饰器注册一个区域获取函数，它会在处理每一个请求时被调用，如代码清单10-10所示。

代码清单10-10 todoism/extensions.py：设置区域选择函数

------

```
@babel.localeselector
def get_locale():
    if current_user.is_authenticated and current_user.locale is not None:
        return current_user.locale

    locale = request.cookies.get('locale')
    if locale is not None:
        return locale
    return request.accept_languages.best_match(current_app.config['TODOISM_LOCALES'])

```

------

这个函数返回TODOISM_LOCALES列表中的某个区域代码。如果当前用户已经登录而且locale属性不为None，那么返回用户对象的locale属性值；如果当前用户未登录，从cookie中的locale键值获取区域代码；如果cookie中没有locale键，返回下面这行代码：

------

```
request.accept_languages.best_match(current_app.config['TODOISM_LOCALES'])

```

------

request请求对象的accept_languages存储的是请求首部中的Accept-Language字段的值，这个值存储了发出请求的客户端（浏览器）的语言偏好。具体来说，这个值是一个按优先级排列的语言代码列表，比如：

------

```
zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7

```

------

这个字段的值根据浏览器的语言设置生成，每一个语言代码通过逗号分隔，其中的q表示对应语言的q-factor weighting（权重），第一个语言的权重默认为1.0。上面的代码在Chrome浏览器中的设置如图10-2所示。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAW-EEThQAAAAAPwdWeM597528304.jpg)
图10-2 Chrome中的语言选项

虽然语言代码和区域代码非常相似，但是如果想用这个字段值中的语言代码与我们的区域代码进行匹配还是非常麻烦的。还好我们可以使用best_match()方法完成这个匹配工作，只需传入TODOISM_LOCALES列表，最先匹配到的区域代码将被返回。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20237.png)
提示

对于简单的程序，你也可以仅从请求首部的Accept-Language字段来匹配区域代码。

如果区域选择函数返回None，那么Flask-Babel将使用我们通过BABEL_DEFAULT_LOCALE配置变量设置的区域代码。因此，我们需要将Flask-Babel提供的BABEL_DEFAULT_LOCALE配置变量设为程序的默认区域，即TODOISM_LOCALES变量的第一个元素en_US：

------

```
BABEL_DEFAULT_LOCALE = TODOISM_LOCALES[0]

```

------

对于其他提供国际化和本地化支持的扩展，我们希望能够统一区域设置。Flask-Babel提供了一个get_locale()函数，可以用来获取当前请求/用户的区域代码，即区域获取函数的返回值。我们可以将这个返回值传递给扩展的相关配置。还有一些扩展会自动调用这个函数获取区域码，比如Flask-WTF。

#### 10.2.3  文本的国际化

在对时间日期进行国际化处理时，我们把固定时区的时间换成了通用的UTC时间。而在对文字进行国际化处理时，我们需要对程序中所有需要翻译的文本进行处理。这里的处理就是使用函数把这些字符串包装起来，以支持本地化处理。包装起来有两个作用：一是在本地化时可以自动把这些文本提取出来，以供添加对应的翻译文本；二是在运行代码时可以根据区域设置来替换这些文本。

1.在Python源码中标记文本

在Python源码中，我们使用Flask-Babel提供的gettext()函数来标记需要被翻译的字符串，比如下面这行代码：

------

```
flash(u' 文章发表成功！ ')

```

------

将被替换为：

------

```
from flask_babel import gettext
flash(gettext(u' 文章发表成功！ '))

```

------

按照约定，一般使用_()来表示gettext()，所以你也可以使用下画线来替代gettext：

------

```
from flask_babel import _
flash(_(u' 文章发表成功！ '))

```

------

对于英文等单复数包含单词变化的语言，你也可以使用ngettext()函数来标记字符串：

------

```
flash(ngettext(u'%(num)s Apple', u'%(num)s Apples', num=number_of_apples))

```

------

这时你需要传入两个字符串，依次为单数形式和复数形式的字符串，其中包含用于区分单复数的变量num，第三个参数则传入代表num数值的变量。

如果字符串中包含变量，则这时需要使用特定的语法，比如下面的代码：

------

```
flash(u' 文章《%s》发表成功！ ' % post_name)

```

------

需要被替换为：

------

```
from flask_babel import _
flash(_(u' 文章《%(post_name)s》发表成功！ ', post_name=post_name))

```

------

最后还需要注意的是，Flask-Babel只会在存在请求上下文时才会调用区域选择函数获取区域和获取翻译，也就是说，只有在处理请求时才会翻译文本。对于某些请求之外的字符串，比如表单类中的字段名和错误消息，在程序启动时就会被调用，但这时无法获取区域，所以也无法被正确处理。这时我们需要使用Flask-Babel提供的lazy_gettext()函数来替代gettext()，它是延迟计算（lazy evaluation）版本的gettext，这样被标记的字符串会在真正被使用时才被翻译，如下所示：

------

```
from flask_babel import lazy_gettext as _l

class LoginForm(FlaskForm):
    username = StringField(_l('Username'), validators=[DataRequired()])
    ...

```

------

为了方便使用，我们在导入时将lazy_gettext()函数简记为_l。

2.在模板中标记文本

当我们调用init_app方法对Flask-Babel进行初始化时，它会为Jinja2开启内置的jinja2.ext.i18n扩展，并进行相关的设置，所以我们可以直接在模板中使用gettext()函数及其简写形式。比如下面的代码：

------

```
<h1>Join now</h1>

```

------

需要替换为：

------

```
<h1>{{ _('Join now') }}</h1>

```

------

字符串中包含变量时修改的方式和在Python源码中相同：

------

```
<h1>{{ _('Welcome, %(username)s!', username=current_user.username) }}</h1>

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20238.png)
提示

如果你签出了项目仓库的i18n标签，可以在程序中的Python脚本和模板中查看所有标记。

#### 10.2.4  文本的本地化

按照约定，待翻译的文本被称为message（消息），包含所有消息的文件被称为message catalog（消息目录）。消息目录最后将会被存储在PO（Portable Object，可移植对象）和MO（Machine Object，机器对象）文件中，前者是面向开发者或翻译人员的可编辑文件，而后者是由PO文件编译器生成的供机器读取的二进制文件。这些文件的格式以及相应的工作流程在GUN gettext工具（ [http://www.gnu.org/software/gettext/](http://www.gnu.org/software/gettext/) ）和GNU翻译项目（ [http://sourceforge.net/projects/translation](http://sourceforge.net/projects/translation) ）中定义，你可以阅读GNU提供的gettext手册（ [https://www.gnu.org/software/gettext/manual/gettext.html](https://www.gnu.org/software/gettext/manual/gettext.xhtml) ）了解详细内容。 

为程序实现文本的本地化，即为特定的区域构建消息目录，这个过程的主要步骤如下：

1）从Python源码、模板等文件中提取所有被标记的文本，生成POT文件（messages.pot），即PO模板（Template）。

2）为某个区域生成消息目录（messages.po）。

3）编辑消息目录，翻译提取出的文本。

4）编译PO文件，生成MO文件。

1.提取待翻译文本

因为我们打算支持两种语言，除了本身使用的英文，我们还希望支持简体中文，所以只需要进行一次本地化过程。我们需要从脚本中提取出所有待翻译的文本，这时就要在项目根目录下创建一个babel.cfg文件作为Babel的配置文件。在babel.cfg中声明包含这些待翻译文本的文件模式，如下所示：

------

```
[python: todoism/**.py]
[jinja2: todoism/templates/**.html]

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20239.png)
提示

如果你为Jinja2开启了额外的扩展，为了让Flask-Babel可以正确处理模板文件，你需要在babel.cfg中新建一行使用extensions关键字声明的扩展列表，比如extensions=jinja2.ext.do。从Jinja2 2.9开始，jinja2.ext.autoescape和jinja2.ext.with_都变为内置扩展。如果你使用的Jinja2版本小于2.9，还需要声明这两个扩展。

现在，使用pybabel extract命令提取所有待翻译文本：

------

```
$ pybabel extract -F babel.cfg -k _l -o messages.pot .

```

------

这会将所有的Python脚本和HTML模板中使用gettext()等函数包装的字符串提取出来：-F babel.cfg表示使用babel.cfg文件中的设置；-k_l表示除了查找使用gettext和_标记的字符串，还要提取使用_l函数标记的字符串；-o messages.pot.表示把消息模板输出到当前目录的messages.pot文件中。

2.生成消息目录并添加翻译

我们先不用关心messages.pot的内容，下面使用pybabel init命令来为特定的区域创建消息目录：

------

```
$ pybabel init -i messages.pot -d todoism/translations -l zh_Hans_CN
creating catalog todoism/translations/zh_Hans_CN/LC_MESSAGES/messages.po based on messages.pot

```

------

这会根据messages.pot的内容生成一个message.po文件：-i messages.pot表示基于messages.pot文件；-d todoism/translations声明生成的存储消息目录的translations文件夹的位置，这里需要在程序包的根目录中创建translations文件夹；-l用来声明区域代码。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2091.png)
注意

翻译文件夹需要在templates文件夹旁生成，所以我们将路径指定在程序包内，即todoism/translations。

这会在todoism/translations/zh_Hans_CN/LC_MESSAGES/目录下创建一个messages.po文件，这个文件表示zh_Hans_CN区域的消息目录，我们需要编辑这个文件以添加对应的翻译。省略开头自动生成的元信息（其中的占位字符可以按照情况修改），需要我们编辑的内容示例如下所示：

------

```
#: todoism/extensions.py:12
msgid "Please login to access this page."
msgstr ""

#: todoism/templates/_app.html:6
msgid "What needs to be done?"
msgstr ""
#: todoism/templates/_app.html:13
msgid "All"
msgstr ""

#: todoism/templates/_app.html:18
msgid "Active"
msgstr ""

#: todoism/templates/_app.html:23
msgid "Done"
msgstr ""
...

```

------

每一条要翻译的消息都由三部分组成，示例如下：

------

```
#: 消息所在的文件名与代码行数
msgid "提取出来待翻译的消息正文"
msgstr "填入翻译文本"

```

------

我们要做的就是在每一个消息的msgstr字段后填上对应的翻译文本，比如：

------

```
#: todoism/extensions.py:12
msgid "Please login to access this page."
msgstr "请先登录。"

#: todoism/templates/_app.html:6
msgid "What needs to be done?"
msgstr "你想做些什么？"

#: todoism/templates/_app.html:13
msgid "All"
msgstr "全部"

#: todoism/templates/_app.html:18
msgid "Active"
msgstr "未完成"

#: todoism/templates/_app.html:23
msgid "Done"
msgstr "已完成"

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20240.png)
提示

除了手动使用文本编辑器编辑PO文件外，你也可以使用PO编辑器工具Poedit（ [https://poedit.net/](https://poedit.net/) ），或是使用Emacs或Vim等编辑器的PO插件。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20241.png)
提示

通过翻译文本，我们甚至可以为不同的语言区域使用不同的图片。比如，在介绍页面的模板中，我们对图片的路径字符串也进行标记：<img src="/Users/cooper/Library/Mobile%20Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/%7B%7Burl_for%EF%BC%88%27static">。在翻译时我们就可以给出不同语言下的图片路径，从而使用不同的图片，中文的消息目录中使用了demo_zh.png，它对应一个中文的示例图片。如果你启动了示例程序，打开介绍页面并尝试切换语言，你会看到介绍图片也会随之更换。

3.编译MO文件并调试

编辑好PO文件后，在开始调试程序的多语言支持前，我们需要编译PO文件生成MO文件，Flask-Babel会通过MO文件读取对应的翻译。我们使用pybabel compile命令生成MO文件，使用-d选项传入translations文件夹的路径：

------

```
$ pybabel compile -d todoism/translations
compiling catalog todoism/translations/zh_Hans_CN/LC_MESSAGES/messages.po to todoism/translations/zh_Hans_CN/LC_MESSAGES/messages.mo

```

------

现在，我们可以启动程序，然后使用导航栏上的对应按钮来切换区域，页面上的文本语言也会随之切换，图10-3所示是切换到中文的程序页面。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAW-EPtDRAAAAAHtoCxY312705404.jpg)
图10-3 切换到中文

4.更新翻译

在很多种情况下，我们会需要更新翻译。如果你仅仅需要修改消息目录中的翻译或元信息，那么为了更新翻译，你要做的仅仅是重新编译消息目录，即message.po文件。

但是，如果你修改了程序中待翻译文本的原文，或是新标记了其他文本，为了让这些更改生效，你需要重新提取所有文本生成的POT文件，然后使用pybabel update命令来执行自动合并和更新：

------

```
$ pybabel extract -F babel.cfg -k _l -o messages.pot .
$ pybabel update -i messages.pot -d todoism/translations

```

------

对于产生冲突的消息，Flask-Babel会为其添加一个fuzzy注释，你需要手动检查消息目录，修改翻译，并删掉fuzzy注释才可以重新编译。

5.创建翻译命令组

因为创建消息目录这一系列命令的内容基本是固定的，所以为了简化输入命令的步骤，我们将为这几个命令创建自定义flask命令。因为这几个命令都用于翻译文本，我们可以使用app.cli.group()装饰器为这几个命令创建一个命令组：

------

```
@app.cli.group()
def translate():
    """Translation and localization commands."""
    pass

```

------

这个命令组仅用来组织一系列翻译命令，所以它的内容为空。其他子命令使用@translate.command()装饰器注册，这些子命令在使用时通过flask translate<子命令>的形式调用。

用来实现翻译工作流程的三个命令函数如代码清单10-11所示。

代码清单10-11 todoism/__init__.py：翻译命令函数

------

```
@translate.command()
@click.argument('locale')
def init(locale):
    """Initialize a new language."""
    if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
        raise RuntimeError('extract command failed')
    if os.system(
            'pybabel init -i messages.pot -d todoism/translations -l ' + locale):
        raise RuntimeError('init command failed')
    os.remove('messages.pot')

@translate.command()
def update():
    """Update all languages."""
    if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
        raise RuntimeError('extract command failed')
    if os.system('pybabel update -i messages.pot -d todoism/translations'):
        raise RuntimeError('update command failed')
    os.remove('messages.pot')

@translate.command()
def compile():
    """Compile all languages."""
    if os.system('pybabel compile -d todoism/translations'):
        raise RuntimeError('compile command failed')

```

------

在这几个命令函数中，init()函数用来提取翻译文本并创建消息目录，接收区域代码作为命令参数，比如：

------

```
$ flask translate init <locale>

```

------

update()函数用来重新提取翻译文本并更新消息目录：

------

```
$ flask translate update

```

------

compile()函数用来编译PO文件：

------

```
$ flask translate compile

```

------

对应的命令使用OS模块提供的system()函数执行，如果执行失败则抛出RuntimeError异常。因为messages.pot文件只是存储消息目录的临时模板文件，在init()和update()函数末尾会使用os.remove()删除这个文件。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20137.png)
附注

你可以调用flask translate --help查看命令组的组织结构和通过文档字符串生成帮助信息。

#### 10.2.5  时间与日期的本地化

在第7章，我们已经通过Moment.js为程序实现了日期与时间的国际化和本地化。如果你仔细回想一下会发现，将程序中的时间默认设置为UTC时间的过程即为“国际化”，而Moment.js库根据用户浏览器的时区而渲染对应的本地时间则是“本地化”。

如果你不使用Flask-Moment，那么也可以使用Babel内置的本地化时间日期功能。使用Flask-Babel本地化时间和日期的好处是可以直接在服务器端处理转换，返回的响应直接包含渲染好的时间日期，避免了在客户端调用JavaScript代码带来的延迟；坏处是你需要让用户手动选择时区。因为Todoism程序没有涉及这部分内容，我们在这里仅进行简单介绍。

1.设置和获取时区

当使用Moment.js时，它会在客户端渲染时间和日期，因此可以直接获取用户浏览器/计算机设置的时区。但是使用Babel/pytz转换时区对时间日期进行本地化处理是在服务器端进行的，而我们无法直接获取用户的时区，这时我们必须让用户自己选择时区。时区通过时区字符串表示，我们可以把时区字符串保存在用户对象的timezone列，或是保存在cookie中。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20138.png)
附注

时区字符串是IANA定义的表示某个时区的标识符，格式为“洲名/城市名”，比如Asia/Shanghai、Europe/London，完整的列表可以访问 [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) 查看，或是在python shell中导入pytz后执行pytz.all_timezones获取。 

在程序中，我们需要创建一个视图函数来保存时区，比如：

------

```
@app.route('/set-timezone/<path:timezone>')
def set_timezone(timezone):
    if timezone not in pytz.all_timezones:
        abort(404)
    if current_user.is_authenticated:
        current_user.timezone = timezone
        db.session.commit()
        return redirect(url_for('foo'))
    else:
        response = make_response(redirect(url_for('foo')))
        response.set_cookie('timezone', timezone, max_age=60 * 60 * 24 * 30)
        return response

```

------

因为时区字符串中包含斜线，为了正确获取变量，我们需要在URL规则中使用path转换器。这里的处理方法和设置区域时相同：首先判断时区字符串是否在pytz.all_timezones列表中，如果出错则返回404响应。如果用户已经登录，把表示时区的时区字符串保存到timezone字段，否则保存到cookie中。

2.显示时区列表

在页面中，和区域下拉列表类似，我们需要添加一个时区选择列表，列表中的内容通过迭代pytz提供的时区字符串列表pytz.all_timezones实现，这个列表需要通过模板上下文处理函数传入模板，如下所示：

------

```
import pytz
...
def register_template_context(app):
    @app.context_processor
    def inject_info():
        timezones = pytz.all_timezones
        return dict(timezones=timezones)

```

------

在模板中，我们迭代这个列表，渲染时区选择列表：

------

```
<div id="timezone-modal" class="modal">
    <div class="modal-content">
        <h4>选择时区</h4>
        <div class="collection">
            {% for timezone in timezones %}
            <a class="collection-item {% if current_user.timezone == timezone %}active{% endif %}" href="{{ url_for('set_timezone', timezone= timezone) }}">{{ timezone }}</a>
            {% endfor %}
          </div>
    </div>
    <div class="modal-footer">
        <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat">关闭</a>
    </div>
</div>

```

------

添加触发模态框的按钮后，单击按钮会打开一个包含所有时区字符串列表的模态框，如图10-4所示。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAW-EP42bAAAAAOC2gnY143189351.jpg)
图10-4 时区选择模态框

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20139.png)
附注

Babel还提供了get_timezone()和get_timezone_name()函数，可以用于获取时区字符串的不同翻译文本。你可以使用它来本地化时区字符串，具体用法可以参考Babel文档相关部分（ [http://babel.pocoo.org/en/latest/dates.xhtml#localized-time-zone-names](../Text/http://babel.pocoo.org/en/latest/dates.xhtml#localized-time-zone-names) ）。 

最后，我们需要使用Flask-Babel提供的babel.timezoneselector装饰器注册一个时区获取函数，示例如下：

------

```
@babel.timezoneselector
def get_timezone():
    if current_user.is_authenticated and current_user.timezone is not None:
        return current_user.timezone
    timezone = request.cookies.get('timezone')
    if timezone is not None:
        return timezone

    return None

```

------

如果这个函数返回None，那么Flask-Babel会使用BABEL_DEFAULT_TIMEZONE配置变量的值，你可以使用它来设置默认的时区字符串，默认值为UTC。

3.在模板中格式化时间

当我们调用init_app方法对Flask-Babel进行初始化时，它在Jinja2中添加了一系列用于格式化字符串的过滤器，其中有四个用于格式化时间日期的过滤器：datetimeformat、dateformat、timeformat、timedeltaformat。这几个过滤器分别通过Flask-Babel提供的format_datetime()、for-mat_date()、format_time()和format_timedelta()函数实现，分别用来格式化datetime模块中的date-time、date、time、和timedelta对象。使用示例如下所示：

------

```
>>> from flask_babel import format_datetime
>>> from datetime import datetime
>>> format_datetime(datetime(1987, 3, 5, 17, 12))
u'Mar 5, 1987 5:12:00 PM'
>>> format_datetime(datetime(1987, 3, 5, 17, 12), 'full')
u'Thursday, March 5, 1987 5:12:00 PM World (GMT) Time'
>>> format_datetime(datetime(1987, 3, 5, 17, 12), 'short')
u'3/5/87 5:12 PM'
>>> format_datetime(datetime(1987, 3, 5, 17, 12), 'dd mm yyy')
u'05 12 1987'

```

------

在模板中，我们使用它来格式化时间戳，以传入short参数来设置格式为例：

------

```
{{ item.timestamp|datetimeformat('short') }}

```

------

当使用这些过滤器格式化时间日期时，时间日期的显示语言和格式会自动根据当前的区域进行转换，而具体数值则会根据当前时区自动调整。具体的用法请参考Flask-Babel的官方文档（ [https://pythonhosted.org/Flask-Babel/#formatting-dates](https://pythonhosted.org/Flask-Babel/#formatting-dates) ）。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 10.3  设计并编写Web API

这一节我们会学习Web API，并为Todoism程序编写一个Web API。为了提前对Web API建立一个基本的概念，我们可以把数据比作原料，而包含数据的HTML页面则比作加工好的商品。这时普通的Web程序就是加工厂（将数据加工成完整的可以用于交互的HTML页面），而Web API则是原料工厂（仅提供数据），通过开放Web API（原料），大家都可以使用原料来加工商品。

在代码层面来说，Web API就是将我们单页程序中的视图函数编写模式发挥到极致——所有视图都只返回纯原料（数据），而不是加工好的商品（包含数据的HTML页面）。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20242.png)
提示

如果你从GitHub上复制了示例程序，可以执行git checkout api签出程序的新版本。程序的新版本添加了Web API。

#### 10.3.1  认识Web API

API通常表示低级的编程代码接口，程序提供一些外部接口来访问程序的功能，而用户并不需要知道内部的具体实现细节。比如Python或Flask提供的类、函数、方法等就是API。近年来，API越来越多地用来表示Web API，即基于HTTP协议用来提供数据的接口。也就是我们经常听到的API接口和数据接口。

也许你并不熟悉API，但它其实与我们的日常生活紧密相连。当我们在手机上使用某个社交软件，软件中的数据就是通过服务器端提供的API获取的。近年来逐渐流行的Mashup应用也离不开API。比如，快递查询网站借助多家快递公司提供的API，可以实现在单个网站上查询多家快递公司的快递信息。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20140.png)
附注

Mashup常被翻译为糅合、混搭或是聚合。我们经常看到的社交聚合或是新闻聚合就是指这类程序。借助其他公司/网站提供的API，我们可以组合这些数据来创建一个新的程序，这类程序就被称为Mashup。

1.Web API vs Web程序

在此之前，我们编写的几个程序都是Web程序。Web程序提供了完整的交互流程，访问某个URL，服务器返回指定的资源（以HTML的格式），浏览器接收响应并显示设计好的HTML页面，页面上的按钮和链接又指向其他资源。而另外一种形式是，当我们访问某个资源，服务器返回的不是HTML，而是使用特定格式表示的纯数据。没有按钮，没有表单，只有数据。与Web程序相对，这种形式被称为Web API或是Web服务。与Web程序不同，Web API提供的资源主要用于机器处理，所以一般使用JSON、XML等格式以提高重用性。这类API也因此被称为JSON over HTTP或XML over HTTP。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20141.png)
附注

在Web中，资源（Resource）就是URL指向的目标，可以在Web中定位的对象，比如一个文件、一张图片等。在Web API语境中，我们用它来表示可以通过URL获取的数据信息。

2.Web API的现状

近年来，越来越多的公司和网站都通过提供Web API将资源和服务开放出来（以收费或免费的形式）。ProgrammableWeb（ [https://www.programmableweb.com/](https://www.programmableweb.com/) ）是一个提供API目录和信息检索的网站，截至2018年5月，它已经收录了近2万个API。这些丰富的API又产出不计其数的Mashup应用，Web API逐渐催生出“API经济”。 

随着Web API的发展，Web世界也变得更加丰富和繁荣。借助Web API，不同的程序可以通过其他在线服务提供的Web API来集成功能。比如在阅读和资讯程序中集成第三方分享，使用社交网站的Web API来集成第三方登录功能，使用PayPal、支付宝、Stripe等服务的Web API提供支付功能。

3.为什么要编写Web API

对于我们的程序来说，为什么要提供Web API呢？假设我们做了一个优秀的Web程序，用户疯狂增长，编写Android和iOS客户端的计划很快就要被排上日程了。那么，我们如何让这些客户端都能和数据库进行数据交换操作呢？这时我们需要有一个中间人专门处理数据的传递工作，这个中间人就是Web API。

同时，随着各种优秀JavaScript框架的流行，比如Angular、React、Ember、Backbone、Vue.js等，借助这些框架，我们可以直接在客户端实现路由处理（routing）、模板渲染（templating）、表单验证等功能，从而编写出交互性良好的现代Web应用，这时服务器仅需要提供数据操作功能。如果你想使用这些框架编写程序客户端，那么我们就要先编写Web API。

现在，几乎所有成功的在线服务和网站，都将自己的服务以Web API的形式开放出来。开放Web API可以带来潜在的价值和影响力。其他用户使用你的Web API开发的其他应用，也会间接为你的产品做广告。在这一节，我们将学习使用Flask为Todoism编写Web API。这样，我们就可以轻松地为其编写桌面应用或移动应用。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20142.png)
附注

在某些公司中，开发大型程序往往由两个团队负责，分别为前端和后端。这时后端开发者负责开发程序基础功能并以Web API的形式开放这些功能；前端开发者（广义的前端也包括Android、iOS等客户端）负责编写页面逻辑，处理用户交互（HTML/CSS/JavaScript）。如果后端能提供Web API，那么前后端就可以完全做到并行开发，后端不用考虑页面交互，而前端可以通过Mock测试来（使用虚拟数据）模拟后端。这样可以在一定程度上提高开发效率。

4.REST与Web API

既然要编写API，我们就要考虑使用何种架构风格来实现。在以前，服务器端和客户端的API通信主要通过RPC（Remote Procedure Call，远程过程调用）和SOAP（Simple Object Acsess Protocol，简单对象访问协议）实现。但是由于这些协议的规范过于严格，实现起来不够灵活，已经被逐渐抛弃。近年来，REST（Representational State Transfer，表现层状态转移）架构逐渐流行开来。它结构清晰、易于理解，并且建立在Web的基础——HTTP之上，所以正得到越来越多网站和公司的采用。

REST起源于Roy Thomas Fielding的博士论文（ [http://www.ics.uci.edu/～fielding/pubs/disserta-tion/rest_arch_style.htm](http://www.ics.uci.edu/～fielding/pubs/disserta-tion/rest_arch_style.htm) ）。它是一种以网络为基础的程序架构风格，目标是构建可扩展的Web Service。符合REST架构约束的API被称为RESTful Web API。 

为了方便理解，我们可以补全REST前的主语Resource，现在完整的词组就变成了Resource Representational State Transfer。这可以理解为“资源（Resource）在网络中以某种表现形式（Re-presentational）进行状态转移（State Transfer）”。

虽然我们在设计API时主要参考了REST架构，但REST并不是规范，其只是一个架构风格，包含了设计API时的多种约束和建议。需要注意的是，仅仅通过HTTP协议返回JSON或XML数据的Web API并不能算是严格意义上的REST API。REST的提出者也在博文（ [http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven) ）中指出，不是使用了HTTP的API都叫RSET API。为了避免混乱，本章会尽量避免REST这个词。事实上，我们不必完全按照REST的架构要求来设计API。要尽量从API的自身特点和普适的规范来设计，而不是拘泥于REST一词。 

#### 10.3.2  设计优美实用的Web API

优美的Web API更利于使用，而且健壮性好。在设计Web API时有一个重要的考量，那就是主要面向的目标用户群。Netflix负责API设计的工程总监Daniel Jacobson在《The future of API design：The orchestration layer》（ [http://tnw.to/c4aDZ](http://tnw.to/c4aDZ) ）一文中提到了两个概念——LSUD（Large Set of Unknown Developers，大量未知的开发者）和SSKD（Small Set of Known Developers，少量已知的开发者）。这两个概念用来表示API所面向的主要开发人员分类。显而易见，这两类API在设计时需要有不同的考虑。 

我们要设计的API面向的对象更符合SSKD，因为我们希望把Todoism的Web API用于开发桌面客户端或移动客户端，所以我们在设计时不必花费太多精力处理大批量访问问题，而是专注于提供易于使用的API，同时客户端认证的处理也相对简单。

1.使用URL定义资源

Web API的根URL应该尽量简洁明了。一般情况下，设计者都会把关键字“api”加入到URL中。根URL模式主要有两种：一种是通过URL前缀指定，即 [http://example.com/api](http://example.com/api) ；另一种方法是直接把api加入主机名中，作为子域名，即 [http://api.example.com](http://api.example.com) 。在实际应用中，后一种方法更为简洁，也是采用较为普遍的方法。后面我们会学习在Flask中设置子域。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2092.png)
注意

为了便于开发和测试，Todoism程序中同时使用URL前缀和子域的方式来构建Web API的根URL。

资源是Web API的核心，这里共有两种资源：单个资源，比如一篇文章，一条评论；集合资源，比如某用户的所有文章，或是某篇文章下的所有评论。每一个资源都使用一个独一无二的URL表示，URL的设计应该遵循下列要求。

·尽量保持简短易懂；

·避免暴露服务器端架构；

·使用类似文件系统的层级结构。

在Web API的语境中，表示资源的URL也被称为端点或API端点。假设我们在api.example.com上为一个博客程序编写了Web API，那么博客中的各类资源与其端点将会是这样：

·api.example.com/users：所有用户。

·api.example.com/users/123/：id为123的用户。

·api.example.com/users/123/posts：id为33的用户的所有文章。

·api.example.com/posts：所有文章。

·api.example.com/posts/23：id为23的文章。

·api.example.com/posts/23/comments：id为23的文章的所有评论。

·...

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20243.png)
提示

大多数情况下，URL与URI可以交替使用。为了便于理解，本书大部分内容都使用了URL。

2.使用HTTP方法描述操作

既然有资源，我们就需要对资源进行常见的操作，比如创建、读取、更新、删除（CRUD）。对同一个资源的不同操作可以使用不同的HTTP方法来表示。比如，向api.example.com/posts/23发送GET请求就代表要获取这篇文章的数据，而向这个URL发送DELETE请求则表示要删除这个资源。API中常用的HTTP方法与对应URL的关系如表10-1所示。

表10-1 资源端点与HTTP方法的操作含义

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAW-EVYqyAAAAALYqYAc000482624.jpg)

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20244.png)
提示

我们不需要为每类资源实现所有的HTTP方法。如果客户端使用了不受支持的方法，Flask会自动处理并返回405（Method Not Allow）错误响应，表示不允许使用的方法。

每种方法应该返回的响应内容如表10-2所示。

表10-2 HTTP方法的响应内容

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAW-EASs0AAAAAHvu0AM299181413.jpg)

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20143.png)
附注

（1）详细的定义和规则可以在RFC7231（ [https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231) ）中看到。 

（2）PATCH方法的标准化经历了一些曲折，起初在RFC 2068中定义，后来又在2616中删除。在2010年3月发布的RFC5789（ [https://tools.ietf.org/html/rfc5789](https://tools.ietf.org/html/rfc5789) ）中，它又被重新确立为HTTP的标准方法。和PUT相比，当更新某个资源时，PUT方法提供完整的资源数据，而PATCH方法仅提供被更新的数据。 

（3）这里的表现层（representation）即资源的某种表现形式，比如JSON格式的数据。

3.使用JSON交换数据

在第2章，我们已经对常用的几种传输格式进行了简单的比较。出于同样的考虑，我们在Web API中将使用JSON来传输数据。事实上，JSON已经取代XML成为了API的标准数据格式。大多数在线服务都使用JSON作为数据格式。

在设计良好的Web API中，一篇文章可能会用下面的JSON数据表示：

------

```
{
    "id": 123
    "url": "http://api.helloflask.com/items/1",
    "html_url": "http://todoism.helloflask.com/item/1"
    "title": "Hello, Flask!"
    "body": "Something...",
    "created_at": "2017-01-26T13:01:12Z",
    "comments_url": "http://api.helloflask.com/post/123/comments",
    "author": {
        "id": 1,
        "url": "http://api.helloflask.com/users/1",
        "html_url": "http://todoism.helloflask.com/user/greyli",
        "username": "greyli",
        "website": "http://greyli.com",
        "posts_url": "http://api.helloflask.com/users/1/posts",
        "type": "User",
        "is_admin": false
    },
}

```

------

数据中除了包含文章的基本内容（标题、正文）外，还应该添加指向其他相关资源的URL（比如作者、评论等），这样Web API的使用者就可以自己探索其他资源了。

4.设置API版本

Web API和程序一样，都需要在完成后进行维护和更新。当程序的Web版本需要更新时，因为客户端是浏览器，每次请求都会重载页面，所以更新一般都可以立即生效。

而如果是其他安装在用户设备上的专用客户端，比如桌面软件或是移动软件，更新就不会那么简单了。虽然你可以通过添加没有取消按钮的弹窗来强迫用户更新，但这并不是个友好的做法。当打算对API进行更新时，我们就不得不考虑还有大量的用户使用的客户端依赖于旧版本的API。如果我们贸然更新，那么这些用户的客户端很可能会无法正常工作。为了解决这个问题，我们需要保留旧版本的API，创建一个新版本。

为了同时提供多个版本的API，较为常见的做法是在API的URL中指定版本：

·version 1： [http://api.example.com/v1](http://api.example.com/v1) 

·version 2： [http://api.example.com/v2](http://api.example.com/v2) 

这在Flask中很容易实现。借助Flask的蓝本特性，我们可以为不同的API版本设置蓝本，并添加URL前缀。还有一个更简洁的方法，就是直接在子域中指定：

·version 1： [http://api.example.com](http://api.example.com) 

·version 2： [http://api2.example.com](http://api2.example.com) 

后面我们会介绍如何使用Flask设置子域。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20144.png)
附注

除了这两种方式，还有一种在报文首部里设置版本信息的方式，不过并不常用。

#### 10.3.3  使用Flask编写Web API

在上一节，我们已经了解了设计Web API的基本知识，下面就让我们开始学习如何使用Flask编写Web API。因为Flask的灵活和轻量，使用它编写Web API非常简单。事实上，我们使用AJAX技术编写的程序本身已经初具Web API的雏形。为了方便理解，你可以把Web API看作对程序原有视图的整合和修改。API相关的视图属于单独的程序子集，我们需要先创建一个蓝本来存放相关脚本。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20245.png)
提示

在实际部署时，Web API可以作为单独的程序，也可以和传统的Flask程序进行组合，比如使用传统模式编写认证系统，编写API返回资源。

1.创建API蓝本

为了同时支持多个版本，我们在程序包中添加一个apis子包，用来存储API相关的脚本。我们再在apis包中创建子包来表示API的某个版本（v1表示version1.0，即初始版本），每个版本使用独立的蓝本表示。当需要创建新版本时，只需要新建一个子包及蓝本即可。目录结构如下：

------

```
todoism/
    apis/
        v1/
        - __init__.py
        - resources.py
        - auth.py
        - errors.py

```

------

因为我们的程序比较简单，所以所有表示资源的视图都存放在resources模块中。对于大型程序来说，我们可以把resources模块转换为包，然后将程序的资源视图按照类别分成多个模块，比如users.py、items.py等。

初始版本的API蓝本在v1子包的构造文件中创建，如下所示：

------

```
from flask import Blueprint

api_v1 = Blueprint('api_v1', __name__)

from todoism.apis.v1 import resources

```

------

为了避免多个API版本的蓝本名称发生冲突，我们将蓝本名称以及Blueprint实例命名为api_v1。为了避免产生导入循环依赖，我们在脚本末尾导入resources模块，以便让蓝本和对应的视图关联起来。

另外，我们还要在程序包的构造文件中将这个蓝本注册到程序实例上：

------

```
from todoism.apis.v1 import api_v1

def create_app():
    ...
    register_blueprints(app)

def register_blueprints(app):
    ...
    app.register_blueprint(api_v1, url_prefix='/api/v1')

```

------

在resgister_blueprint()函数中，我们使用url_prefix参数为蓝本设置URL前缀。你也可以为API蓝本设置子域，下一节会具体介绍。

在上一节，我们学习了使用Flask-WTF扩展提供的CSRFProtect扩展设置全局CSRF保护，但是Web API中的视图并不需要使用CSRF防护，因为Web API并不使用cookie认证用户。我们可以使用csrf.exempt()方法来取消对API蓝本的CSRF保护，它接收蓝本对象作为参数：

------

```
from todoism.apis.v1 import api

def register_extensions(app):
    ...
    csrf.init_app(app)
    csrf.exempt(api)

```

------

在这个程序中，我们把API的代码作为一个蓝本集成到程序中。作为替代，你也可以只创建API，这样就不用再考虑Flask-WTF的CSRF保护问题。在这种情况下，后端（back-end）和前端（front-end）可以分为两个独立的程序，两者借助HTTP通过API进行数据交换。

2.设置子域

使用Flask设置子域非常简单。我们可以为程序设置子域，也可以为蓝本设置子域，甚至可以为某个路由设置子域。

有两种方式可以为蓝本指定子域：一种是在实例化Blueprint类时使用subdomain参数指定，另一种是在使用register_blueprint()函数注册蓝本时使用subdomain参数指定。

------

```
def register_blueprints(app):
    ...
    app.register_blueprint(api_v1, url_prefix='/api/v1')
    app.register_blueprint(api_v1, subdomain='api', url_prefix='/v1')

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20246.png)
提示

你可以同时注册两次api_v1蓝本，分别支持通过子域或URL前缀的形式访问Web API。在Todoism程序中，我们仅实现了URL前缀方式。

需要注意的是，如果要在本地测试时使用子域，我们还需要修改操作系统的hosts文件。在Windows系统中，hosts文件的地址为C：\Windows\System32\drivers\etc\hosts（你可能需要根据Windows系统的安装位置来修改盘符）；在Linux和macOS系统中的地址为/etc/hosts。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20145.png)
附注

hosts文件（又被称为域名映射文件）是一个没有扩展名的系统文件，它存储了主机名和相应IP地址的映射关系。它通常作为对DNS（Domain Name System，域名系统）的补充，可以理解成一个本地的域名解析系统。正因为如此，我们可以自己管理映射关系。

我们在第1章曾介绍过使用http://localhost：5000访问程序，在hosts文件中，我们可以创建一个类似localhost与本地主机IP的映射关系。使用文本编辑器打开hosts文件后，在hosts文件中新起一行，将本地主机的IP地址（127.0.0.1）指向我们自定义的主机名，两者使用空格分隔：

------

```
127.0.0.1 todoism.dev
127.0.0.1 api.todoism.dev

```

------

第一行的todoism.dev作为程序的主机名，而第二行的api.todoism.dev就是我们为API蓝本分配的包含子域的主机名。

如果不知道主机名，Flask就无法获取子域名称，也无法正确设置cookie。为此我们需要将SERVER_NAME的值设为我们在hosts文件中设置的主机名和对应的端口号：

------

```
SERVER_NAME = 'todoism.dev:5000'

```

------

我们也可以使用单个单词来作为主机名，但是由于大多数主流浏览器不允许设置跨子域cookie，当主机名不包括“点”时（比如localhost）会导致无法使用cookie。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20247.png)
提示

在Windows下，设置包含“点”的主机名可能会导致AttributeError异常，这是因为Windows下的socket对象没有inet_pton属性。如果你使用Windows系统，可以使用win_inet_pton包来解决这个兼容问题，首先使用Pipenv安装$pipenv install win_inet_pton。然后在程序中相关调用前导入import win_intet_pton这个模块（比如在程序包的构造文件中）。

假如我们在API蓝本中创建了一个index视图：

------

```
from flask import jsonify
from todoism.apis.v1 import api_v1
@api_v1.route('/')
def index():
    return jsonify('message='hello, world!')

```

------

那么，当我们使用浏览器访问 [http://todoism.dev:5000](http://todoism.dev:5000) 时，就会打开程序的主页；而访问 [http://api.todoism.dev:5000/v1](http://api.todoism.dev:5000/v1) 时，则会获得上面的index视图返回的JSON数据。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2093.png)
注意

（1）Todoism程序中仅使用URL前缀/api/v1注册了蓝本，所以你需要使用 [http://localhost:5000/api/v1](http://localhost:5000/api/v1) 来访问API主页。如果你想启用子域，可以在设置hosts文件后在setting.py和__init__.py中删掉对应代码行前的注释符号。 

（2）用于注册路由的route()装饰器也接收subdomain参数，可以为某个视图定义子域。

3.添加CORS支持

在介绍CORS（Cross Origin Resource Sharing，跨域资源共享）之前，我们需要先了解一下同源策略（Same origin policy）。出于安全考虑，浏览器会限制从脚本内发起的跨域请求。这里的跨域包括不同域名、不同端口、不同HTTP模式（HTTP、HTTPS等）。比如，从exampleA.com向exampleB.com发起的请求就属于跨域请求。

当API蓝本设置了子域后，假设我们的Web API部署在api.example.com中，而程序部署在 [www.example.com](http://www.example.com) 中，这时从 [www.example.com](http://www.example.com) 向API发起的AJAX请求就会因为同源策略而失败。对于向第三方大范围公开的API，更要考虑支持CORS。 

在CORS流行之前，大多数API都通过支持JSONP（JSON with Padding）来支持跨域请求。和JSONP相比，CORS更加方便灵活，支持更多的跨域请求方法，并且在2014年成为W3C的推荐标准，逐渐开始替代JSONP。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20146.png)
附注

由于篇幅所限，这里不会详细介绍CORS的工作原理，具体内容可以访问 [http://www.w3.org/TR/cors](http://www.w3.org/TR/cors) 查看。 

CORS需要同时被浏览器和服务器支持，大多数浏览器都支持CORS，我们只需要在服务器端设置支持CORS。我们可以使用扩展Flask-CORS来为API添加跨域访问支持，先使用Pipenv进行安装：

------

```
$ pipenv install flask-cors

```

------

因为我们只需要对API蓝本中的路由添加跨域请求支持，所以Flask-CORS扩展只在蓝本中初始化，传入蓝本对象作为参数：

------

```
from flask import Blueprint
from flask_cors import CORS

api_v1 = Blueprint('api_v1', __name__)

CORS(api_v1)

```

------

默认情况下，Flask-CORS会为蓝本下的所有路由添加跨域请求支持，并且允许来自任意源的跨域请求。

4.设计资源端点

在设计Web API的资源端点时，我们首先要考虑的是通过Web API开发程序的哪些功能。我们不需要在Web API中开放程序的所有功能，Todoism开放的功能如下所示：

·用户登录；

·获取用户信息；

·获取条目；

·修改条目；

·切换条目的完成状态；

·删除条目；

·获取当前用户的所有条目；

·获取当前用户的未完成条目；

·获取当前用户的已完成条目；

·删除当前用户所有已完成条目。

接着，我们需要将这些功能分类，每一类作为一个资源端点，可以分为下列5个资源：

·单个条目；

·当前用户；

·当前用户所有条目；

·当前用户所有未完成条目；

·当前用户所以已完成条目。

最后，我们考虑每个资源对应的URL，并根据上面的功能分配各自的HTTP方法，如表10-3所示。

表10-3 资源端点设计

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAW-EX7BzAAAAAA_xDKo788082302.jpg)

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20248.png)
提示

因为Todoism属于私人在线应用，所有资源都只有当前用户可以获取，除了用于创建用户的users端点，其他URL都从表示当前用户的user开头。

除了这些程序相关的资源，我们还要定义一个资源首页，即根端点（root endpoint）。当访问API的根地址（ [http://api.example.com/v1](http://api.example.com/v1) 或 [http://example.com/api/v1](http://example.com/api/v1) ）时，程序会返回API的版本信息以及与所有主要资源对应的URL，作为API的主入口。这可以方便开发者探索资源，相当于API所提供资源的索引目录，如下所示： 

------

```
{
    "api_version": "1.0",
    "api_base_url": "http://example.com/api/v1",
    "current_user_url": "http://example.com/api/v1/user",
    "authentication_url": "http://example.com/api/v1/token",
    "item_url": "http://example.com/api/v1/items/{item_id }",
    "current_user_items_url": "http://example.com/api/v1/user/items{?page,per_page}",
    "current_user_active_items_url": "http://example.com/api/v1/user/items/active{?page,per_page}",
    "current_user_completed_items_url": "http://example.com/api/v1/user/items/completed{?page,per_page}",
}

```

------

5.创建资源类

在Flask中，资源端点可以使用普通的视图函数来表示，通过为同一个URL定义不同的方法实现，比如：

------

```
@api_v1.route('/items/<int:id>', methods=['GET'])
def get_post(id):
    pass

@api_v1.route('/items/<int:id>', methods=['DELETE'])
def delete_post(id):
    pass

```

------

对于简单的程序，使用这种方式就足够了。不过，Flask提供了使用Python类来组织视图函数的支持，其中的方法视图（MethodView类）可以让Web API的编写更加方便，并且让资源的表示更加直观。借助方法视图，我们可以定义一个继承自MethodView的资源类，整个类表示一个资源端点。我们使用资源端点支持的HTTP方法作为类方法名，它会处理对应类型的请求。比如，当客户端向/items/<int：id>发起一个GET请求时，资源类中的get()方法将会被调用：

------

```
from flask.views import MethodView  # 导入MethodView类

class Item(MethodView):

    def get(self, item_id):
        pass

    def delete(self, item_id):
        pass

```

------

在使用方法视图时，除了定义资源类，我们还需要使用add_url_rule()方法来注册路由：

------

```
app.add_url_rule('/items/<int:item_id>', view_func=ItemAPI.as_view('item_api'), methods=['GET','DELETE'])

```

------

因为整个资源类表示实现多个处理方法的视图，我们需要对资源类调用as_view()方法把其转换为视图函数，传入自定义的端点值（用来生成URL），最后将它赋给view_func参数。另外，在methods参数的列表中，我们需要写出所有在资源类中使用的方法。

代码清单10-12所示是完整的表示item端点的ItemAPI类的实现。

代码清单10-12 todoism/apis/v1/resources.py：Item API资源类

------

```
from flask.views import MethodView

class ItemAPI(MethodView):
    decorators = [auth_required]

    def get(self, item_id):
        """Get item."""
        item = Item.query.get_or_404(item_id)
        if g.current_user != item.author:
            return api_abort(403)
        return jsonify(item_schema(item))

    def put(self, item_id):
        """Edit item."""
        item = Item.query.get_or_404(item_id)
        if g.current_user != item.author:
            return api_abort(403)
        item.body = get_item_body()
        db.session.commit()
        return '', 204

    def patch(self, item_id):
        """Toggle item."""
        item = Item.query.get_or_404(item_id)
        if g.current_user != item.author:
            return api_abort(403)
        item.done = not item.done
        db.session.commit()
        return '', 204

    def delete(self, item_id):
        """Delete item."""
        item = Item.query.get_or_404(item_id)
        if g.current_user != item.author:
            return api_abort(403)
        db.session.delete(item)
        db.session.commit()
        return '', 204

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2094.png)
注意

资源类的名称和模型类名称重合度很高，很容易发生命名冲突。对于这个问题，以User类为例，你可以考虑将资源类命名为UserAPI或UserResource。另外，你也可以在导入模型类时使用别名，比如from todoism.models import User as UserModel。

关于这些方法中的一些实现，我们会在下面慢慢介绍。在设计响应时，我们不必完全遵守表10-2中所示的规则。为了方便使用者，对于对资源进行创建和更新的方法（POST、PATCH等），我们可以返回创建/更新后的资源主体。这样可以避免用户再发起一次GET请求来获取创建/更新后的资源，而且比返回空白资源主体的204响应更友好。另外，对于其他操作，你也可以返回一个提示消息，我们在这里仅返回了无内容的204响应。

在resources模块的末尾，我们统一为所有的资源类注册路由（你也可以在每一个资源类的定义后注册），如代码清单10-13所示。

代码清单10-13 todoism/apis/v1/resources.py：为资源类注册路由

------

```
api_v1.add_url_rule('/', view_func=IndexAPI.as_view('index'), methods=['GET', 'POST'])
api_v1.add_url_rule('/token', view_func=AuthTokenAPI.as_view('token'), methods=['GET'])
api_v1.add_url_rule('/user', view_func=UserAPI.as_view('user'), methods=['GET'])
api_v1.add_url_rule('/user/items', view_func=ItemsAPI.as_view('items'), methods=['GET', 'POST'])
api_v1.add_url_rule('/user/items/<int:item_id>', view_func=ItemAPI.as_view('item'), methods=['GET', 'PUT', 'PATCH', 'DELETE'])
api_v1.add_url_rule('/user/items/active', view_func=ActiveItemsAPI.as_view('active_items'), methods=['GET'])
api_v1.add_url_rule('/user/items/completed', view_func=CompletedItemsAPI.as_view('completed_items'), methods=['GET', 'DELETE'])

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20249.png)
提示

（1）由于篇幅所限，这里不列出其他的资源类的具体代码，详情可以到源码仓库查看。

（2）除了手动使用MethodView实现资源类外，你也可以考虑使用扩展，比如Flask-RESTful（ [https://github.com/flask-restful/flask-restful](https://github.com/flask-restful/flask-restful) ）、Flask-apispec（ [https://github.com/jmcarp/flask-apispec](https://github.com/jmcarp/flask-apispec) ）、Flask-Classful（ [https://github.com/teracyhq/flask-classful](https://github.com/teracyhq/flask-classful) ）、Flask-RestPlus（ [https://github.com/noirbizarre/flask-restplus](https://github.com/noirbizarre/flask-restplus) ）、flask-Restless（ [https://github.com/jfinkels/flask-restless](https://github.com/jfinkels/flask-restless) ）。 

#### 10.3.4  使用OAuth认证

在传统的Web应用中，用户的认证信息存储在浏览器的cookie中。但是cookie在其他客户端并没有得到广泛支持，所以我们不能通过cookie来记住用户状态。因为API的无状态特性，我们不能再使用Flask-Login实现认证功能，而是需要用户在每一次获取受登录保护的资源时都要提供认证信息。但是让用户在每一次请求中附加认证信息并不合理，而且会带来安全问题。更好的解决方法是用户通过一次认证后，在服务器端为用户生成一个认证令牌，在之后的请求中，客户端可以通过认证令牌进行认证。出于安全的考虑，认证令牌还会设置过期时间。

OAuth（Open Authorization，开放授权）是一个2007年发布的授权标准，它是现代Web API中应用非常广泛的授权机制，Google、Facebook、Twitter、腾讯QQ等各种在线服务都提供了OAuth认证支持。这一节我们将学习为API添加OAuth支持。

1.认识OAuth 2.0

我们先举一些常见的例子来介绍OAuth中最常见的认证模式。OAuth允许用户授权第三方移动应用有限访问他们存储在其他服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用。

大多数网站都在登录页面提供了使用第三方服务登录的功能，比如使用QQ号码登录。比如我们要登录A网站，单击A网站上的“使用QQ登录”按钮后会跳转到QQ提供的登录页面，在这个登录页面我们还可以选择允许A网站访问的内容，输入QQ账号和密码进行授权。登录成功后会跳转回A网站，显示已成功使用QQ登录。在这种情况下，我们的账号和密码并没有暴露给A网站，取而代之，A网站会从QQ的服务器获取一个名为access token的令牌。通过这个令牌，A网站就能访问你允许范围内的信息，而不需要账号和密码。

再比如，团队协作应用通常都提供了大量的第三方接入功能，比如你想在Trello（ [https://trello.com/](https://trello.com/) ）看板里插入某个Github仓库里的Pull Request或Isssue。当你单击Trello中的“连接到Github”按钮时，会跳转到Github的认证页面，如图10-5所示。这些认证形式都是OAuth。在下一章的在线聊天室程序中，我们会学习使用OAuth为程序添加社交账户（第三方）登录功能。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAW-Ebhp8AAAAAAYBtzw566160734.jpg)
图10-5 在Trello中连接Github账户

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20147.png)
附注

OAuth 2.0（ [https://oauth.net/2/](https://oauth.net/2/) ）相对于OAuth 1.0来说更加完善，其提供了更丰富的认证场景支持，所以这里我们使用OAuth 2.0。OAuth 2.0的具体定义可以在RFC 6749（ [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749) ）中看到。 

除了这种第三方程序需要访问用户的其他在线服务时的认证模式外，OAuth 2.0还提供了其他认证模式。OAtuh 2.0提供的认证模式如表10-4所示。

表10-4 OAuth 2.0认证模式

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAW-EKFAYAAAAAHYy7Bw282653003.jpg)

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20148.png)
附注

（1）除了上述基本的授权类型，后来又添加了SAML Bearer Assertion认证和JWT Bearer Token认证，具体可以在RFC 7522和RFC 7522中看到，这里暂不展开介绍。

（2）如果你想快速了解OAuth的基础知识，可以阅读这篇简化教程： [https://aaron-parecki.com/oauth-2-simplified](https://aaron-parecki.com/oauth-2-simplified) 。 

对于自己编写的客户端，可以使用第三种认证模式（密码模式）。这时用户可以直接在程序中输入用户名和密码，程序把用户名和密码发送到服务器，服务器返回access令牌，之后客户端就可以使用access令牌进行认证并获取用户资源。整个认证流程如图10-6所示。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAW-Ebge_AAAAACR5ReY046592916.jpg)
图10-6 密码模式认证流程

在图10-6中，Resource Server（资源服务器）是提供API资源的服务器，Authorization Server（授权服务器）是用于管理授权的服务器；Resource Owner（资源拥有者）即用户，而Client（客户端）指第三方程序。因为我们的程序很简单，所以API服务和授权操作使用同一个服务器提供。

下面我们就在Todoism中实现Resource Owner Password Credentials模式（后面简称为密码模式）的OAuth认证功能。我们首先要做的是，考虑如何表示令牌端点。一般情况下，OAuth端点中都会包含oauth关键字，我们可以使用/oauth/token作为令牌端点，比如 [http://api.example.com/v1/oauth/token](http://api.example.com/v1/oauth/token) 。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2095.png)
注意

再次说明，无论使用何种认证方式，都要使用HTTPS加密传输来防止信息在传输过程中被窃取。除非你的API不涉及会话信息，即任何人访问都获得相同的结果。

2.认证并返回access令牌

首先，我们需要创建一个对应认证端点的AuthTokenAPI资源类和处理认证请求的POST方法：

------

```
class AuthTokenAPI(MethodView):

    def post(self):
        pass
...
api_v1.add_url_rule('/oauth/token', view_func=AuthTokenAPI.as_view('token'), methods=['POST'])

```

------

使用密码模式认证时，客户端在访问认证端点时需要将表10-5中所示的信息以application/x-www-form-urlencoded的形式（这也是我们平时提交HTML表单时默认的内容类型），使用POST方法，并经过UTF-8编码后发送到服务器。

表10-5 客户端提供的认证信息

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAW-EYKAEAAAAAN4_11A250540270.jpg)

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20149.png)
附注

scope键用来指定请求的权限，由代表权限的字符组成的列表，可用的权限由API服务器定义。

比如，某个客户端发送的授权请求可能会是这样：

------

```
POST /v1/oauth/authorize HTTP/1.1
Host: api.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=greyli&password=12345

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20250.png)
提示

当服务器端需要识别客户端的身份时，比如需要对客户端的访问频次进行限制；或者仅允许某些客户端调用API（不对第三方开放的API），还需要对客户端进行认证。我们需要提供客户端注册功能以便客户端开发人员获得客户端ID和密码。然后客户端需要进行HTTP Basic认证的方式将客户端ID（Client ID）和客户端密码（Client Secret）进行Base64编码后存放在请求首部的Authorization字段中。在服务器端，Flask将Basic认证信息解析在request.authorization中。认证ID存储在request.authorization.name中，而认证密码存储在request.authorization.password中。客户端注册、验证的操作和用户的注册、验证的基本相同，为了简化实例，在这里暂不实现此功能。

我们在AuthTokenAPI资源类的POST方法中获取认证请求中的用户名和密码，如代码清单10-14所示。

代码清单10-14 todoism/apis/v1/resources.py：处理认证的AuthTokenAPI端点

------

```
class AuthTokenAPI(MethodView):

    def post(self):
        grant_type = request.form.get('grant_type')
        username = request.form.get('username')
        password = request.form.get('password')

        if grant_type is None or grant_type.lower() != 'password':
            return api_abort(code=400, message='The grant type must be password.')

        user = User.query.filter_by(username=username).first()
        if user is None or not user.validate_password(password):
            return api_abort(code=400, message='Either the username or password was invalid.')

        token, expiration = generate_token(user)

        response = jsonify({
                'access_token': token,
                'token_type': 'Bearer',
                'expires_in': expiration
                })
        response.headers['Cache-Control'] = 'no-store'
        response.headers['Pragma'] = 'no-cache'
        return response

```

------

我们从请求对象的form属性中获取认证类型、用户名和密码，对其进行相应的验证。如果用户名和密码经过认证，我们就返回JSON数据，其中包含了access令牌（access_token）、令牌类型（token_type）以及过期时间（expires_in），可选的值还有表示权限范围的scope和用于刷新认证的refresh令牌。

除此之外，当返回的响应中包含令牌等敏感信息时，我们应该将响应首部Cache-Control字段的值设为no-store，将Pramga字段的值设为no-cache。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20150.png)
附注

access令牌是客户端用于访问受登录保护时的认证凭证，令牌类型中的“Bearer”是RFC 6750（ [https://tools.ietf.org/html/rfc6750](https://tools.ietf.org/html/rfc6750) ）定义的OAuth 2.0使用的令牌类型（常被翻译为不记名令牌）。 

当请求中的认证类型、用户名或密码无效时，我们会调用api_abort()函数，它是我们在errors模块中自定义的API错误响应函数，后面我们会详细介绍。这个api_abort()函数有两个参数：code参数表示错误响应的状态码；message是错误提示信息。其他附加的关键字参数将会解析为JSON响应中的键值对。

生成令牌的函数在auth模块中创建，如代码清单10-15所示。

代码清单10-15 todoism/apis/v1/auth.py：生成access令牌

------

```
def generate_token(user):
    expiration = 3600
    s = Serializer(current_app.config['SECRET_KEY'], expires_in=expiration)
    token = s.dumps({'id': user.id}).decode('ascii')
    return token, expiration

```

------

access令牌是使用itsdangerous生成的有过期时间的JWS令牌，它使用程序密钥签名。令牌的负载（payload）中存储用户的ID，这样当客户端发送包含令牌的请求时，我们可以根据令牌的有效性判断用户的认证状态，根据令牌的内容获取对应的用户。设置短期令牌（1小时及以下）可以减小令牌值泄露造成的危害。

3.验证access令牌

用户发出授权请求并附带相应的信息后，会获得类似下面的JSON响应：

------

```
{
    "access_token": "eyJhbGciOiJIUzI1NiIsImV4cCI6MTUyNjE3MTY1NiwiaWF0IjoxNTI2MTY4MDU2fQ.eyJpZCI6MX0.PJK4Ie07JxSAPNYcKEmfQogBzpiFEnicyzABOfmabYU",
    "expires_in": 3600,
    "token_type": "Bearer"
}

```

------

用户获取access令牌后，就可以在访问受认证保护的端点时提供这个令牌来认证。发送请求时需要把认证令牌附加在请求首部的Authorization字段中，并且在令牌前指定令牌类型（即Bearer）：

------

```
Authorization Bearer eyJhbGciOiJIUzI1NiIsImV4...

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20251.png)
提示

根据RFC 6750的定义，令牌值还可以附加在请求主体中，或是附加在查询字符串中，但出于安全和灵活的考虑，这两种方式通常不使用。

因为Flask的request对象只支持解析Basic和Digest类型的授权字段，所以我们需要自己解析Authorization首部字段以获取令牌值。用于获取令牌类型和令牌值的get_token()函数如代码清单10-16所示。

代码清单10-16 todoism/apis/v1/auth.py：获取请求中的令牌值

------

```
def get_token():
    if 'Authorization' in request.headers:
        try:
            token_type, token = request.headers['Authorization'].split(None, 1)
        except ValueError:  # Authorization字段为空或token为空
            token_type = token = None
    else:
        token_type = token = None

    return token_type, token

```

------

在对应的视图中，我们需要验证这些令牌。用来验证令牌是否有效的validate_token()函数如代码清单10-17所示。

代码清单10-17 todoism/apis/v1/auth.py：验证令牌

------

```
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer, BadSigna-ture, SignatureExpired

def validate_token(token):
    s = Serializer(current_app.config['SECRET_KEY'])
    try:
        data = s.loads(token)
    except (BadSignature, SignatureExpired):
        return False
    user = User.query.get(data['id'])  # 使用令牌中的id来查询对应的用户对象
    if user is None:
        return False
    g.current_user = user  # 将用户对象存储到g上
    return True

```

------

validate_token()函数返回布尔值表示验证的结果。在这个函数中，如果验证通过，我们会获取令牌负载中存储的用户id，并查询对应的用户对象，然后保存到Flask提供的全局对象g中，作为current_user属性。这类似于Flask-Login提供的current_user对象，使用它我们可以在视图函数中调用g.current_user获取通过授权的当前用户对象。

我们需要在每一个受认证保护的视图中获取认证令牌，并调用validate_token方法验证令牌值。这显然不是最佳方案，我们可以像Flask-Login一样实现一个auth_required装饰器，验证令牌的工作可以放到装饰器函数中。auth_required装饰器在auth模块中创建，如代码清单10-18所示。

代码清单10-18 todoism/apis/v1/auth.py：登录保护装饰器

------

```
from functools import wraps

def auth_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token_type, token = get_token()

        if request.method != 'OPTIONS':
            if token_type is None or token_type.lower() != 'bearer':
                return api_abort(400, 'The token type must be bearer.')
            if token is None:
                return token_missing()
            if not validate_token(token):
                return invalid_token()
        return f(*args, **kwargs)
    return decorated

```

------

在这个装饰器函数中，我们首先调用get_token()获取令牌类型和令牌值。如果令牌类型为None或不是Bearer，返回400错误；如果令牌值为None，调用token_missing()函数；如果令牌值验证出错，即validate_token()返回False，就调用invalid_token()函数。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20252.png)
提示

因为在CORS交互中的事先请求（Pre-flight Request）会使用OPTIONS方法发送请求，所以我们只在OPTIONS方法之外的请求中验证令牌。

根据RFC 6750的定义，在未提供令牌和令牌无效时分别返回不同的错误响应。我们创建的invalid_token()和token_missing()函数在errors.py中定义，分别用来返回令牌无效和未提供令牌时的错误响应，如代码清单10-19所示。

代码清单10-19 todoism/apis/v1/errors.py：令牌错误响应

------

```
def invalid_token():
    response = api_abort(401, error='invalid_token', error_description='Either the token was expired or invalid.')
    response.headers['WWW-Authenticate'] = 'Bearer'
    return response

def token_missing():
    response = api_abort(401)
    response.headers['WWW-Authenticate'] = 'Bearer'
    return response

```

------

在上面的函数中，invalid_token()用于令牌无效的情况，token_missing()用于未提供认证令牌的情况。错误响应中，请求首部中的error参数的值为OAuth 2.0定义描述错误类型的可选值之一，可选的error_description参数用来附加可读性更高的错误描述。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20151.png)
附注

OAuth错误响应的详细定义可以在RFC 6750（ [https://tools.ietf.org/html/rfc6750#sec-tion-3.1](https://tools.ietf.org/html/rfc6750#sec-tion-3.1) ）中看到。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20253.png)
提示

当客户端为浏览器时，接收到401响应后，浏览器会弹出一个默认的窗口用于填写用户ID和密码（HTTP Basic认证）。

最后我们需要为所有必要的资源添加认证保护，Flask在MethodView类中提供了decorators属性，使用它可以为整个资源类的所有视图方法附加装饰器：

------

```
class ItemAPI(MethodView):
    decorators = [auth_required]

    def get(self, item_id):
        ...

```

------

至此，密码模式的OAuth认证功能基本完成了。更进一步，你可以考虑实现令牌更新（refresh）和令牌撤销（revoke）功能。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20152.png)
附注

因为我们的程序非常简单，手动实现认证功能也很容易。如果你想简化操作，或是实现其他授权模式，可以考虑使用Authlib（ [https://github.com/lepture/authlib](https://github.com/lepture/authlib) ）。 

#### 10.3.5  资源的序列化

在传统Web程序中，我们使用Jinja2来把数据渲染到模板中，然后返回渲染后的HTML数据；而在Web API中，我们则需要将数据按照设计好的模式封装为JSON数据并返回。这个过程被称为响应的格式化，或是响应封装，也被称为资源的序列化（Serialization）。

对我们的Web API来说，序列化（Serialize）就是把数据库模型对象转换成JSON数据。相对的，反序列化（Deserialize）就是把JSON数据转换成数据库模型对象，我们在下一节会学习到。

1.定义资源模式

返回某个资源时，我们要考虑如何设计响应数据的结构，这个结构被称为资源的模式。一般来说，资源的模式遵循以下几个要点：

·响应数据并不需要完全反映数据库字段，仅需要包含必要的基本信息。

·包含自身的描述信息（比如kind），指向自身及相关资源的URL。

·为了便于使用，最好尽量使数据扁平化，以减少层级复杂度。当然，在使用层级结构更合适的情况下，也可以使用层级结构。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20153.png)
附注

关于JSON风格建议，可以参考Google的JSON风格指南（ [https://google.github.io/sty-leguide/jsoncstyleguide.xml](https://google.github.io/sty-leguide/jsoncstyleguide.xml) ）。 

如果程序很小，自己手动实现资源的序列化转换也很容易。在Todoism程序中，我们把返回某个资源的操作放到函数中，在函数中使用字典来定义资源的模式。代码清单10-20是用于生成表示用户资源的user_schema()函数和生成单个条目资源的item_schema()函数。它们分别接收User类实例和Item类实例作为参数，返回按照预定模式创建的字典对象，用于生成JSON数据。

代码清单10-20 todoism/apis/v1/schemas.py：用户资源序列化函数

------

```
def user_schema(user):
    return {
        'id': user.id,
        'self': url_for('.user', _external=True),
        'kind': 'User',
        'username': user.username,
        'all_items_url': url_for('.items', _external=True),
        'active_items_url': url_for('.active_items', _external=True),
        'completed_items_url': url_for('.completed_items', _external=True),
        'all_item_count': len(user.items),
        'active_item_count': Item.query.with_parent(user).filter_by(done=False).count(),
        'completed_item_count': Item.query.with_parent(user).filter_by(done=True).count(),
    }

def item_schema(item):
    return {
        'id': item.id,
        'self': url_for('.item', item_id=item.id, _external=True),
        'kind': 'Item',
        'body': item.body,
        'done': item.done,
        'author': {
            'id': 1,
            'url': url_for('.user', _external=True),
            'username': item.author,
            'kind': 'User',
        },
    }

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20154.png)
附注

我们也可以把序列化/反序列化资源的函数定义为数据库模型类的方法。比如我们要将User模型的数据序列化为JSON资源，可以在User类中创建serialize()/deserialize()或to_json()/from_json()方法。

在上面定义的资源模式中，你会发现除了User模型或Item模型中定义的字段数据外，我们还在响应数据中添加了与当前用户或条目相关的URL和内容。其中，self表示资源自身的URL，kind表明了当前资源的类别。像这种包含相关链接和自描述（self-describing）信息的资源被称为超媒体（Hypermedia），因为这些数据在被机器解析时可以像人类浏览网页一样对资源进行进一步操作。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20155.png)
附注

说到Web API中的Hypermeida，通常会引入另一个概念——HATEOAS（Hypermedia as the Engine of Application State，超媒体作为程序状态的引擎），这是REST的一个重要约束。它主要的含义是客户端和REST API的交互要由超媒体驱动。

2.序列化处理

在资源类的get方法中，我们使用模式函数来获取资源字典，传入对应的模型类实例。如下所示：

------

```
from flask import jsonify
from flask.view import MethodView
from todoism.models import User, Item
from todoism.apis.v1.auth import auth_required
from todoism.apis.v1.errors import api_abort
from todoism.apis.v1.schemas import user_schema, item_schema

class UserAPI(MethodView):
    decorators = [auth_required]

    def get(self):
        return jsonify(user_schema(g.current_user))

class ItemAPI(MethodView):
    decorators = [auth_required]

    def get(self, item_id):
        """Get item."""
        item = Item.query.get_or_404(item_id)
        if g.current_user != item.author:  # 验证当前用户是否是条目作者
            return api_abort(403)
        return jsonify(item_schema(item))

```

------

我们调用Flask提供的jsonify()方法将模式函数返回的字典对象转换为标准的JSON数据，它会为响应报文设置正确的Content-Type字段（即“application/json”）。以user端点为例，最终生成的JSON数据示例如下所示：

------

```
{
    "active_item_count": 0,
    "active_items_url": "http://localhost:5000/api/v1/user/items/active",
    "all_item_count": 0,
    "all_items_url": "http://localhost:5000/api/v1/user/items",
    "completed_item_count": 0,
    "completed_items_url": "http://localhost:5000/api/v1/user/items/completed",
    "id": 1,
    "kind": "User",
    "self": "http://localhost:5000/api/v1/user",
    "username": "grey"
}

```

------

3.资源分页

与在网页加载大量数据一样，如果不对Web API返回的资源内容进行分页，当数据库的内容增多时，就会增大服务器的负载。

返回条目集合的视图方法接收page指定页数，默认为1，每页的数量为配置变量TODOI-SM_ITEM_PER_PAGE的值。我们仍然使用Flask-SQLAlchemy提供的paginate()方法对查询结果进行分页，如代码清单10-21所示。

代码清单10-21 todoism/apis/v1/resources.py：资源分页

------

```
class ItemsAPI(MethodView):
    decorators = [auth_required]

    def get(self):
        """Get current user's all items."""
        page = request.args.get('page', 1, type=int)
        pagination = Item.query.with_parent(g.current_user).paginate(
            page, per_page=current_app.config['TODOISM_ITEM_PER_PAGE'])
        items = pagination.items
        current = url_for('.items', page=page, _external=True)
        prev = None
        if pagination.has_prev:
            prev = url_for('.items', page=page - 1, _external=True)
        next = None
        if pagination.has_next:
            next = url_for('.items', page=page + 1, _external=True)
        return jsonify(items_schema(items, current, prev, next, pagination))

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20254.png)
提示

你也可以考虑添加一个per_page参数来让用户指定每页数量，但是要注意对最大值进行合理的限制，可以在paginate()方法中通过max_per_page参数设置。

在返回的JSON数据中，除了返回对应页数的条目列表，我们还需要返回其他信息，比如用于获取上一页和下一页数据的URL、当前URL、当前页数、总页数等，以便客户端可以自行获取相关资源，创建条目集合资源字典的items_schema()函数如代码清单10-22所示。

代码清单10-22 todoism/apis/v1/schemas.py：条目集合的资源模式

------

```
def items_schema(items, current, prev, next, pagination):
    return {
        'self': current,
        'kind': 'ItemCollection',
        'items': [item_schema(item) for item in items],  # 迭代传入的items列表
        'prev': prev,
        'last': url_for('.items', page=pagination.pages, _external=True),
        'first': url_for('.items', page=1, _external=True),
        'next': next,
        'count': pagination.total
    }

```

------

对这个items端点发起GET请求后返回的响应示例如下所示：

------

```
{
    "count": 2,
    "first": "http://localhost:5000/api/v1/user/items?page=1",
    "items": [
        {
            "author": {
                "id": 1,
                "kind": "User",
                "url": "http://localhost:5000/api/v1/user",
                "username": "grey"
            },
            "body": "Buy some milk.",
            "done": false,
            "id": 1,
            "kind": "Item",
            "self": "http://localhost:5000/api/v1/user/items/1"
        },
        {
            "author": {
                "id": 1,
                "kind": "User",
                "url": "http://localhost:5000/api/v1/user",
                "username": "grey"
            },
            "body": "Read book",
            "done": false,
            "id": 2,
            "kind": "Item",
            "self": "http://localhost:5000/api/v1/user/items/2"
        }
    ],
    "kind": "ItemCollection",
    "last": "http://localhost:5000/api/v1/user/items?page=1",
    "next": null,
    "prev": null,
    "self": "http://localhost:5000/api/v1/user/items?page=1"
}

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20156.png)
附注

除了对资源进行分页，如果API要面临大量的访问，常常还需要对客户端的访问频次进行限制，以降低服务器的负荷。这首先需要客户端注册账户，本书暂不展开介绍。

#### 10.3.6  资源的反序列化

以前我们使用Flask-WTF获取并验证表单数据时，它会自动从请求对象的form属性中获取表单数据，然后根据在表单类上设置的验证函数对每个数据进行验证。而在Web API中，我们也需要获取POST、PUT、PATCH等请求中包含的数据，然后验证这些数据的格式是否符合要求，最后存储于数据库中。这个过程被称为资源的反序列化（Deserialization）。

1.反序列化处理

在接收POST方法的资源方法中，我们需要做相反的工作：从请求对象处获取客户端发来的JSON数据，验证数据格式，并将其对应的值存储到数据库字段中。在我们的Web API中，唯一需要接收的数据就是条目的body值，为了避免重复，我们把接收并验证条目body字段的工作放到get_item_body()函数中完成，如代码清单10-23所示。

代码清单10-23 todoism/apis/v1/resources.py：获取请求JSON中的body值

------

```
def get_item_body():
    data = request.get_json()
    body = data.get('body')
    if body is None or str(body).strip() == '':
        raise ValidationError('The item body was empty or invalid.')
    return body

```

------

我们从request对象的get_json()方法中获取解析后的JSON数据，使用键来获取对应的值。

在get_item_body()函数中，我们还需要对数据进行验证。如果body值为None或是空白，我们需要返回400响应。但因为get_item_body()由视图方法调用，我们并不能在这里使用api_abort()函数，只能通过抛出异常的方式来处理错误。我们在errors.py脚本中定义了一个ValidationError异常类，它继承Python中的ValueError类：

------

```
class ValidationError(ValueError):
    pass

```

------

然后我们可以使用Flask提供的errorhandler装饰器为这个异常类注册一个错误处理函数，当抛出这个异常时，这个错误处理函数就会被调用。在这个函数中，我们使用api_abort()函数返回400错误响应，它还接收异常类传入的参数作为错误消息，如代码清单10-24所示。

代码清单10-24 todoism/apis/v1/errors.py：为自定义异常类注册错误处理函数

------

```
@api_v1.errorhandler(ValidationError)
def validation_error(e):
    return api_abort(400, e.args[0])

```

------

在对应资源类的post()方法中，我们调用get_item_body()函数获取条目的body值，并保存到数据库中，以创建条目的方法为例：

------

```
class ItemsAPI(MethodView):
    decorators = [auth_required]
    ...
    def post(self):
        """Create new item."""
        item = Item(body=get_item_body(), author=g.current_user)
        db.session.add(item)
        db.session.commit()
        response = jsonify(item_schema(item))
        response.status_code = 201  # 表示已创建（Created）
        response.headers['Location'] = url_for('.item', item_id=item.id, _external=True)
        return response

```

------

为了方便用户，我们在创建条目后返回新创建的条目资源作为响应，设置状态码为201，表示已创建。另外，我们还在响应首部的Location字段设置新创建条目的URL，方便用户发起新请求。

2.使用Webargs解析请求

因为我们的程序非常简单，创建待办条目时只需要验证body字段。但对于大型程序来说，反序列化时通常需要处理多个资源，每个资源又包含多个不同的字段，这时手动验证数据就会非常繁琐，而且容易出错，我们需要借助工具来简化工作。Webargs是一个用于解析HTTP请求参数的Python库，它主要基于Python序列化/反序列化工具Marshmallow（ [https://github.com/marshmallow-code/marshmallow/](https://github.com/marshmallow-code/marshmallow/) ）实现，添加了HTTP请求解析支持。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20157.png)
附注

Marshmallow的用法和WTForms类似，通过创建模式类事先定义好字段类型以及验证函数。对模式类对象调用dump()方法和load()方法分别执行序列化和反序列化操作，同时对传入的对象进行验证，并返回验证后的数据字典和相应的错误消息字典。在复杂的程序中，我们可以将Webargs搭配Marshmallow使用。

Webargs可以解析请求中包含的表单、查询字符串、JSON、cookies、files、首部字段等一系列数据，然后根据预定的样式进行验证，如果验证未通过会生成内置的错误消息。在某种程度上，它可以说是加强版的Flask-WTF。

与使用WTForms时定义的表单类类似，我们通过字典来定义某个资源的模式。比如，下面的user_args字典使用Webargs提供的字段定义了一个表示注册用户的资源模式，每个字段通过各自的字段类来限定内容：

------

```
from webargs import fields, validate

user_args = {
    'username': fields.Str(required=True),
    'password': fields.Str(validate=validate.Length(min=6)),
    'display_per_page': fields.Int(missing=10),
}

```

------

资源模式字典（参数字典）的键在解析请求时会用做键来获取对应的数据，而字典中的键值则定义了字段的类型，在验证时会用来验证数据。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20255.png)
提示

你可以在字段类中使用关键字参数来定义验证的具体行为，比如将required设为True表示不能为空；使用missing参数设置未找到对应数据时使用的默认值；使用error_messages参数可以定义错误消息字典等。

Webargs通过webargs.flaskparser模块提供了与Flask集成的解析相关函数。在处理注册用户的视图中，我们使用webargs.flaskparser模块中的parser函数解析数据、传入参数字典和请求对象request：

------

```
from flask import request
from webargs.flaskparser import parser

@app.route('/register', methods=['POST'])
def register():
    args = parser.parse(user_args, request)
    user = User(username=args['username'], per_page=args['display_per_page'])
    user.set_password(args['password'])
    db.session.add(user)
    db.session.commit()
    ...

```

------

对于使用方法视图的程序，上面的代码可以放到资源类的post()方法中执行。

除了使用webargs.flaskparser.parser函数解析，我们也可以使用use_args()装饰器传入参数字典，它会自动从请求对象中获取数据，并获取对应的数据，然后进行验证：

------

```
from webargs.flaskparser import use_args

@app.route('/register', methods=['POST'])
@use_args(user_args)  # 传入参数字典
def register(args):
    user = User(username=args['username'], per_page=args['display_per_page'])
    user.set_password(args['password'])
    db.session.add(user)
    db.session.commit()
    ...

```

------

在上面的示例中，视图函数接收args字典作为参数，这是包含所有匹配字符名和对应值的字典，我们可以通过它来获取通过验证后的请求数据。另外，我们也可以显式地接收关键字参数：

------

```
from webargs.flaskparser import use_args

@app.route('/register', methods=['POST'])
@use_kwargs(user_args)
def register(username, password, display_per_page):
    user = User(username=username, per_page=display_per_page)
    user.set_password(password)
    db.session.add(user)
    db.session.commit()
    ...

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20256.png)
提示

Webargs在解析请求时，从请求对象request获取数据的位置依次为查询字符串（request.args）、表单（request.form）和JSON（request.json）。你也可以在use_args()装饰器中使用locations参数显式指定一个数据位置列表/元组，可用的值为querystring（等同于query，表示查询字符串）、json（表示JSON）、form（表示表单数据）、headers（表示首部字段）、cookies（表示Cookie）和files（表示文件）。

当验证出错时，Webargs会返回422响应（Unprocessable Entity，表示实体无法处理，即语义错误），我们可以注册一个对应的错误处理函数，如下所示：

------

```
@app.errorhandler(422)
def handle_validation_error(e):
    exc = e.exc
    return jsonify({'errors': exc.messages}), 422

```

------

Webargs内置的异常对象存储在错误处理函数接收的HTTP异常对象的exc属性中，而错误消息存储在Webargs内置异常对象的messages属性中。这个messages属性是Webargs根据验证情况生成的一个匹配字段名到错误消息列表的字典。

一些辅助编写Web API的Flask扩展逐渐转向使用Marshmallow和Webargs，但是因为这一系列变化还正在发生，这几个工具的集成和可用性还不够完善，所以Todoism中的代码暂时没有选用这些扩展工具。这里只是一个简单的介绍，更多的用法请访问Webargs的官方文档（ [https://webargs.readthedocs.io](https://webargs.readthedocs.io) ）查看。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20158.png)
附注

Marshmallow的开发者还提供了一个Flask扩展Flask-Marshmallow（ [https://github.com/marshmallow-code/flask-marshmallow](https://github.com/marshmallow-code/flask-marshmallow) ）。另外，Flask扩展Flask-Apispec，它集成了Apispec、Marshmallow和Webargs。 

3.处理错误响应

和其他程序一样，Todoism使用app.error_handler装饰器注册了全局错误处理器。但是Web API中的错误响应不能返回HTML模板，而应该返回包含错误信息提示的JSON数据。所以我们在API蓝本中返回错误响应时使用我们自定义的，用于生成JSON错误响应的api_abort()函数，而不是Flask提供的abort()函数。api_abort()函数的定义如代码清单10-25所示。

代码清单10-25 todoism/apis/v1/errors.py：错误响应处理函数

------

```
from flask import jsonify
from werkzeug.http import HTTP_STATUS_CODES

def api_abort(code, message=None, **kwargs):
    if message is None:
        message = HTTP_STATUS_CODES.get(code, '')

    response = jsonify(code=code, message=message, **kwargs)
    response.status_code = code
    return response

```

------

我们可以使用它自定义错误响应的内容。code参数用来指定状态码，message参数用来指定错误提示消息。如果message没有指定，那么将使用状态码的原因短语，从Werkzeug中的HTTP_STATUS_CODES字典获取（使用状态码作为键）。

这个api_abort()函数只能用于生成一般的错误响应，我们还需要特别注意的是404、405、500和503（Service Unavailable，表示服务不可用）错误，因为这些错误由Flask直接处理，发生错误时会触发全局的错误处理函数，如果没有定义对应的错误处理函数，则返回默认的HTTP响应。为了让API蓝本中的端点和程序端点都能获得各自需要的响应，我们需要对相应的全局错误处理函数进行一些改动。以404错误为例，如代码清单10-26所示。

代码清单10-26 todoism/__init__.py：支持JSON响应的404错误处理器

------

```
def register_errors(app):
    @app.errorhandler(404)
    def page_not_found(e):
        if request.accept_mimetypes.accept_json and \
                not request.accept_mimetypes.accept_html \
                or request.path.startswith('/api'):
            response = jsonify(code=404, message='The requested URL was not found on the server.')
            response.status_code = 404
            return response
        return render_template('errors.html', code=404, info='Page Not Found'), 404

```

------

我们在上一节编写Todoism时了解过，请求首部字段Content-Type可以用来告诉服务器客户端所期待的响应内容类型。在服务器端，程序就可以根据这个字段的内容来返回不同格式的响应。Flask将Content-Type字段解析到request.accept_mimetypes，我们通过判断request.accept_mimetypes.accept_json和request.accept_mimetypes.accept_html的值来确定客户端所期待的响应格式，并返回对应的响应内容。这种机制被称为HTTP内容协商（Content Negotiation）。除了Accept字段，其他一系列Accept-*字段可用来设置期望的语言、编码和字符集。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20257.png)
提示

如果你编写的Web API是作为单独的程序而不是蓝本，那么可以直接在全局错误处理器中返回JSON响应。

为了让API更加健壮，我们除了检查Accept字段外，还验证请求的路径（request.path）是否以“/api”开头。如果客户端没有设置Accept字段，但访问的是API的端点，这时程序也会返回JSON响应。如果你的API根地址是类似 [http://api.example.com/v1](http://api.example.com/v1) 的形式，那么可以将最后的if判断条件替换为： 

------

```
if ... or request.host.startwith('api')
    ...

```

------

500错误的处理方法与其基本相同。

405错误响应一般只会发生在API中，我们可以直接返回JSON格式的响应。

------

```
def register_errors(app):
    @app.errorhandler(405)
    def method_not_allowed(e):
        response = jsonify(code=405, message='The method is not allowed for the requested URL.')
        response.status_code = 405
        return response

```

------

为了保证API可以正常服务，我们可以通过添加新版本来更新API。但在某些特殊情况下，我们不得不临时停止服务。这时我们需要返回503错误，表示服务临时不可用。由于我们的程序很简单，503错误处理器也可以直接返回JSON响应。处理方式和解决405错误类似。

在大型的Web API中，我们常常需要设置自定义的错误码，用来表示和程序相关的错误。为了和HTTP的标准错误码相区分，自定义错误码一般为4位数，使用和HTTP错误码相同的分类方法（2开头表示成功，4开头表示客户端错误，5开头表示服务器错误）。同时，我们还可以在错误响应中加入详细的错误信息，必要时，还会附上API文档中相关部分的URL。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2096.png)
注意

当程序出现500错误时，为了返回正确的响应，我们需要关闭Flask的调试模式（具体见第1章）。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20258.png)
提示

HTTP错误内置的错误状态码、原因短语和描述可以通过HTTP异常对象的status_code、name和description属性获取，这里为了直观而手动写出，具体可参考第3章的内容。

#### 10.3.7  Web API的测试与发布

有多种工具可以用来手动测试Web API，比如Bash内置的curl（ [https://curl.haxx.se/](https://curl.haxx.se/) ），或是使用Python编写的HTTPie（ [https://httpie.org/](https://httpie.org/) ）等。除了命令行工具，我们还可以选用更加直观、更容易上手的GUI工具，比如Postman（ [https://www.getpostman.com/](https://www.getpostman.com/) ）。在本节，我们会简单介绍使用HTTPie对API进行测试。在本书的第三部分，我们会学习编写Web API自动化测试。 

1.使用HTTPie测试

使用Postman等GUI工具测试Web API非常简单，这里不再展开介绍。如果你偏爱命令行，那么可以尝试一下HTTPie。HTTPie和同类的curl相比，它的命令更加简洁直观，易于记忆和使用。它内置了JSON支持，而且对输出的字符进行了排版和高亮处理。我们首先使用Pipenv或pip安装它（添加--dev选项标记为开发用的包）：

------

```
$ pipenv install httpie --dev

```

------

然后我们就可以在命令行中使用它了。在HTTPie中，请求从http命令开始，一个最完整的请求语句大概会是这样：

------

```
$ http [ 选项（flags）] [ 方法] URL [ 查询字符串/ 数据字段/ 首部字段]

```

------

比如：

------

```
$ http –json GET api.example.com name==greyli data=test Header-Foo:bar

```

------

从上面的示例可以看出HTTPie对不同的内容使用不同的符号，主要的语法如表10-6所示。

表10-6 HTTPie数据语法

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAW-ELUIJAAAAAEUFBYE454360372.jpg)

为了简化输入，HTTPie提供了一系列缺省选项，这些选项的默认值如表10-7所示。

表10-7 HTTPie的缺省选项

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAW-EKJdFAAAAAM2U2W4380281048.jpg)

当请求包含数据时，HTTPie会默认将Content-Type字段以及Accept字段的值设为JSON类型（application/json）。如果想在不包含数据的请求中指定Accept字段为JSON类型，可以显式地使用--json参数。

下面的命令用于向API首页发送GET请求：

------

```
$ http :5000/api/v1/

```

------

使用HTTPie获取令牌时需要把认证信息以www-x-formencode的形式写入请求主体（Body），所以这里我们需要使用--form选项：

------

```
$ http --form :5000/api/v1/oauth/token grant_type=password username=grey password=123
HTTP/1.0 200 OK
Access-Control-Allow-Origin: *
Cache-Control: no-store
Content-Length: 197
Content-Type: application/json
Date: Wed, 13 Sep 2017 06:38:15 GMT
Pragma: no-cache
Server: Werkzeug/0.12.2 Python/2.7.13

{
    "access_token": "eyJhbGciOiJIUzI1NiI...",
    "expires_in": 3600,
    "token_type": "Bearer"
}

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20259.png)
提示

如果需要对客户端进行认证，可以使用-a参数指定使用Basic认证，并提供客户端ID和密码：$http–a username：password example.com

在接下来的一小时内，我们就可以使用令牌来认证，下面的命令用来获取当前用户资源：

------

```
$ http :5000/api/v1/user Authorization:"Bearer eyJhbGciOiJIUzI..."

```

------

创建一个新条目可以使用下面的命令：

------

```
$ http POST :5000/api/v1/user/items body="test item body." Authorization:"Bearer eyJhbGciOiJIUzI..."

```

------

为了避免每次请求都需要输入Authorization字段，可以使用--session命令来将Authori-zation字段临时存储在本地，比如：

------

```
$ http --session=Authorization :5000/api/v1/user Authorization:"Bearer eyJhbGciOiJI... "

```

------

然后就可以在获取资源时加入--session选项--session=Authorization，不必再输入Authori-zation字段的值，比如：

------

```
$ http :5000/api/v1/user --session=Authorization

```

------

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%2097.png)
注意

在Windows系统的命令行中，数据的值需要使用双引号括起来，否则会按照空格分离导致解析出错。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20159.png)
附注

更多的用法可以在HTTPie的官方文档（ [https://httpie.org/doc](https://httpie.org/doc) ）上看到。 

2.发布与壮大

我们的API终于编写完成了。如果你打算公开API，那么就希望会有人来使用它。在这之前，我们要做的是最基本的事情就是为它编写一份基本的文档，这样其他的开发人员才会知道如何使用它。你可以考虑使用Sphinx（ [http://www.sphinx-doc.org](http://www.sphinx-doc.org) ）编写文档，一种方式是撰写单独的文档文件，你还可以使用Sphinx将API代码中的注释自动生成为API文档。这样我们就可以保持代码与文档同步更新。Sphinx使用reStructuredText（ [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.xhtml) ）语言。 

还需要提及的是Web API的设计语言/规范，比如Swagger（ [https://swagger.io/](https://swagger.io/) ）、API Blueprint（ [https://apiblueprint.org/](https://apiblueprint.org/) ）、RAML（ [https://raml.org/](https://raml.org/) ）等。它们都是高层的API描述语言，使用它们可以设计、开发原型、编写文档、测试Web API，几乎包括Web API的整个生命周期。除此之外，它们还有各种各样的官方或第三方工具可以使用。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20160.png)
附注

如果你使用Flask-apispec扩展开发API，那么它内置了自动生成Swagger 2.0文档的功能。

很多大型在线服务在提供API的同时还提供了使用浏览器来测试和操作API的API Console（API控制台）的功能，比如Google提供的API explorer（ [https://developers.google.com/apis-explorer](https://developers.google.com/apis-explorer) ）。借助API Console，开发人员可以浏览API提供的所有资源及其详细信息，并且可以直接发起相关请求。自己编写API Console比较麻烦，我们可以使用Apigee（ [https://apigee.com](https://apigee.com) ）来自动生成API Console。 

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20161.png)
附注

Apigee同时也提供了API管理服务——Apigee Edge（ [https://apigee.com/edge](https://apigee.com/edge) ），它提供了API的设计、监控等一系列功能。 

最后，当API的使用者增多后，为了方便不同语言的开发人员，你可能还要考虑发布SDK（Software Development Kit，软件开发工具包）。SDK是提供给API使用者（开发人员）的便利工具，比如使用Python调用API实现资源操作的库。

在现实生活中，Web API的设计需要投入很大的精力，尤其是在客户端认证以及安全防范方面。本节作为使用Flask实现Web API的例子，对于Web API的设计只是一个简单的介绍。如果你想进一步学习Web API的设计与开发，可以阅读相关书籍。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 10.4  本章小结

在本章，我们学习了一个“特别”的Flask程序，除此之外，我们还学习了如何为程序进行国际化和本地化处理，以及为程序编写Web API。下一章我们会实现一个聊天室程序，并学习一些新鲜的内容。

![](/Users/cooper/Library/Mobile Documents/com~apple~CloudDocs/AID/PROJECT/FlaskBook/AAATOP_Flask_web_book/Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20260.png)
提示

如果你发现了程序中的错误或者有任何改进建议，可以在Todoism的GitHub项目（ [https://github.com/greyli/todoism](https://github.com/greyli/todoism) ）中创建Issue，或是在fork仓库修改后并在GitHub上提交Pull Request。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 