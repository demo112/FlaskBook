11.5.3  代码语法高亮

代码语法高亮（Code Syntax Highlight）即为代码添加色彩样式以便增加可读性，比如使用文本编辑器时显示的代码样式。在第4章我们使用Flask-CKEditor扩展提供的内置CKEditor包即包含这个功能。


提示

如果你从GitHub上复制了示例程序，可以执行git checkout highlight签出程序的新版本。程序的新版本实现了代码语法高亮支持。

Pocoo团队开发的Pyments库是一个优秀的代码高亮工具，在这里我们并不直接使用它，因为Markdown库包含了集成Pyments的扩展——CodeHilite（ https://python-markdown.github.io/extensions/code_hilite/ ）。 


附注

所有可用的扩展列表可以在Markdown库的文档（ https://python-markdown.github.io/extensions/ ）中看到。 

为了使用CodeHilite，我们需要先安装Pyments：

------

```
$ pipenv install pyments

```

------

那么，Pyments是如何为代码添加色彩的呢？对于HTML格式来说，通过解析代码片段的语法结构，Pyments会使用<span>标签分隔每一个语法单元，并添加对应的样式类，最后通过加载对应的CSS文件即可实现代码“上色”。

在使用markdown()函数将Markdown源文本转换成HTML时，CodeHilite扩展会自动使用Pyments解析源文本中包含的代码块，并为解析后的代码块添加对应的样式类。CodeHilite检测代码块的方式和Markdown标准语法相同，即四个空格缩进的为代码块。在代码块的上一行使用#！或：：：符号可以指定语言，如果不指定则由Pyments自动探测。一段合法的Python代码块如下所示：

------

```
:::python
for i in range(100):
    print(i)

```

------

但对于需要编辑或复制大量代码的情况就比较麻烦，因为每一行都需要额外的缩进。这时我们可以使用另一个Markdown库的内置的Fenced Code Blocks（ https://python-markdown.github.io/extensions/fenced_code_blocks/ ）扩展来简化操作。顾名思义，它提供了围栏（fence）的方式来定义代码块，而且它内置了对CodeHilite的支持。它支持两种代码块语法，一种是使用PHP Markdown Extra（ https://michelf.ca/projects/php-markdown/extra/ ）风格语法来定义代码块，使用四个连续波浪号，在随后的花括号中指定语言，比如： 

------

```
~~~~{.python}
for i in range(100):
    print(i)
~~~~

```

------

指定语言的大括号也可以省略：

------

```
~~~~.html
<p>HTML Document</p>
~~~~

```

------

另一种是我们熟悉的GitHub风格语法，使用三个连续反引号，语言写在开头的三个反引号后：

------

```
​```python
for i in range(100):
    print(i)

```

------

要使用内置的扩展，我们只需要使用markdown()方法转换HTML时通过extensions参数指定使用的扩展名称，如下所示：

------



------

借助这两个扩展，下面的Markdown源文本：

------

Here is the minimal Flask application:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello, Flask!'

```

------

会被转换成下面的HTML文本：

------

<p>Here is the minimal Flask application:</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

app = Flask(name)

@app.route('/')
def index():
    return 'Hello, Flask!'
</pre></div>

------

现在，我们需要使用Pyments提供的pygmentize命令生成包含代码高亮CSS规则的CSS文件：

------



------

在上面的命令中，-f html用来将格式指定为html，这会生成HTML使用的CSS规则。-S monokai用来将代码样式主题指定为monokai。最新版本的Pygments内置了29种主题，你可以使用下面的pygmentize-L styles命令查看可用的主题。-a.codehilite用来将生成样式类的基类指定为.codehilite，它是CodeHilite解析代码片段后默认添加的基类。这条命令会直接把生成的CSS规则输出在命令下方，我们可以将它们复制粘贴到自定义样式类的styles.css文件中。


附注

你也可以在上面的命令结尾添加>来指定输出的文件对象，比如>codestyles.css。我们需要把这个文件移动（或直接指定最终输出位置）到static/css目录下，然后在基模板中加载这个CSS文件。但是为了减少页面加载请求的数量，最好还是将CSS规则合并在单个文件中。

重载页面后，添加了代码高亮，上面的代码块实际的效果如图11-8所示。


图11-8 渲染后的代码块


提示

对于所有主题的实际效果可以访问Pygments官网的DEMO页面查看示例（比如 http://pygments.org/demo/6717666/ ），单击右侧的主题下拉列表可以更换主题。 


附注

页面上的输入框太小，不适合输入大段的代码块。我们添加了一个用来输入大段文本或代码块的模态框，并在输入框右侧添加一个按钮来触发它，具体可以到源码仓库中查看。作为替代选项，你也可以考虑使用JavaScript让输入框随着输入的文本高度自动增加高度。

#### 11.5.4  标签页消息提醒

作为一个聊天室程序，消息提醒的功能必不可少。如果你使用Twitter，当你在浏览器中打开Twitter，然后转而浏览其他页面，这时如果有新的推文，那么Twitter页面所在的标签页标题会实时显示未读推文的数量。在图片社交网站中，我们会在有新消息后在导航栏的收件箱图标上添加一个红色的消息数量徽章。而在聊天室程序中，消息会直接显示在列表中，所以没必要在导航栏上设置数量提醒。我们可以为聊天室添加类似Twitter的标签页数量提醒功能。


提示

如果你从GitHub上复制了示例程序，可以执行git checkout notify签出程序的新版本。程序的新版本实现了提醒功能。

我们在客户端使用new message事件处理函数监听来自服务端的新消息事件，所以我们可以在对应的回调函数中更新标签页标题，如代码清单11-15所示。

代码清单11-15 catchat/static/js/script.js：在标签页标题中显示消息数量

------

```
var message_count = 0;
...
socket.on('message', function(data) {
    message_count++;
    if (!document.hasFocus()){
        document.title = '(' + message_count + ') ' + document.title;
    }

```



------

消息数量使用变量message_count存储，首先使消息数量加1。document.hasFocus()方法用来获取当前页面的激活状态，返回布尔值。我们添加一个if判断，如果页面未激活，那么就在页面标题（document.title）前加入消息数量，加入未读消息数量后的标签页标题如图11-9所示。


图11-9 标签页数量提醒

另外，我们使用jQuery提供的focus()方法注册一个回调函数，当页面被激活时会还原标题并清零消息计数：

------



```
...
$(window).focus(function(){
       message_count = 0;
       document.title = 'CatChat';
   });

```



------


提示

这里使用Focus management APIs（ https://www.w3.org/TR/html/editing.xhtml#focus-manage-ment-apis ）实现比较简单，如果想要让代码更加健壮，可以考虑使用Page Visibility API（ http://www.w3.org/TR/page-visibility/ ），用法介绍可以在MDN（ https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API ）上看到。 


附注

使用favico.js（ http://lab.ejci.net/favico.js/ ）可以在Favicon上显示一个消息数量badge，而且有丰富的自定义选项。 

#### 11.5.5  浏览器桌面通知

桌面通知（Desktop Notification）是基于Notifications API（ https://www.w3.org/TR/notifica-tions/ ）实现的浏览器层面上的通知机制，目前新版本的Edge、Chrome、Firefox和Safari浏览器都提供了支持。当用户授权后，只要浏览器处于运行状态，新消息就可以以弹窗的形式在操作系统的桌面上弹出。我们可以在页面第一次加载时向用户请求开启桌面通知，如代码清单11-16所示。 

代码清单11-16 catchat/static/js/script.js：请求开启桌面通知

------



document.addEventListener('DOMContentLoaded', function () {
  if (!Notification) {
       alert('Desktop notifications not available in your browser.');
       return;
  }

  if (Notification.permission !== "granted")
    Notification.requestPermission();
});

------

在JavaScript脚本中，我们创建一个表示DOM内容加载完成的DOMContentLoaded事件的监听函数。在函数中，我们首先判断用户浏览器是否支持Notification API，如果不支持就显示一个提示（alert）。只读属性Notification.permission存储用户的许可状态值，这个属性有三个可选值：granted表示允许，denied表示拒绝，默认为default（等同于denied）。如果Notification.permission的值不是granted，那么就调用Notification.requestPermission()方法请求授权，这会在用户浏览器中弹出一个授权请求窗口。


提示

作为替代选项，你也可以在页面上添加设置按钮来让用户主动开启。

然后，我们创建一个messageNotify()函数用来在接收到新消息时发送提醒，如代码清单11-17所示。

代码清单11-17 catchat/static/js/script.js：发送新消息提醒

------



...
function messageNotify(data) {
  if (Notification.permission !== "granted")
    Notification.requestPermission();
  else {
    var notification = new Notification("Message from " + data.name, {
      icon: 'https://gravatar.com/avatar/' + data.email_hash + '?d=monsterid',
      body: data.message_body.replace(/(<(>+)>)/ig,""),
    });

notification.onclick = function () {
  window.open(root_url);
};
setTimeout(function() { notification.close() }, 4000);

  }
};

------

messageNotify()函数用来发送新消息提醒，那么自然应该在new message事件处理函数中调用。messageNotify()函数接收的data参数是服务器端发来的数据。在这个函数中，我们再次判断用户的授权状态，如果没有允许就再次调用Notification.requestPermission()方法。提醒消息使用Notification实例表示，弹窗的标题作为实例化时的第一个参数传入，可选的第二个参数用来传入附加的选项，我们在这里只定义了icon和body键，分别用来指定提醒内显示的图标和内容主体。


注意

因为提醒弹窗中只会解析纯文本，所以对message_body调用replace（/（<（>+）>）/ig，""），以便删除文本中包含的HTML标签。你也可以在服务器端使用Python来处理，除了使用正则表达式匹配，还可以使用我们前面介绍的bleach包清理，或是在渲染模板字符串时使用Jinja2中的striptags过滤器。

为notification.onclick属性定义的函数会在提醒弹窗被单击时执行，我们这里调用window.open（root_url）打开聊天室主页。这个JavaScript变量root_url表示程序的主页，在基模板中定义，使用url_for()函数获取对应的URL：

------



<script type="text/javascript">
    var root_url = "{{ url_for('chat.home') }}";
</script>
------

最后，我们使用setTimeout()方法设置4秒后调用notification.close()方法关闭弹窗。

因为在弹出消息弹窗时我们需要显示必要的消息信息，即消息的发送者昵称（data.nickname）、头像（data.gravatar）以及消息正文（data.message_body），所以我们需要在服务器端的new message事件处理函数返回这些信息：

------



@socketio.on('new message')
def new_message(message_body):
    ...
    emit('new message',
        {'message_html': render_template('_message.html', message=message),
         'message_body': message_body,
         'gravatar': current_user.gravatar,
         'nickname': current_user.nickname,
         'user_id': current_user.id},
        broadcast=True)

------

除了这三个数据，我们还传入了当前用户的id，这会在下面用来判断消息的发送者。很显然，对于用户自己发送的消息，并不需要弹出提醒。服务器端传入的id值会被用来在客户端判断当前用户是否是消息发送者。为了实现这个判断，我们还需要在模板中添加一个JavaScript变量current_user_id，设置default过滤器对匿名用户设为0：

------



<script type="text/javascript">
    var current_user_id = {{ current_user.id|default(0) }};
</script>

```
- - - -

在new message事件处理函数中，我们在data.user_id和current_user_id不相等时调用这个函数，并传入服务器端发送的数据data：

- - - -



```

...
socket.on('new message', function(data) {
    ...
    if (data.user_id !== current_user_id) {
        messageNotify(data);
    };
});

```
- - - -

在Chrome浏览器中，消息弹窗的示例如图11-10所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEZYG0AAAAAL6VjOY095747126.jpg)
图11-10 消息弹窗示例

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20183.png)
附注

关于Notifications API最新的标准在whatwg.org（ [https://notifications.spec.whatwg.org/](https://notifications.spec.whatwg.org/) ）上可以看到，用法文档可以在MDN（ [https://developer.mozilla.org/en-US/docs/Web/API/notification](https://developer.mozilla.org/en-US/docs/Web/API/notification) ）上看到。 

#### 11.5.6  消息管理

消息管理的功能比较简单，我们不再详细介绍，具体可以到源码仓库中查看。每个登录的用户都可以看到消息一侧的功能按钮。我们不需要实现消息的编辑功能，但需要提供删除功能。和我们在上一章介绍的内容相同，删除按钮单击后会通过jQuery向对应的URL发送AJAX请求，删除成功后在客户端使用jQuery的remove()方法移除消息。

程序没有实现管理后台，但添加了一个简单的“嵌入式”的管理功能。管理员通过Email地址识别，当用户为管理员时，所有消息一侧的功能下拉框都会包含删除按钮，而且在用户的资料弹窗上同时添加了一个封禁按钮，用于封禁恶意用户。

另外，我们还添加了一个引用功能，当用户单击消息一侧的引用按钮时，消息的正文会添加到输入框里，并附加一个引用符号“>”。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20291.png)
提示

如果你从GitHub上复制了示例程序，可以执行git checkout admin签出程序的新版本。程序的新版本添加了消息管理功能。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 11.6  本章小结

虽然一个简单的聊天室已经完成了，但离一个真正的聊天室还差得远。比如，我们还可以考虑实现的有@用户、消息收藏、私聊等功能。你可以在项目的GitHub页面（ [https://github.com/geryli/catchat](https://github.com/geryli/catchat) ）fork它，然后改造一个你自己的版本。 

至此，本书的第二部分就已经完满结束了。经历过这么多的实践，想必你已经对Flask相当熟悉了。在本书的第三部分，我们将学习如何对程序进行测试和优化，最后将程序部署到服务器上，让我们的Web程序走进Web。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20292.png)
提示

如果你发现了程序中的错误或者有改进建议，可以在CatChat的GitHub项目（ [https://github.com/geryli/catchat](https://github.com/geryli/catchat) ）中创建Issue，或是在fork仓库并修改后在GitHub上提交Pull Request。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXGETyF6AAAAANJyhqI405480588%203.png)

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXGESY0iAAAAAKZf9eo909068142%203.png)

# 第三部分

# 进阶篇

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEVRf_AAAAAOKw6s8293087594.jpg)

注：Icons made by Nikita Golubev www.flaticon.com is licensed by CC 3.0 BY

大部分人肯定不希望自己的程序只能在自己的电脑上使用，而如果把程序部署到互联网上，就要考虑到程序的性能、维护和测试等问题。这一部分我们会学习部署的基本流程以及部署前的准备工作。另外，我们还会学习如何编写Flask扩展。最后，我们会了解Flask的主要设计理念和工作机制。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

## 第12章

## 自动化测试

测试必不可少。在此之前，每当为程序添加了新的功能，我们就需要手动打开浏览器访问程序，并测试各项功能是否正常。比如，新添加的留言是否显示在留言列表中；访问不存在的资源时是否会显示自定义的404页面……这样重复无聊的工作当然应该避免。而且，当程序功能变多后，手动测试所有功能不太现实。这时我们需要自动化测试，即编写代码来自动测试主要的程序功能，这样可以显著提高测试的效率和准确度。

本章新涉及的Python包的版本与主页如下所示：

·Selenium（3.11.0）

·主页： [https://www.seleniumhq.org/](https://www.seleniumhq.org/) 

·文档： [https://docs.seleniumhq.org/](https://docs.seleniumhq.org/) 

·源码： [https://github.com/SeleniumHQ/selenium](https://github.com/SeleniumHQ/selenium) 

·Flake8（3.5.0）

·主页： [https://github.com/PyCQA/flake8](https://github.com/PyCQA/flake8) 

·文档： [http://flake8.pycqa.org/en/latest/](http://flake8.pycqa.org/en/latest/) 

·Coverage（4.5.1）

·主页： [https://bitbucket.org/ned/coveragepy](https://bitbucket.org/ned/coveragepy) 

·文档： [https://coverage.readthedocs.io](https://coverage.readthedocs.io) Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 12.1  认识自动化测试

在开发时，每当添加一些新功能时，都会编写相应的测试来确保代码按照预期工作。这样当功能累积后，每次都可以通过测试来检查代码是否正常工作。在每次提交代码到代码仓库的主分支前，或是对线上的程序进行部署更新前，都要确保程序通过所有的测试。

测试代码应该和程序开发同步进行，通常的工作流程是：编写一部分代码，立刻编写配套的测试，运行测试确保一切正常，继续编写新功能，编写配套测试……按照这个流程不断迭代直至程序完成。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20111.png)
注意

为了便于组织内容，本书第二部分的示例程序的测试代码均在名称为testing的标签中提交，你可以通过git checkout testing命令签出。在实际开发中，请避免这种行为。

顺便提一下，还有一种测试优先的开发模式——测试驱动开发（Test-Driven Development，TDD）。在TDD中，测试是先于开发进行的。比如你要实现某个功能，那么先编写对应的测试，接着编写代码，不断完善代码直至通过测试为止。通过这种周期的不断循环直至实现整个程序。这种开发模式简化了开发的过程，因为它遵循KISS（Keep It Simple，Stupid）和YAGNI（You Aren抰Gonna Need It）原则，通过这种模式编写出的代码会非常简洁，因为你的目的只是通过测试，测试严格塑造了程序的功能，不会产生多余的代码和程序功能。

自动化测试主要分为下面三种：

1）单元测试（Unit Test）：对单独的代码块，比如函数进行测试。单元测试是自动化测试的主要形式，也是最基本的测试方式。

2）集成测试（Integration Test）：集成测试对代码单位之间的协同工作进行测试，比如测试Flask和各个Flask扩展的集成代码。这部分的测试不容易编写，各个扩展通常会包含集成测试。在部署到云平台时，集成测试可以确保程序和云平台的各个接口正常协作。

3）用户界面测试（User Interface Test）：也被称为端对端测试或全链路测试，因为需要启动服务器并调用浏览器来完成测试，所以耗时比较长，适合用来测试复杂的页面交互，比如包含JavaScript代码和AJAX请求等实现的功能。

这三类测试的合理的结构比例关系如图12-1所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCESFrvAAAAAIc1uhY566752768.jpg)
图12-1 测试比例关系图 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 12.2  Flask测试客户端

在进行测试时，我们通常会需要模拟请求——响应的处理过程。比如，我们想要测试向index端点发送请求时返回的响应中是否包含网页标题；或是向发表文章的视图发送请求创建文章，测试返回响应是否包含新创建的内容。

Flask通过app.test_client()方法提供了一个测试客户端，这会模拟一个Web服务器环境。通过对程序实例app调用这个方法会返回一个测试客户端对象，通过对这个对象调用get()和post()方法可以模拟客户端对服务器发送请求，我们可以从这两个方法返回的响应对象获取响应数据。

下面以SayHello程序为例，向首页发送一个GET请求：

- - - -


```

$ flask shell

> > > client = app.test_client()  # 创建测试客户端对象
> > > client.get('/')  # 发送GET请求
> > > <Response streamed [200 OK]>
> > > response = client.get('/')
> > > response.get_data()  # 获取字符字节串（bytestring）格式的响应主体
> > > '<!DOCTYPE html>\n<html lang="en">\n...
> > > response.get_data(as_text=True)  # 获取解码为Unicode字符串后的响应主体
> > > u'<!DOCTYPE html>\n<html lang="en">\n...
> > > b'Say Hello' in response.get_data()
> > > True
> > > response.status_code  # 响应状态码
> > > 200
> > > response.status  # 响应状态字符串
> > > '200 OK'

```
- - - -

get()方法模拟向服务器发送GET请求，第一个参数是请求的URL。对返回的Response对象调用get_data()方法默认返回字节字符串（bytestring，又被译为字节串）形式的响应主体。字节字符串即Python 2中的str类型。在Python 3中字符串默认为unicode类型，因此需要在字符串前添加b前缀，将字符串声明为bytes类型。在上面为了兼容两者，我们统一添加了b前缀：

- - - -



```

> > > b'Say Hello' in response.get_data()
> > > True

```
- - - -

为了更方便处理，并支持使用中文字符进行判断，我们可以将as_text参数设为True来获取解码为Unicode格式的响应主体，这时不必再添加b前缀：

- - - -



```

> > > # data = response.get_data(as_text=True)
> > >
> > > 'Say Hello' in data
> > > True

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20293.png)
提示

因为返回的内容包含完整的HTML响应，某些情况下你可以使用正则表达式来匹配其中被空格或HTML标签分隔的文本。

通过判断返回的数据是否包含标题Say Hello，我们就可以确认主页视图是否正常工作。类似地，我们调用post()方法发送POST请求：

- - - -



```

> > > response = client.post('/', data={'name': 'Grey Li', 'body': 'I am a test message.'}, follow_redirects=True)
> > > 'Your message have been sent to the world!' in response.get_data(as_text=True)
> > > True
> > > 'I am a test message.' in response.get_data(as_text=True)
> > > True

- - - -

除了URL，我们还将表单的数据以字典的形式通过data参数传入，表单字段的name值作为键，这里的name和body键分别对应表单的name和body字段。因为表单提交后会跳转到首页，将follow_redirects参数设为True可以跟随重定向，自动向重定向后的页面发起GET请求。通过判断返回的数据中是否包含通过flash()函数发送的提示消息和刚刚创建的消息内容，我们就可以判断发表问候的功能是否正常。

对于Web程序来说，大部分的测试都是这种模式，下面我们会介绍使用测试框架来更方便的编写和组织测试。


注意

上面的示例对程序做了改动。直接测试时，因为提交表单数据时没有加入CSRF令牌，所以会导致表单提交失败，表单下方显示错误提示“CSRF token is missing.”。下面我们会介绍如何在测试时通过设置配置变量来关闭CSRF保护。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 12.3  使用unittest编写单元测试

自动化测试最常见的形式是单元测试。单元测试（Unit Test）指的是对程序代码中最小的单元进行测试，比如Python函数或方法。

Python标准库内置了一个优秀的单元测试框架——unittest。本节我们将学习使用它来为程序编写单元测试。unittest包含下面几个重要的概念：

（1）测试用例（Test Case）

在unittest中，最小的测试单元被称为测试用例，它由继承unittest.TestCase的类表示。每个测试用例中包含多个测试方法。

（2）测试固件（Test Fixture）

测试固件指的是执行测试所需的前期准备工作和后期清理工作。比如创建临时的数据库，测试执行后清除数据库。测试用例可以创建setUp()和tearDown()方法，它们会分别在每一个测试方法被执行的前后执行，这两个方法分别用来初始化测试环境、清除测试环境。除了这两个方法，还有setUpClass()和tearDownClass()方法，这两个方法必须接收类本身作为唯一的参数，并且附加classmethod装饰器，它们会分别在整个测试用例执行的前后执行。

（3）测试集（Test Suite）

测试集是测试用例的集合，用来聚合所有测试以便执行。

（4）测试运行器（Test Runner）

测试运行器用来运行测试，收集测试结果，并呈现给用户。

#### 12.3.1  Flask程序的测试固件

在SayHello程序中，我们创建一个test_sayhello.py脚本来存储测试代码，unittest会自动识别test_*模式的文件，脚本中的测试固件如代码清单12-1所示。

代码清单12-1 test_sayhello.py：测试固件

- - - -



import unittest

from sayhello import app, db

class SayHelloTestCase(unittest.TestCase):

def setUp(self):
    app.config.update(
        TESTING=True,
        WTF_CSRF_ENABLED=False,
        SQLALCHEMY_DATABASE_URI='sqlite:///:memory:'
    )
    db.create_all()

def tearDown(self):
    db.session.remove()
    db.drop_all()



- - - -

对程序实例调用test_client()会获得一个Werkzeug提供的Client类的实例，我们在setUp()方法中将其保存为类属性self.client，以便在测试方法中使用它来发送模拟请求。

测试时通常使用不同的配置。在上面的setUp()方法中，我们使用config对象的update方法一次更新多个配置。其中，我们将TESTING配置键设为True，这会开启测试模式。在测试模式下，Flask会关闭在处理请求时的错误捕捉，从而获得更易读的错误报告。


提示

当TESTING配置变量的值为True时，Flask-DebugToolbar会自动将DEBUG_TB_ENABLED设为False以关闭调试工具栏，不用手动关闭。

在第4章我们说到过，Flask-WTF默认开启CSRF保护，但是测试时并不需要验证CSRF，开启CSRF保护会让发送POST提交表单数据变得困难，我们可以将配置变量WTF_CSRF_ENABLED设为False来关闭CSRF保护。

测试会对数据库进行修改，为了不影响之前的数据，测试时需要使用单独的数据库。我们在这里使用SQLite内存型数据库进行测试，这不用生成新的文件，而且会显著提高测试速度。当URI中的文件地址为空时（即sqlite：///）将默认使用内存型数据库，这也是SQLALCHEMY_DATABASE_URI配置键的默认值。但是这会显示一个警告信息，所以我们可以显式地指定为sqlite：///或sqlite：///：memory：。指定好URI后使用db.create_all()方法创建数据库和表。


提示

如果程序中使用了DBMS特定的代码，比如MySQL、Postgresql提供的功能，那么使用SQLite的内存型数据库会出错。

另外，Flask-SQLAlchemy为我们管理SQLAlchemy的数据库会话，在程序上下文被销毁时，它会调用db.session.remove()清除会话（通过注册teardown_appcontext回调函数实现），但是测试时并没有激活上下文，所以我们需要手动调用db.session.remove()以清除会话，最后调用db.drop_all()清除数据库。

在SayHello程序中，我们需要在测试中导入程序实例，并且更新大量的配置值。而在其他程序实例中，我们均使用工厂函数来创建程序实例，并使用Python类来组织配置，在这些程序的setUp方法中可以直接导入工厂函数，传入测试用的配置类名，从而创建一个专用于测试的程序实例。比如：

- - - -



class BaseTestCase(unittest.TestCase):

def setUp(self):
    app = create_app('testing')
    ...
def tearDown(self):
    ...



- - - -

#### 12.3.2  编写测试用例

代码清单12-2是我们为SayHello创建的两个基本测试，这两个测试方法分别测试程序实例是否存在、配置键TESTING是否为True。

代码清单12-2 test_sayhello.py：基本测试

- - - -



import unittest
from sayhello import app, db

class SayHelloTestCase(unittest.TestCase):

...
def test_app_exsit(self):
    self.assertFalse(app is None)

def test_app_is_testing(self):
    self.assertTrue(app.config['TESTING'])



- - - -


提示

测试方法由test_开头，测试运行器会自动把这类方法识别为测试并调用。

在每个测试方法中，我们需要使用unittest提供的多个断言（assert）方法来对各种情况进行验证，以判断程序的功能是否符合预期。这是每一个测试方法的关键，也是运行测试时判断测试是否通过的凭证。在代码清单12-2中，我们使用了assertFalse()方法和assertEqual()方法，包括这两个方法在内的常用的断言方法验证说明如表12-1所示。

表12-1 常用的断言方法



代码清单12-3是几个基于测试客户端编写的测试方法。

代码清单12-3 test_sayhello.py：使用测试客户端测试程序请求

- - - -



import unittest

from app import app, db

class SayHelloTestCase(unittest.TestCase):
    ...
    def test_404_page(self):   # 测试400错误页面
        response = self.client.get('/nothing')  # 访问一个未定义的URL
        data = response.get_data(as_text=True)
        self.assertIn('404 Error', data)
        self.assertIn('Go Back', data)
        self.assertEqual(response.status_code, 404)

def test_500_page(self):  # 测试500错误页面
    # 临时创建一个视图来生成500错误响应
​    @app.route('/500')
​    def internal_server_error_for_test():
​        abort(500)

​    response = self.client.get('/500')
​    data = response.get_data(as_text=True)
​    self.assertEqual(response.status_code, 500)
​    self.assertIn('500 Error', data)
​    self.assertIn('Go Back', data)

def test_index_page(self):  # 测试主页
    response = self.client.get('/')
    data = response.get_data(as_text=True)
    self.assertIn('Say Hello', data)

def test_create_message(self):  # 测试创建新消息
    response = self.client.post('/', data=dict(
        name='Peter',
        body='Hello, world.'
    ), follow_redirects=True)
    data = response.get_data(as_text=True)
    self.assertIn('Your message have been sent to the world!', data)
    self.assertIn('Hello, world.', data)

def test_form_validation(self):  # 测试表单验证
    response = self.client.post('/', data=dict(
        name=' ',  # 填入空格作为名称
        body='Hello, world.'
    ), follow_redirects=True)
    data = response.get_data(as_text=True)
    self.assertIn('This field is required.', data)



- - - -

在这几个测试中，test_index_page()测试主页，验证返回值中是否包含“Say Hello”字符；test_404_page()测试访问不存在的URL后是否返回404错误响应，并验证是否为自定义错误页面；test_500_page()测试500错误，为了返回500响应，我们临时创建了一个视图，在视图内调用abort()方法生成500响应。test_create_message()测试问候留言的创建，这个测试验证返回值中是否包含创建的留言和留言创建成功后的flash消息；最后的test_form_validation()测试表单验证是否正常工作，这个测试和test_create_message()很相似，不过提交表单时name字段的值为空格，这个测试验证返回值中是否包含表单的错误提示信息。

1.为测试创建上下文

在执行测试时是没有Flask上下文存在的，但是有一些行为又依赖于程序上下文或请求上下文才能正确进行。比如，Flask-SQLAlchemy中用来清除数据库会话的db.session.remove()调用通过teardown_appcontext装饰器注册，而这个函数只会在程序上下文销毁时才会触发。

另外，当使用工厂函数创建程序时，我们使用current_app来操作程序实例。事实上，除了我们程序中使用的代码，扩展的代码中也会使用current_app。比如，Flask-SQLAlchemy需要从程序实例获取配置信息。当直接创建程序实例，并在实例化SQLAlchemy类时传入程序实例时，Flask-SQLAlchemy会直接从这个程序实例app对象获取配置信息。但当使用工厂函数创建程序并使用init_app()初始化程序后，Flask-SQLAlchemy则会从current_app对象来获取对应程序的配置信息。

我们在第2章介绍过，current_app变量只有在程序上下文被激活后才可以使用。在使用工厂函数的程序中，为了能让我们的数据库表顺利进行创建，我们需要手动激活上下文。我们在第2章介绍过Flask提供的app_context()和test_request_context()方法来手动激活上下文：

- - - -



with app.app_context():
    db.create_all()

- - - -

除了使用with语句，我们也可以对这两个方法返回的上下文对象调用push()方法显式地推送上下文。这时需要在setUp()方法中使用push()方法推送上下文。相应地，在tearDown()方法中，我们需要调用pop()方法删除上下文。在push()方法调用后，在pop()方法调用前，我们可以执行一系列依赖于上下文的操作：

- - - -



from bluelog import create_app

class BaseTestCase(unittest.TestCase):

def setUp(self):
    app = create_app('testing')
    self.context = app.test_request_context()  # 创建上下文对象
    self.context.push()  # 推送上下文
    self.client = app.test_client()
    db.create_all()

def tearDown(self):
   db.drop_all()
   self.context.pop()  # 销毁上下文



- - - -


提示

（1）因为我们经常需要在测试方法中使用url_for()函数来构建URL，所以必须在setUp()方法中推送请求上下文，通过app.test_requeset_context()方法获取测试用的请求上下文对象。因为请求上下文被推送时，程序上下文也会一同被推送，所以我们也可以顺利执行依赖于current_app的操作，比如db.create_all()。如果你不需要在测试方法中使用url_for()，那么推送程序上下文（app.app_context()）即可。

（2）当显式地推送上下文后，我们不用再手动调用db.session.remove()清除数据库会话。

使用test_request_context()方法只能构建一个全局的请求上下文环境，对应的URL默认为根地址，你可以将自定义路径作为第一个参数（path）传入。如果你想使用特定请求的request、session等请求上下文全局变量，可以使用with语句来调用test_client()，这会在with语句结束前创建一个测试用的请求上下文，对应当前请求，比如：

- - - -



> > > with app.test_client() as client:
> > > ...     client.get('/hello')
> > > ...     request.endpoint
> > > ...     request.url
> > > ...
> > > <Response streamed [200 OK]>
> > > 'hello'
> > > u'http://localhost/hello'

- - - -


提示

虽然在使用test_client()发起请求时会附带激活和销毁请求上下文，从而调用Flask-SQLAlchemy注册的db.session.remove()调用，但是为了确保每一个测试方法执行后都清除了数据库会话，我们仍然需要手动调用，除非是使用前面介绍的方法显式推送了上下文。

2.测试Web API

在第10章我们介绍了使用HTTPie测试Web API，除了手动测试外，我们还需要为Web API编写单元测试。因为资源端点接收JSON格式的数据，在使用Flask提供的测试客户端发起模拟请求时，我们使用json关键字传入一个表示JSON数据的字典：

- - - -



> > > client = app.test_client()
> > > response = client.post('/api/items', json={
> > >      'title': 'hello', 'body': 'world'
> > >  })
> > > json_data = response.get_json()  # 获取JSON格式响应
> > > json_data['message']
> > > 'Item Created!'

- - - -

对返回的响应对象调用get_json()方法可以获取返回的JSON数据，这些数据会被解析为字典，所以我们可以自由操作返回的JSON数据。在Todoism中，测试Web API的tests/test_api.py脚本中就大量使用这种方式来进行测试。我们先来看看这个脚本中的两个辅助方法：

- - - -



import unittest
from flask import url_for
from todoism import create_app, db
from todoism.models import User

class APITestCase(unittest.TestCase):

def setUp(self):
    ...
    user = User(username='grey')  # 创建用于测试的用户记录
    user.set_password('123')
    db.session.add(user)
    db.session.commit()
...
def get_oauth_token(self):  # 获取认证令牌
    response = self.client.post(url_for('api_v1.token'), data=dict(
        grant_type='password',
        username='grey',
        password='123'
    ))
    data = response.get_json()
    return data['access_token']

def set_auth_headers(self, token):  # 设置认证首部
    return {
        'Authorization': 'Bearer ' + token,
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }



- - - -

为了方便测试时操作资源，我们在setUp()方法中在数据库里创建一个测试的用户记录。在测试方法中发送请求时，我们需要进行OAuth认证。认证过程中的获取令牌和将令牌加入请求首部的操作分别使用get_oauth_token()方法和set_auth_headers()方法实现，前者向认证令牌端点发送POST请求，使用data参数（作为表单数据）传入必要的认证信息，返回access令牌；后者接收令牌值作为参数，返回一个包含必要字段的首部字典。代码清单12-4是基于这两个方法实现的几个测试方法，你可以到源码仓库查看所有的测试。

代码清单12-4 tests/test_api.py：测试Web API

- - - -



class APITestCase(unittest.TestCase):
    ...
    def test_api_index(self):  # 测试API首页
        response = self.client.get(url_for('api_v1.index'))
        data = response.get_json()
        self.assertEqual(data['api_version'], '1.0')

def test_get_token(self):  # 测试获取认证令牌
    response = self.client.post(url_for('api_v1.token'), data=dict(
        grant_type='password',
        username='grey',
        password='123'
    ))
    data = response.get_json()
    self.assertEqual(response.status_code, 200)
    self.assertIn('access_token', data)

def test_get_user(self):  # 测试获取用户资源
    token = self.get_oauth_token()  # 获取认证令牌
    response = self.client.get(url_for('api_v1.user'),
                               headers=self.set_auth_headers(token))
    data = response.get_json()
    self.assertEqual(response.status_code, 200)
    self.assertEqual(data['username'], 'grey')

def test_new_item(self):  # 测试添加新条目
    token = self.get_oauth_token()
    response = self.client.post(url_for('api_v1.items'),
                                json=dict(body='Buy milk'),
                                headers=self.set_auth_headers(token))
    data = response.get_json()
    self.assertEqual(response.status_code, 201)
    self.assertEqual(data['body'], 'Buy milk')



- - - -

test_api_index()方法测试API首页，因为首页资源不需要认证，所以可以直接发起GET请求，判断返回值是否包含api_version和对应的值。

test_get_token()和用于获取access令牌的辅助方法内容基本相同，我们最后判断响应的状态码是否为200，返回数据中是否包含access_token键。

test_get_user()测试获取用户端点资源，我们首先调用get_oauth_token()获取access令牌，然后在发起GET请求的get()方法中通过headers参数传入首部字段，参数的值通过set_auth_headers（token）方法获取。

test_new_item()用来测试创建新条目，发起请求的方式和test_get_user()类似，获取响应后，我们判断状态码是否为201，返回的JOSN数据中body键是否为发送请求时传入的值。

3.测试flask命令

对于flask命令，Flask提供了app.test_cli_runner()方法用于在测试中调用命令函数、捕捉输出。对于使用包的测试，你可以创建一个test_cli.py模块存储测试命令的代码，在SayHello的测试模块test_sayhello.py中，我们为生成虚拟数据的forge命令创建了两个测试，如代码清单12-5所示。

代码清单12-5 test_sayhello.py：测试forge命令

- - - -



import unittest

from sayhello import app, db
from sayhello.models import Message
from sayhello.commands import forge

class SayHelloTestCase(unittest.TestCase):
    ...
    def setUp():
        …
        self.runner = app.test_cli_runner()

# 测试forge命令

​    def test_forge_command(self):
​        result = self.runner.invoke(forge)  # 触发对应的命令函数
​        self.assertIn('Created 20 fake messages.', result.output)
​        self.assertEqual(Message.query.count(), 20)

# 测试添加--count选项的forge命令
def test_forge_command_with_count(self):
    result = self.runner.invoke(forge, ['--count', '50'])
    self.assertIn('Created 50 fake messages.', result.output)
    self.assertEqual(Message.query.count(), 50)

# 测试initdb命令
def test_initdb_command(self):
    result = self.runner.invoke(initdb)
    self.assertIn('Initialized database.', result.output)

# 测试添加--drop选项的initdb命令
def test_initdb_command_with_drop(self):
    result = self.runner.invoke(initdb, ['--drop'], input='y\n')
    self.assertIn('This operation will delete the database, do you want to continue?', result.output)
    self.assertIn('Drop tables.', result.output)



```
- - - -

第一个测试用来测试生成虚拟数据是否正常，我们首先对程序实例app调用test_cli_runner()，它会返回一个FlaskCliRunner对象，我们使用它提供的invoke()方法调用命令，传入命令函数对象作为第一个参数。invoke()调用会返回一个包含命令执行结果的Result对象，其中的output属性包含命令的输出内容。通过判断命令的输出字符和数据库的记录数量，我们就可以判断这个功能是否正常。

第二个测试用来测试自定义生成虚拟消息的数量是否正常，我们同样使用invoke()方法调用命令，传入了第二个参数指定在命令后附加的参数列表。同样，通过判断命令的输出字符和数据库的记录数量，我们就可以判断这个功能是否正常。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20299.png)
提示

顺便说一句，你也可以在invoke()方法中通过参数列表（args关键字）中给出完整的命令，不用传入命令函数对象，比如：invoke（args=['forge'，'--count'，'10']）。

最后两个测试基本相同，唯一需要提及的是最后一个测试，用于重新生成数据库的initdb命令在使用--drop选项后，会给出确认提示，我们需要在invoke()方法中使用input参数给出输入值，即：

- - - -



```

result = runner.invoke(initdb, ['--drop'], input='y\n')

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20300.png)
提示

更多用法可以访问 [http://flask.pocoo.org/docs/1.0/testing/#testing-cli-commands](http://flask.pocoo.org/docs/1.0/testing/#testing-cli-commands) 了解。 

#### 12.3.3  组织测试

通常，我们会为每个模块创建对应的测试。如果程序比较简单，比如我们的SayHello程序，那么可以仅创建一个脚本来存储测试代码。测试脚本的命名规则为test_*，比如test_sayhello.py。

在Bluelog等更大的程序中，随着程序变大，测试也变多了。为了更好地组织测试，我们创建一个tests包来分模块组织测试代码，测试被按照类别分为test_basic.py、test_auth.py、test_blog.py、test_admin.py等多个模块。你可以根据蓝本来组织测试，每一个蓝本对应一个模块；也可以根据程序的主要功能区分来进行组织，比如数据库模型（test_models.py）、用户认证（test_auth.py）、命令（test_commands.py）等。

当使用包组织组织测试时，不同的测试模块常常需要类似的测试固件。在unittest中，我们可以创建一个基本测试用例，在其他模块中直接导入并继承这个测试用例。在Bluelog程序中，我们创建了4个测试模块，分别测试程序基础、用户认证、博客功能和后台管理。这些测试用例都需要实现基本相同的setUp()和tearDow()方法。为了避免大量重复，我们在base.py中创建了一个基本测试用例，其中包含了这两个方法和一些通用的辅助函数，如代码清单12-6所示。

代码清单12-6 tests/base.py：基本测试用例

- - - -



```

import unittest

from flask import current_app, url_for

from bluelog import create_app
from bluelog.extensions import db
from bluelog.models import User

class BaseTestCase(unittest.TestCase):

```
def setUp(self):
    app = create_app('testing')
    self.context = app.test_request_context()
    self.context.push()
    self.client = app.test_client()
    self.runner = app.test_cli_runner()

    db.create_all()
    user = Admin(name='Grey Li', username='grey', about = 'I am test', blog_title = 'Testlog', blog_sub_title = 'a test')  # 创建测试用户记录
    user.set_password('123')
    db.session.add(user)
    db.session.commit()

def tearDown(self):
    db.drop_all()
    self.context.pop()


```

```
- - - -

我们用来测试博客后台管理功能的测试用例需要在管理员权限下进行操作，所以我们还在setUp()方法中创建了一个管理员用户。另外，为了方便在其他测试用例中模拟客户端测试，我们还在基本测试用例中创建了用于登录和注销管理员用户的login()和logout()方法，如代码清单12-7所示。

代码清单12-7 bluelog/tests/base.py：登录和注销登录

- - - -



```

import unittest
from flask import current_app, url_for
from bluelog import create_app
from bluelog.extensions import db
from bluelog.models import Admin

class BaseTestCase(unittest.TestCase):

```
...
def login(self, username=None, password=None):
    if username is None and password is None:
        username = 'grey'
        password = '123'

    return self.client.post(url_for('auth.login'), data=dict(
        username=username,
        password=password
    ), follow_redirects=True)

def logout(self):
    return self.client.get(url_for('auth.logout'), follow_redirects=True)


```

```
- - - -

#### 12.3.4  运行测试

我们需要运行测试一遍查看哪些测试没有通过，然后就可以尝试更新相应的代码。有很多种方式来运行unittest测试，你可以选择你最喜欢的方式。

1.unittest.main()

对于存储在单脚本的测试来说，最方便的是在测试模块中调用unittest.main()方法，在测试脚本底部添加下面的代码：

- - - -



```

...
if name == 'main':
    unittest.main()

```
- - - -

然后在命令行界面使用Python执行测试脚本：

- - - -



```

$ python test_sayhello.py

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20301.png)
提示

在命令后添加-v选项（verbose）可以获取更详细的测试输出信息。

2.自动发现测试

在Python2.7版本中，unittest支持自动发现测试，我们可以使用下面的命令运行测试：

- - - -



```

$ python -m unittest discover -v

```
- - - -

unittest默认会从当前目录开始寻找以test_*.py模式命名的模块，然后运行其中的测试。你可以通过其他可用的选项来定义自动发现行为，具体可以访问unittest文档（ [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.xhtml) ）查看。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20302.png)
提示

在命令后添加-v选项可以获取更详细的测试输出信息。

3.通过setuptools运行测试

通过在项目setup.py文件中把setup()函数中的test_suite参数设为包含测试的模块名称或包名称（比如test_sayhello或tests），我们也可以使用下面的命令来执行单元测试：

- - - -



```

$ python setup.py test

```
- - - -

它会首先对程序打包安装，然后执行测试。关于打包构建的具体内容我们将在第15章学习。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20303.png)
提示

使用-q选项（quite）可以简略测试输出信息。

4.编写Flask测试命令

我们也可以编写一个自定义的Flask命令来运行测试，如下所示：

- - - -



```

import unittest
import click
from myapp import app

@app.cli.command()
def test():
    """Run unit tests."""
    test_suite = unittest.TestLoader().discover('tests')
    unittest.TextTestRunner(verbosity=2).run(test_suite)

```
- - - -

这部分代码实际上正是python-m unittest discover命令背后调用的代码。在这个test()命令函数中，我们使用TestLoader()加载测试集，在discover()方法中传入测试所在的开始路径，比如test_sayhello或tests。然后我们使用TextTestRunner()运行测试，verbosity参数控制测试输出信息的详细程度，默认为1。

创建这个命令函数后，使用flask test命令即可运行测试：

- - - -



```

$ flask test

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20304.png)
提示

因为这种方式需要首先触发Flask的命令行系统，可能会导致一些潜在的Bug，因此不推荐使用这种方式来运行测试。

这里只是对unittest的简单介绍，你可以访问Python官方文档unittest部分（ [https://docs.python.org/2/library/unittest.html](https://docs.python.org/2/library/unittest.xhtml) ），了解unittest的更多用法。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20184.png)
附注

除了使用unittest，Python还内置了一个doctest模块，它允许你通过在文档字符串中以交互式Python示例的形式编写测试。另外，你也可以尝试使用第三方测试框架，比如nose（ [https://github.com/nose-devs/nose](https://github.com/nose-devs/nose) ）和pytest（ [http://pytest.org/](http://pytest.org/) ）。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 12.4  使用Selenium进行用户界面测试

Flask内置的测试客户端只是用来测试视图函数是否正常工作，但实际的用户界面也需要进行测试。以SayHello为例，虽然我们在单元测试中使用模拟测试客户端可以正确创建问候消息，但是如果页面中表单的提交按钮没有正确渲染，那么程序仍然不能正常使用。

尤其是对于包含较多JavaScript代码的程序，仅仅编写单元测试是不够的，我们需要能实际测试页面加载JavaScript后的实际交互功能。要解决这些问题，我们需要使用一种新的测试形式——用户界面（User Interface，UI）测试。

虽然我们直接在浏览器中使用程序可以算得上是用户界面测试，但人工进行测试太耗费时间，而且容易出错。如果能把我们手动操作浏览器进行测试的行为转换为可以复用的代码，然后自动执行代码来进行测试，就能完美解决这类问题，我们本节要介绍的Selenium就是这类自动化工具。

并不是所有的功能都需要进行用户界面测试，通常需要着重关注的是比较关键的功能，或是较多依赖于JavaScript代码的功能，这里将以待办事项程序Todoism作为示例。

Selenium让我们可以使用Python代码来操控浏览器：填写表单、单击按钮、获取页面内容等各种功能都可以通过代码来实现。我们首先使用Pipenv安装Selenium的Python接口：

- - - -



```

$ pipenv install selenium --dev

```
- - - -

#### 12.4.1  安装浏览器与驱动

因为测试需要使用真正的浏览器，我们得先确保用来测试的浏览器已经安装完毕。为了确保正常运行测试，请尝试更新浏览器为最新版本。另外还要安装的是浏览器相应的Web驱动接口程序，即WebDriver（ [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/) ），Selenium会借助它用来与浏览器进行交互操作，几个主流浏览器的Web驱动的下载地址如表12-2所示。 

表12-2 主流浏览器的Web驱动下载地址

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEUQIkAAAAABt9f7w822564457.jpg)

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20185.png)
附注

其他浏览器Web驱动的下载地址可以在Selenium网站的下载页面（ [http://www.seleniumhq.org/download/](http://www.seleniumhq.org/download/) ）看到。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20113.png)
注意

下载驱动程序后，我们还要把驱动程序的路径添加到系统的PATH环境变量中。这样Selenium才能执行对应的驱动程序。最简单的方式是把驱动程序放到Python解释器所在的目录下。

在示例程序中，我们将使用Firefox进行测试，所以确保你安装了最新版本的Firefox和最新版本的驱动。在进行测试时，会自动打开一个浏览器窗口，然后按照脚本的代码来执行操作，就像是有真人在控制一样。下面的交互式代码片段演示了Selenium的一些基本用法：

- - - -



```

> > > from selenium import webdriver  # 导入驱动对象
> > > from selenium.webdriver.common.keys import Keys  # 导入按键对象
> > > driver = webdriver.Firefox()  # 加载驱动程序，如果使用Chrome，则调用webdriver.Chrome()
> > > driver.get('https://pypi.org')  # 访问对应的URL
> > > elem = driver.find_element_by_name('q')  # 定位搜索输入框元素（name为q）
> > > elem.click()  # 单击输入框
> > > elem.send_keys('Flask')  # 输入字符
> > > elem.send_keys(Keys.RETURN)  # 按下Enter键
> > > 'A simple framework for building complex web applications.' in driver.page_source
> > >
> > > # driver.page_source可以获取页面源码
> > >
> > > True
> > > elem = driver.find_element_by_link_text('Flask')  # 定位Flask项目链接
> > > elem.click()  # 单击链接
> > > 'Project Description' in driver.page_source
> > > True
> > > driver.get_screenshot_as_file('main-page.png')  # 截屏保存图片
> > > driver.quit()  # 退出驱动程序

```
- - - -

Selenium提供了多种方式来定位元素，比如find_element_by_id()可以通过元素id来定位，而find_element_by_class()可以通过元素的class来定位，具体可以访问官方文档（ [https://seleniumhq.github.io/selenium/docs/api/py/index.html](https://seleniumhq.github.io/selenium/docs/api/py/index.xhtml) ）或是另一个由贡献者维护的非官方文档（ [http://selenium-python.readthedocs.io/](http://selenium-python.readthedocs.io/) ）查看。 

#### 12.4.2  准备测试环境

因为要操控浏览器，所以我们需要让程序运行在真实的服务器中。要在测试的同时运行开发服务器，通常有下面这些方法：

1）最直接的做法是新建一个脚本，创建一个app实例，并为测试做一些基础操作（初始化数据库等），然后在单独的命令行窗口启动服务器，再在新的命令行窗口运行测试。测试完成后，手动关闭服务器。

2）另一种更优雅的方法是直接在测试中通过新建后台线程来运行Flask开发服务器。测试完成后，通过Werkzeug提供的接口来关闭服务器，不过这种实现稍显复杂。

3）最后，使用扩展也可以完成这个任务，Flask-Testing（ [https://github.com/jarus/flask-testing](https://github.com/jarus/flask-testing) ）提供了一些测试辅助功能，其中就提供了一个集成unittest.TestCase类的LiveServerTestCase类，继承这个类的测试用例在执行测试方法前（setup）会自动启动一个开发服务器，在测试方法执行后自动关闭（teardown），类似Django中的LiveServerTestCase。遗憾的是，目前这个类无法在Windows上正常使用。 

基于这些考虑，我们将采用第一种方式，首先在项目根目录创建一个test_app.py脚本，存储一个加载测试配置的程序实例，如代码清单12-8所示。

代码清单12-8 test_app.py：测试用的程序实例

- - - -



```

from todoism import create_app, db
from todoism.models import User, Item

app = create_app('testing')

with app.app_context():
    db.create_all()

```
user = User(username='grey')
user.set_password('123')
db.session.add(user)

item1 = Item(body='test item 1')
item2 = Item(body='test item 2')
item3 = Item(body='test item 3')
user.items = [item1, item2, item3]

db.session.commit()


```

```
- - - -

在创建程序实例后，我们创建用于测试的用户记录和三个待办事项记录。现在可以在新打开的命令行窗口中运行它：

- - - -



```

You can't use 'macro parameter character #' in math mode export FLASK_APP=test_app.py  # Windows下使用set
 flask run

```
- - - -

接着，我们来编写单元测试。首先在Todoism项目根目录下的tests包内创建一个新脚本test_ui.py，然后创建一个UserInterfaceTestCase测试用例，并编写测试固件，如代码清单12-9所示。

代码清单12-9 tests/test_ui.py：用户界面测试

- - - -



```

class UserInterfaceTestCase(unittest.TestCase):

```
def setUp(self):
    os.environ['MOZ_HEADLESS'] = '1'  # 开启headless模式
    self.client = webdriver.Firefox()

    if not self.client:
        self.skipTest('Web browser not available.')

def tearDown(self):
    if self.client:
        self.client.quit()


```

```
- - - -

在setUp()方法中，我们首先与浏览器驱动建立连接，创建一个客户端对象self.client。通过将MOZ_HEADLESS环境变量设为1，可以开启Firefox的headless模式。目前最新版本的Chrome和Firefox均支持Headless选项，可以不用弹出图形窗口，直接在后台执行所有操作。除了设置MOZ_HEADLESS环境变量，你也可以通过下面的方式设置：

- - - -



```

options = webdriver.FirefoxOptions()
options.add_argument('headless')
self.client = webdriver.Firefox(options=options)

```
- - - -

如果你使用Chrome，那么实现方式类似：

- - - -



```

options = webdriver.ChromeOptions()
options.add_argument('headless')
self.client = webdriver.Chrome(options=options)

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20305.png)
提示

headless浏览器即没有图形界面的浏览器，还有很多纯headless浏览器，比如Phantom-JS、HtmlUnit、Splash等。

如果建立连接失败，我们就使用skipTest()方法跳过测试。对应地，在tearDown()方法中，我们使用quit()退出浏览器驱动。

#### 12.4.3  编写测试代码

在使用Selenium编写测试时，我们要考虑到下面的问题：

1）元素遮挡问题：和我们手动操作相同，如果页面上的某个元素被另一个元素遮挡了，那么我们无法使用Selenium单击它。

2）元素引用失效：当我们把指向某个元素的引用保存在Python变量中时，这个变量仅仅在当前页面可用。如果你这时跳转到新的页面，那么指向旧页面的引用也会随之失效。

3）页面加载时间：和手动操作类似，页面加载需要时间。如果某个操作需要耗费较长的时间，那么你同时需要使用time.sleep()来休眠程序进行等待，否则相应的操作可能会无法执行。

下面是使用Selenium编写的四个测试方法，分别对应三个操作场景：显示主页、用户登录、添加新条目和删除新条目，如代码清单12-10所示，你可以在源码仓库中查看所有的测试方法。

代码清单12-10 tests/test_ui.py：用户界面测试

- - - -



```

from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains

class UserInterfaceTestCase(unittest.TestCase):
    ...
    def login(self):  # 用于登录程序的辅助方法，非测试
        self.client.get('http://localhost:5000')  # 访问主页
        time.sleep(2)  # 等待页面加载

# 访问登录页面

​        self.client.find_element_by_link_text('Get Started').click()
​        time.sleep(1)

# 输入用户名

​        self.client.find_element_by_name('username').send_keys('grey')

# 输入密码

​        self.client.find_element_by_name('password').send_keys('123')

# 单击登录按钮

​        self.client.find_element_by_id('login-btn').click()
​        time.sleep(1)

```
def test_index(self):  # 测试主页
    self.client.get('http://localhost:5000')
    time.sleep(2)
    self.assertIn('Todoism makes everything clear.', self.client.page_source)

def test_login(self):  # 测试登录
    self.login()
    self.assertIn('What needs to be done?', self.client.page_source)

def test_new_item(self):  # 测试创建新条目
    self.login()
    # 定位页面中的条目计数
    all_item_count = self.client.find_element_by_id('all-count')
    # 获取全部条目的数量值
    before_count = int(all_item_count.text)
    # 定位输入按钮
    item_input = self.client.find_element_by_id('item-input')
    # 输入文本Hello, World
    item_input.send_keys('Hello, World')
    # 按下按钮
    item_input.send_keys(Keys.RETURN)
    time.sleep(1)
    # 再次获取全部条目的数量
    after_count = int(all_item_count.text)
    # 确保新创建的条目在页面中
    self.assertIn('Hello, World', self.client.page_source)
    # 确保全部条目计数增加1
    self.assertEqual(after_count, before_count + 1)

def test_delete_item(self):
    self.login()
    all_item_count = self.client.find_element_by_id('all-count')
    before_count = int(all_item_count.text)
    # 定位页面中的第一个条目，通过XPath来根据元素文本定位
    item1 = self.client.find_element_by_xpath("//span[text()='test item 1']")
    # 通过ActionChains.move_to_element()方法来执行 悬停操作
    hover_item1 = ActionChains(self.client).move_to_element(item1)
    hover_item1.perform()  # 执行操作
    # 定位悬停后出现的删除按钮，并单击
    delete_button = self.client.find_element_by_class_name('delete-btn')
    delete_button.click()
    # 再次获取条目计数，验证被删除条目不存在，条目计数减1
    after_count = int(all_item_count.text)
    self.assertNotIn('test item 1', self.client.page_source)
    self.assertIn('test item 2', self.client.page_source)
    self.assertEqual(after_count, before_count - 1)


```

```
这部分测试本身自描述性很强，必要的操作说明都通过注释描述过了，这里不再赘述。我们把登录操作的代码放到login()方法中，以便在其他方法中可以直接调用这个方法来执行登录操作，login()方法中的调用使用了“链式调用”来简化代码。在单击新的按钮后，我们使用time.sleep()来等待页面加载。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20186.png)
附注

（1）在测试删除元素的方法中，我们使用find_element_by_xpath()方法来通过XPath（XML Path Language）或根据元素的文本来定位元素，你可以访问 [https://www.w3.org/TR/xpath/all/](https://www.w3.org/TR/xpath/all/) 了解关于XPath的更多信息。 

（2）对于鼠标单击、移动、悬停、拖拽等底层操作，Selenium提供了ActionChains类，具体可以访问API文档（ [https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.action_chains.html](https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.action_chains.xhtml) ）了解。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 12.5  使用Coverage.py计算测试覆盖率

对于测试的质量，有一个重要的考虑指标——测试覆盖率（test coverage）。测试覆盖率是指测试覆盖的代码占全部代码行数的百分比。通常情况下，覆盖率应该越高越好，100%的测试覆盖率是理想目标，但有些时候并不是那么容易实现。对于大多数项目来说，应该尽量将测试覆盖率保持在90%左右。

Coverage.py是一个使用Python编写的检查代码覆盖率的工具，我们可以使用它来检查测试覆盖率，首先使用Pipenv安装它：

- - - -


```

$ pipenv install coverage --dev

```
- - - -

#### 12.5.1  基本用法

Coverage.py提供了命令行支持，使用起来非常简单。为了演示Coverage.py的用法，我们先使用一个简单的Python脚本来演示一下用法。下面这个脚本包含三个简单的函数，分别对传入的参数执行加、减、乘操作，脚本最后调用了其中的add()函数：

- - - -



```

def add(a, b):
    return a + b

 def subtract(a, b):
    return a - b

 def multiply(a, b):
    return a * b

add(2, 3)

```
- - - -

coverage run命令用来执行脚本并计算代码执行覆盖率，命令后要附加脚本文件名作为执行的目标：

- - - -


```

$ coverage run maths.py

```
- - - -

这会在脚本所在目录生成一个.coverage文件，其中包含了运行的结果数据。我们使用coverage report命令来输出覆盖率报告：

- - - -


```

$ coverage report

Name     Stmts  Miss  Cover

maths.py     7     2    71%

```
- - - -

通过报告我们可以看出这个脚本的代码执行情况：一共有7行代码，其中有两行没有被执行，覆盖率为71%。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20306.png)
提示

通过在coverage report命令后附加-m选项，可以在输出的报告中添加一列显示未执行的代码行数。

除了在命令行中输出覆盖率报告，我们还可以使用coverage html来查看HTML版本的覆盖率报告：

- - - -


```

$ coverage html

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20187.png)
附注

类似地，使用coverage xml命令可以输出XML格式的覆盖率报告。

这会在脚本所在目录生成一个htmlcov文件夹，使用浏览器打开其中的index.html文件可以看到HTML格式的覆盖率报告主页，如图12-2所示。

单击对应的脚本，我们还可以查看使用颜色标出代码执行的具体覆盖情况，如图12-3所示。

最后，我们可以使用erase命令来清除生成的覆盖率数据（仅清除.coverage文件）：

- - - -


```

$ coverage erase

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEVMWoAAAAANWlHdM388333043.jpg)
图12-2 HTML测试覆盖率报告

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEIkaxAAAAAHvnp7o762998447.jpg)
图12-3 测试覆盖具体情况

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20188.png)
附注

你可以访问Coverage.py文档（ [https://coverage.readthedocs.io](https://coverage.readthedocs.io) ）或执行coverage help命令来查看更多用法。 

#### 12.5.2  获取测试覆盖率

我们可以使用下面的命令在运行测试的同时开启覆盖率检查，这样就可以获取测试覆盖率：

- - - -



```

$ coverage run --source=sayhello --branch -m unittest discover

```
- - - -

这里传入--source选项指定要检查的包或模块为sayhello，如果测试保存在单脚本中，只需写出脚本名称。可选的--branch选项用来开启分支覆盖检查，比如，这会将if判断中未执行到的elif或else子句也视为未覆盖。

如果你不想在每次测试时手动输入这些选项，可以创建一个.coveragerc文件来存储配置，添加一个run节来为run命令定义配置。比如：

- - - -


```

[run]
source = sayhello
branch = true

```
- - - -

现在要测试sayhello包的覆盖率，只需要执行coverage run-m unittest discover即可。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20189.png)
附注

这个配置文件使用INI风格语法：每一个节（section）使用[foo]形式定义，其中每一行为键值对形式的参数（name=value），注释使用#或；开头。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20190.png)
附注

你可以访问Coverage.py文档的配置部分（ [https://coverage.readthedocs.io/en/coverage-4.5.1/config.html](https://coverage.readthedocs.io/en/coverage-4.5.1/config.xhtml) ）查看所有可用的命令与选项。 

现在使用coverage report或coverage html命令来输出报告，SayHello程序的HTML格式的覆盖率报告如图12-4所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEIvKkAAAAAL2tcZM948671115.jpg)
图12-4 Bluelog测试覆盖率报告

因为程序比较简单，我们的测试覆盖率可以达到100%，但随着程序变得更大更复杂，测试覆盖率要想达到100%会变得越来越困难。在报告中我们可以看到各个模块的覆盖率，而通过HTML版本的报告，我们甚至可以直观地看到哪些代码没有被执行，这样就可以有针对性地加强测试。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20191.png)
附注

使用coverage可以在本地生成覆盖率报告。为了便于协作和管理覆盖率数据，我们可以使用Coveralls（ [https://coveralls.io/](https://coveralls.io/) ）或Codecov（ [https://codecov.io/](https://codecov.io/) ）来生成在线分析。两者均对开源项目免费，并提供相应的Python库，对持续集成系统以及GitHub集成非常方便。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 12.6  使用Flake8检查代码质量

除了保证代码正确，我们还应该考虑代码的质量。代码质量良好，或者说优美的代码更易于维护和二次开发。如果是开源项目，那么编写优美的代码能够吸引其他人来贡献代码，清晰良好的结构、适当的注释都能让其他人更容易理解代码。

从理念上，我们应该遵循“Python之禅”：

- - - -


```

> > > import this

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20192.png)
附注

《Zen of Python》常被译为《Python之禅》，它是Python核心开发者Tim Peters撰写的影响Python设计的20个设计原则集合——实际上只有19个，最后一个作者称要留给Guido van Rossum（Python的创建者）来补充。它的具体定义在PEP 20（ [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/) ）中，你可以在Python Shell中使用import this语句查看。 

具体来说，我们应该遵循PEP 8（ [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/) ）中提出的代码约定。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20193.png)
附注

PEP（Python Enhancement Proposal，Python增强提案）是Python社区提供的Python设计文档，类似于RFC。具体介绍可以在PEP 1（ [https://www.python.org/dev/peps/pep-0001/](https://www.python.org/dev/peps/pep-0001/) ）中看到。完整的PEP索引在 [https://www.python.org/dev/peps/](https://www.python.org/dev/peps/) 。 

为了确保代码质量，我们需要借助静态检查工具。Python代码质量检查工具有很多，比如pycodestyle、Pyflake、Pylint、Flake8等，这里我们选用了Flake8（ [https://github.com/PyCQA/flake8](https://github.com/PyCQA/flake8) ）。Flake8是目前最流行的Python代码质量检查工具，它包装了Pyflakes、Pycodestyle（原pep8）和McCabe，并且提供了自定义插件支持。使用它可以检查代码是否符合PEP 8规范，是否包含语法错误或未使用的变量和导入，另外还可以检查代码的复杂度。首先使用Pipenv安装： 

- - - -



```

$ pipenv install flake8 --dev

```
- - - -

使用下面的命令即可对bluelog程序包进行检查：

- - - -



```

$ flake8 sayhello

```
- - - -

Flake8的输出的格式为“文件路径：行号：列号：错误码错误描述”，比如：

- - - -



```

sayhello__init__.py:18:1: E402 module level import not at top of file

```
- - - -

其中的错误码主要分类及含义如表12-3所示。

表12-3 常见的Flake8错误码

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEcn2tAAAAAEFK6us452963039.jpg)

Flake8支持定义配置，我们在项目根目录下创建一个.flake8文件，写入下面的配置：

- - - -



```

[flake8]
exclude = .git,migrations
max-line-length = 11

```
- - - -

exclude用来设置忽略检查的文件或目录，而max-line-length用来设置最长的行长度，默认的行长度为79，我们通常需要更长的行长度以增强代码的可读性。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20194.png)
附注

访问Flake8的文档（ [http://flake8.pycqa.org/en/latest/user/options.html](http://flake8.pycqa.org/en/latest/user/options.xhtml) ）查看所有可用的选项。 

发现了代码的问题后，我们该如何解决呢？我们可以使用autopep8（ [https://github.com/hhatto/autopep8](https://github.com/hhatto/autopep8) ）来自动处理pep8相关的错误，使用autoflake（ [https://github.com/myint/autoflake](https://github.com/myint/autoflake) ）来自动处理Pyflake相关的错误。当然，有些问题（比如复杂度）我们还需要手动处理。 

有时候，我们因为某些原因不得不违反这些代码规范的约束，为了不报错，我们可以选择忽略对某些代码的检查。要忽略某一行的代码检查，可以在这一行的后面添加注释“#noqa”，可以理解为No Quality Assurance：

- - - -



```

example = lambda: 'example' # noqa

```
- - - -

你还可以在注释后附加忽略检查的特定错误码，比如：

- - - -



```

example = lambda: 'example' # noqa: E731

```
- - - -

另外，在脚本中添加注释“#flake8：noqa”会忽略整个文件。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20307.png)
提示

用PyCharm时，我们可以使用快捷键Alt+Ctrl+Shift+L来按照PEP 8的约定重新整理代码。社区版的PyCharm仅支持对Python和HTML代码进行整理。

除了编码风格，代码质量还取决于代码的复杂度，过于复杂的代码不易于理解。Flake8内置了用于检查代码复杂度的McCabe。在使用flake8命令时，加入--max-complexity选项并附加最大复杂度的阈值，比如：

- - - -



```

$ flake8 --max-complexity 5 sayhello

```
- - - -

这个值也可以在配置文件中使用max-complexity=5定义，默认值为-1，即关闭复杂度检查，阈值需要大于0时才会弃用复杂度检查，具体的值可根据需要自行设置。一般来说，代码复杂度不应超过10。复杂度为1～5区间的代码比较容易理解，复杂度为6～10区间的代码稍微复杂。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20195.png)
附注

McCabe对代码复杂度的检查基于Thomas J.McCabe，Sr创建的软件度量单位——循环复杂度（cyclomatic complexity），具体可访问 [https://en.wikipedia.org/wiki/Cyclomatic_complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity) 了解。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 12.7  本章小结

除了本章介绍的测试外，还有很多测试形式，比如对部署后的程序进行Web压力（负载）测试，前端页面的浏览器兼容性测试，或是进行Web漏洞扫描等。这些超出了本书的主题范围，你可以阅读其他书籍进行学习。

对于多人协作开发和开源项目来说，我们可以为程序设置持续集成（Continuous Integration，CI）服务器来执行一系列测试，以便保证程序功能的正常迭代。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20196.png)
附注

持续集成是指个人开发的部分向项目整体部分交付，频繁进行集成以便更快地发现其中的错误的过程。对于多人参与的团队项目或是开源项目来说，需要一个持续集成服务器更高效地完成这些测试和集成工作。当有人向项目主分支推送代码后，会自动触发持续集成服务器执行单元测试、代码质量检查、测试覆盖率检查等步骤，如果这些测试都通过了，则说明构建成功，推送的代码可以被合并。如果你打算自己部署一个CI服务器，那么开源的Jenkins（ [https://jenkins.io/](https://jenkins.io/) ）、Buildbot（ [http://buildbot.net/](http://buildbot.net/) ）等都是不错的选择。另一方面，不用自己托管，云服务类型的CI服务越来越流行，比如Circle CI（ [https://circleci.com/](https://circleci.com/) ）、Travis CI（ [https://travis-ci.org/](https://travis-ci.org/) ）等，这些服务均对开源项目免费。 

测试可以确保程序正常工作，但是除了能正常工作，我们还应该关注程序的性能。程序的性能决定了处理请求的响应速度，而程序的响应速度则直接决定了用户是否会喜欢上你的程序。没人愿意使用响应缓慢的程序，下一章我们将学习程序性能优化的主要方式。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

## 第13章

## 性能优化

经过了各种测试，代码的正确性和质量都有了很大的保证。但是，工作还没有结束。虽然代码能够实现预期的效果，但在性能上未必是合格的。导致程序响应和加载缓慢的原因有很多，比如函数执行时间过长，数据库查询过慢或是模板中加载了太多JavaScript和CSS等静态文件。本章我们会尝试使用各种工具来对程序的性能进行分析，并借助其他扩展进行相应地优化。

程序的响应速度取决于很多因素，除了网络状况等外部因素外，我们可以从请求-响应处理流程中的下面几个环节来进行优化：

·函数执行

·数据库查询

·模板渲染

·页面资源加载

本章新涉及的Python库的版本与主页如下所示：

·Flask-Caching（1.4.0）

·主页： [https://github.com/sh4nks/flask-caching](https://github.com/sh4nks/flask-caching) 

·文档： [https://flask-caching.readthedocs.io/](https://flask-caching.readthedocs.io/) 

·redis-py（2.10.6）

·主页： [https://github.com/andymccurdy/redis-py](https://github.com/andymccurdy/redis-py) 

·文档： [http://redis-py.readthedocs.io](http://redis-py.readthedocs.io) 

·Flask-Assets（0.12）

·主页： [https://github.com/miracle2k/flask-assets](https://github.com/miracle2k/flask-assets) 

·文档： [https://flask-assets.readthedocs.io/](https://flask-assets.readthedocs.io/) 

·webassets（0.12.1）

·主页： [https://github.com/miracle2k/webassets](https://github.com/miracle2k/webassets) 

·文档： [https://webassets.readthedocs.io/](https://webassets.readthedocs.io/) 

·cssmin（0.2.0）

·主页： [https://github.com/zacharyvoase/cssmin](https://github.com/zacharyvoase/cssmin) 

·jsmin（2.2.2）

·主页： [https://github.com/tikitu/jsmin/](https://github.com/tikitu/jsmin/) 

因为使用这些工具时需要更改程序的代码，这会破坏示例程序的易读性，所以我们将使用单独的示例程序来介绍缓存和静态资源管理的内容。关于缓存和静态资源管理的两个示例程序分别存储在本书的项目仓库helloflask中的demos/cache和demos/assets目录下。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 13.1  程序性能分析

为了能够更有针对性地进行优化，我们需要对程序进行一些简单地分析。我们先来看看代码性分析，下一节则会了解数据库查询性能的分析。本节的性能分析将以Bluelog程序作为示例。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20308.png)
提示

如果你从GitHub上复制了Bluelog程序，可以执行git checkout profiling签出程序的新版本。

#### 13.1.1  函数性能分析

在第7章，我们曾介绍使用Flask-DebugToolbar来调试程序，其实它还内置了一个Profiler（性能分析器）。这个Profiler默认是关闭的，我们需要单击工具栏中Profiler选项右上方的对号按钮来激活它。激活后重新加载页面，打开性能分析页面，你会看到当前页面的加载时间，以及所有函数的调用情况，可以按照不同的信息来排序，如图13-1所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20197.png)
附注

Flask-DebugToolbar的性能分析功能使用cProfile库或profile库来实现，具体信息可以访问 [https://docs.python.org/2/library/profile.html](https://docs.python.org/2/library/profile.xhtml) 。 

对代码进行分析后，我们就可以知道哪些函数运行最慢。那么如何对这些函数进行优化呢？除了在代码层面上进行优化外，对于高CPU消耗函数和耗时较长的任务（比如发送邮件），我们通常会使用异步任务队列把它们放到后台处理，这样可以避免阻塞请求响应的处理。常用的Python任务队列有Celery（ [http://www.celeryproject.org/](http://www.celeryproject.org/) ）和更轻量的Redis-Queue（ [http://python-rq.org/](http://python-rq.org/) ）等，其中Celery还支持周期任务和定时任务。你可以通过阅读Celery的入门教程（ [http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html](http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.xhtml) ）学习。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20114.png)
注意

代码分析器需要监控程序的运行流程，所以会增大性能开销，因此最好不要在生产环境中进行代码分析。这也是为什么Flask-DebugToolbar默认把性能分析器设为关闭状态。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEBwGOAAAAAIW19uU920350380.jpg)
图13-1 Flask-DebugToolbar内置的
![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAWqEUPF2AAAAAH8GMTU927583229%202.png)

#### 13.1.2  数据库查询分析

在Flask-DebugToolbar提供的工具栏中，我们也可以通过SQLAlchemy面板查看到所有数据库查询花费的时间和查询的原生SQL语句。我们可以从中查找出占用时间过长的查询并对其进行优化。唯一的问题是，Flask-DebugToolbar只能在开发时使用，而开发时的服务器负载比较小，数据量也比较小，不能真实模拟生产环境的情况。因此，我们需要在生产环境下监控数据库查询情况，当发生缓慢查询时，记录到日志中或发送邮件通知，以便及时进行优化和处理。

记录数据库慢查询的最简单的方式是使用Flask-SQLAlchemy提供的get_debug_queries()函数。实际上，Flask-DebugToolbar的数据库查询记录功能就是基于Flask-SQLAlchemy完成的。当我们开启查询记录后，在每个请求结束时调用get_debug_queries()函数即可获得该请求所有数据库查询的信息，包括SQL语句、参数、时长等。

在调试模式或测试模式中，Flask-SQLAlchemy会自动开启查询记录。我们可以通过将配置变量SQLALCHEMY_RECORD_QUERIES设为True来显式地开启查询记录功能：

- - - -



```

SQLALCHEMY_RECORD_QUERIES = True

```
- - - -

因为查询信息必须在请求结束后获取，我们需要使用after_request装饰器注册一个请求处理函数，在这个函数中调用get_debug_queries()函数获取查询记录信息。代码清单13-1就是用于获取查询记录信息并分析慢查询的query_profiler()函数示例。

代码清单13-1 bluelog/__init__.py：分析查询记录，找出慢查询

- - - -



```

def create_app(config_name=None):
    ...
    register_request_handlers(app)

def register_request_handlers(app):
    @app.after_app_request
    def query_profiler(response):
      for q in get_debug_queries():
          if q.duration >= current_app.config['BLUELOG_SLOW_QUERY_THRESHOLD']:
            current_app.logger.warning(
                'Slow query: Duration: %fs\n Context: %s\nQuery: %s\n '
                % (q.duration, q.context, q.statement)
            )
      return response

```
- - - -

为了便于组织，我们在构造文件中创建一个register_request_handlers()函数并在工厂函数中调用，传入程序实例app。我们的慢查询过滤函数就在这个register_request_handlers()中创建。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20309.png)
提示

因为要记录所有请求的查询信息，如果你使用蓝本对象注册这个处理函数，那么需要使用after_app_request装饰器注册一个全局的请求后处理函数。

这个函数使用app.after_request装饰器注册一个请求后处理函数。请求后处理函数会在视图函数执行后被调用并传入生成的响应对象，以便需要对响应对象进行修改。在函数的结尾应该返回修改后的响应对象，或是原响应对象。

在这个函数中，我们使用for语句迭代get_debug_queries()函数来遍历所有查询记录信息，一个由包含查询记录信息的命名元组（named tuple）组成的列表，这个命名元素提供了表13-1中的属性来获取查询信息。

表13-1 查询信息元组包含的属性

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEK8lkAAAAAFjmSRs321916573.jpg)

既然要找出慢查询，我们就要设置一个合理的阈值（threshold），查询执行时长大于这个阈值就被视为慢查询。因为get_debug_queries()函数返回的时间单位为秒，我们也将使用秒作为单位。一般来说，一次合理的查询不应该超过1秒，所以我们把这个值设为1秒。为了便于修改，我们把这个值存储在配置变量BLUELOG_SLOW_QUERY_THRESHOLD中。

当查询的时长超过这个阈值时，我们就记录一条warning等级的日志，日志里加入这条查询的SQL语句、查询执行位置和持续时间，这三个值分别通过查询信息元组的statement、context以及duration属性获取，关于日志的详细内容我们将在第14章介绍。

当找出慢查询后，我们可以通过增加索引、优化数据库查询语句和表结构等方式对其进行优化。除了这些常规的数据库优化措施，我们还可以为程序设置缓存，具体我们将在下一节了解。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20310.png)
提示

为了便于开发，我们在几个程序实例中使用了SQLite。在实际生产环境下，尤其是对于大数据量、高并发访问、高流量的程序，你需要使用更健壮的DBMS，比如MySQL、PostgreSQL等，或是使用单独的数据库服务器来分离数据库读写操作。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 13.2  使用Flask-Caching设置缓存

顾名思义，缓存（cache）就是数据交换的缓冲区。计算机中的CPU需要执行计算时，会先在CPU高速缓存区查找是否有需要的数据，如果没有再到内存中寻找数据，并把找到的数据存储到高速缓存区，下次需要同一份数据时会直接从高速缓存区读取，这会大大提高CPU的计算效率。

在Web程序中，加速程序响应时间的最简单和有效的方法就是使用缓存。如果没有设置缓存，那么用户访问某个页面N次，服务器就要调用对应的视图函数N次。这就意味着会执行N次数据库查询、N次函数计算和N次模板渲染。如果我们在用户第一次访问时把调用视图函数的返回值缓存起来，那么用户后续的访问会直接使用缓存的数据，这样我们就不需要重复执行数据库查询、函数计算和模板渲染等工作。

在本节，我们介绍使用扩展Flask-Caching为程序添加缓存功能，对应的示例程序在helloflask/demos/cache目录下，确保当前工作目录在helloflask/demos/cache下并激活了虚拟环境，然后执行flask run命令运行程序：

- - - -


```

 cd cache
​ flask run

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20198.png)
附注

Flask-Caching是Flask-Cache扩展（ [https://github.com/thadeusb/flask-cache](https://github.com/thadeusb/flask-cache) ）的派生（fork），旨在替代缺乏维护的后者。 

我们首先使用Pipenv安装Flask-Caching及其依赖：

- - - -


```

$ pipenv install flask-caching

```
- - - -

然后导入并实例化Cache类创建一个cache对象，并传入程序实例作为参数以初始化扩展：

- - - -


```

from flask import Flask
from flask_caching import Cache

app = Flask(name)
cache = Cache(app)

```
- - - -

为了启用缓存，我们必须设置CACHE_TYPE配置变量，这个配置的值决定了使用哪种后端来存储缓存数据。常用的缓存后端类型值及其说明如表13-2所示。

表13-2 Flask-Caching中常用的缓存后端

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEUB7SAAAAAE5j4wg448961248.jpg)

默认情况下，这个值为null，也就是不使用缓存。在较小的程序中，我们可以使用simple或filesystem类型，前者会把缓存的数据直接存储到内存中的一个Python字典中，后者则存储到文件系统中；对于大型程序，你需要使用Redis、Memcached等性能更高的存储后端，我们会在后面进行介绍。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20311.png)
提示

有时你会想要同时使用不同类型的缓存后端，这时你可以创建多个Cache类对象，然后在Cache类的构造方法或是init_app()方法中使用config关键字传入一个包含配置键值的字典。

因为开发时经常需要对视图函数进行修改，所以不建议（也不需要）设置缓存，除非你想要测试缓存是否正常工作。当使用Python类组织配置时，你可以仅在生产环境下加载的配置类中设置CACHE_TYPE配置变量，而在开发时加载的配置类不设置CACHE_TYPE键，这会使用默认值null，即不启用缓存。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20312.png)
提示

当缓存类型为null时，Flask-Caching会在命令行输出提示信息，你可以通过将配置变量CACHE_NO_NULL_WARNING设为True来关闭警告信息。

#### 13.2.1  缓存视图函数

我们该为哪些视图函数设置缓存呢？一般来说，调用频繁，涉及大量数据库查询和计算任务的视图函数应该被优先考虑。需要注意的是，被缓存的数据应该是不经常变动的，至少在我们设置的缓存有效期内是固定不变的。

在示例程序的所有视图函数中，我们均使用time.sleep（1）函数来让程序休眠1秒，这用来模拟复杂计算耗费的时间。为了更方便判断其中的区别，我们先创建一个没有使用缓存的foo视图。

- - - -


```

@app.route('/foo')
def foo():
    time.sleep(1)
    return render_template('foo.html')

```
- - - -

为视图函数附加一个cache.cached()装饰器即可开启缓存，当视图函数第一次被执行后会将返回值临时存储起来，在过期时间前，对这个视图函数的调用将直接使用被缓存起来的值。在代码清单13-2中，我们为显示bar页面的bar视图设置了缓存，缓存时间设为10分钟。

代码清单13-2 cache/app.py：为视图函数设置缓存

- - - -


```

@app.route('/bar')
@cache.cached(timeout=10 * 60)
def bar():
    time.sleep(1)
    return render_template('bar.html')

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20115.png)
注意

cache.cached()装饰器应该在app.route()装饰器内部定义。

我们可以在cache.cached()装饰器中使用timeout参数来设置缓存数据的过期时间，单位为秒，默认值为300。这个值要根据对应数据的变动频率来设置，不同类型的页面需要设置不同的缓存过期时间。以社交网站为例，关于网站介绍页面、隐私政策页面等不常变动的页面可以设为1天或更多，用户主页可以设为1小时，文章页面可以设为15分钟。

如果你运行了示例程序，可以访问 [http://localhost:5000](http://localhost:5000) 打开主页，然后分别Foo和Bar链接打开对应的页面，然后通过按下F5刷新页面来查看两个页面的对比，通过调试工具栏的Time列可以查看页面加载时间。未启用缓存时每次加载页面都需要1秒以上的时间；启用缓存后，第一次加载需要1秒以上，再次刷新页面时，加载时间则会降到1毫秒左右。 

被缓存的数据会以键值对的形式存储起来，当下次处理请求时会先查找是否存在对应键的数据，所以我们要确保被缓存的不同值的键是唯一的。当缓存视图函数返回值时，它使用当前请求的request.path值来构建缓存数据的键，即view/%（request.path）s。也就是说，如果URL中包含查询字符串的话，这部分内容会被忽略掉。比如我们的posts视图接收查询参数page来指定分页的页数，而缓存的键不包含查询参数，这就会导致不论访问哪一页都会返回被缓存的第一页数据。

在对包含查询参数的路由使用cache.cached()装饰器时，需要将参数query_string设为True，这会将排序后的查询参数散列值作为键，比如：

- - - -


```

@app.route('/qux')
@cache.cached(query_string=True)
def qux():
    time.sleep(1)
    page = request.args.get('page', 1)
    return render_template('qux.html', page=page)

------

如果你运行了示例程序，可以访问 http://localhost:5000/qux 打开包含查询字符串的缓存测试页面，默认的page查询参数的值为1，在刷新页面可以看到启用了缓存。如果你在地址栏中将page查询参数设为2，那么页面对应的视图函数会重新执行，并设置新的缓存数据。 

通过使用Flask-DebugToolbar，你可以从数据上直观了解缓存的效果。以Bluelog程序为例，Bluelog的主页共包含27个数据库查询和一次模板渲染。以随机的一次测试为例，第一次加载共花费了129毫秒（ms），使用缓存后，数据库查询和模板渲染数量均为0，加载页面只使用了0.18毫秒（ms），与之前相比，这可是716倍的速度提升。

#### 13.2.2  缓存其他函数

我们不仅可以缓存视图函数的返回值，还可以缓存其他函数。和缓存视图函数相同，我们也使用cache.cached()装饰器设置缓存。不同的是，你必须使用key_prefix关键字为缓存数据设置一个缓存键。如果没有设置，Flask-Caching会使用当前请求的request.path的值，这有可能会覆盖视图函数的数据。以一个简单的add()函数为例，在这个函数中我们休眠2秒来模拟复杂运算：

------

@cache.cached(key_prefix='add')
def add(a, b):
    time.sleep(2)
    return a + b

------

在Python Shell中调用这个函数的示例如下所示：

------

> > > from app import add
> > > add(1, 1)  # 第一次调用的返回值会被缓存，计算耗时2秒多
> > > 2
> > > add(2, 2)  # 因为被缓存，所以返回值仍然是2，耗时小到忽略不计
> > > 2
> > > add(5, 5)  # 返回值仍然相同，直到缓存过期，耗时小到忽略不计
> > > 2

------

为计算加法的函数设置缓存有些奇怪，这主要是为了引出下面的另一种缓存方式。对于接收参数的函数或方法，如果你想将参数值纳入缓存考虑范围，可以使用memoize()装饰器。它的用法和cached()完全相同，不过同时将传入函数的参数作为考量，只有发生传入同样参数的调用才会使用缓存。下面是使用memoize()装饰器的进阶版add_pro()函数：

------

@cache.memoize()
def add_pro(a, b):
    time.sleep(2)
    return a + b

------

在Python Shell中的使用示例如下所示：

------

> > > from app import add_pro
> > > add_pro(1, 1)  # 调用函数，返回值被缓存，耗时2秒多
> > > 2
> > > add_pro(1, 1)  # 直接使用缓存，耗时小到忽略不计
> > > 2
> > > add_pro(3, 4)  # 参数不同，再次调用函数，返回值被缓存，耗时2秒多
> > > 7
> > > add_pro(3, 4)  # 直接使用缓存，耗时小到忽略不计
> > > 7

------


附注

Flask-Caching还支持使用cache标签在Jinja2模板中设置缓存，具体请访问Flask-Caching文档查看。

#### 13.2.3  更新缓存

当使用了缓存后，我们会面临一个问题。拿Bluelog来说，当博客的作者登录程序后，会对博客的内容进行修改，这时因为缓存的缘故，作者无法立刻看到更改后的新内容。为了解决这个问题，我们可以在每一个对博客内容进行更改的操作后面调用cache.delete()方法来清除缓存，传入特定的键来获取对应的缓存。在示例程序中，我们创建了update_bar和update_baz视图，分别用来为前面的Bar页面和Baz页面删除缓存（baz视图和bar视图类似，但缓存过期时间设为1小时），如代码清单13-3所示。

代码清单13-3 cache/app.py：删除特定的缓存

------

@app.route('/update/bar')
def update_bar():
    cache.delete('view/%s' % url_for('bar'))
    flash('Cached data for bar have been deleted.')
    return redirect(url_for('index'))

@app.route('/update/baz')
def update_baz():
    cache.delete('view/%s' % url_for('baz'))
    flash('Cached data for baz have been deleted.')
    return redirect(url_for('index'))

------

在执行完数据库操作后，我们使用cache.delete()方法删除缓存。我们在前面提到过，视图函数缓存的键默认为“view/<请求路径request.path>”，这里我们使用url_for()函数构建缓存的键，删除对应的缓存。另一方面，如果你在cached()装饰器中通过key_prefix参数传入了自定义的键前缀，那么在删除时传入这个键即可。

对于使用memorize()装饰器设置的缓存，你可以使用delete_memorized()方法来删除缓存，传入函数对象。另外，你还可以调用cache.clear()来清除程序中的所有缓存，如下所示：

------

# 清除所有缓存

@app.route('/update/all')
def update_all():
    cache.clear()
    flash('All cached data deleted.')
    return redirect(url_for('index'))

# 删除为add_pro()函数设置的缓存

def del_pro_cache():
    cache.delete_memoized(add_pro)

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20116.png)
注意

某些缓存后端不支持清除所有缓存。另外，如果没有为缓存数据设置缓存键，Redis会清空整个数据库。一般情况下，我们不需要清除所有缓存。

如果你运行了示例程序，可以访问 [http://localhost:5000](http://localhost:5000) 打开主页，主页上的按钮依次用来删除Bar页面、Baz页面和所有缓存，如图13-2所示。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20313.png)
提示

另一个设置跳过缓存的方法是使用cached装饰器中的unless参数。它接收一个可调用对象作为输入，如果可调用对象返回True则不使用缓存。我们可以创建一个is_login()函数，赋值给unless，即cached（unless=is_login），这个函数会返回current_user.is_authenticated的值。这样当用户登录后就会取消缓存。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEC0U7AAAAAMcI_BQ626587060.jpg)
图13-2 清除缓存按钮

#### 13.2.4  使用Redis作为缓存后端

在大型程序中，因为要缓存的数据量比较大，对存取速度的要求比较高，我们需要一个更可靠，性能更好的存储后端。Redis（ [https://redis.io/](https://redis.io/) ）是一个开源的内存型数据结构存储系统，属于我们在第5章介绍的键值对NoSQL数据库。它的存取速度非常快，支持丰富的数据类型，因此非常适合作为缓存的存储后端。 

首先，我们需要访问Redis官网的下载页面（ [https://redis.io/download](https://redis.io/download) ）下载并安装Redis服务器。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20314.png)
提示

Redis官方没有提供Windows支持，不过微软Open Tech小组开发了一个Windows移植版本（ [https://github.com/MicrosoftArchive/redis](https://github.com/MicrosoftArchive/redis) ），你可以在这个项目的release页面找到.msi安装文件。 

安装好Redis服务器并运行启动后，我们还需要安装Redis的Python接口库，Flask-Cach-ing会使用它来连接Redis服务器进行存取操作：

- - - -


```

$ pipenv install redis

```
- - - -

我们将CACHE_TYPE的值设为redis来告诉Flask-Caching使用Redis存储缓存：

- - - -




```

CACHE_TYPE = 'redis'

```
- - - -

如果你没有修改Redis服务器的默认设置，那么现在缓存就可以正常工作了。如果你修改了默认配置，那么可以使用额外的配置键设置：

- - - -




```

CACHE_REDIS_HOST = 'localhost'
CACHE_REDIS_PORT = '6379'
CACHE_REDIS_PASSWORD = 'your password'
CACHE_REDIS_DB = '0'

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20200.png)
附注

你也可以直接使用CACHE_REDIS_URL传入redis服务器地址，比如redis：//user：password@localhost：6379/0

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20315.png)
提示

对于大型程序，除了在程序服务器本地存储缓存外，还会使用CDN、分布式缓存服务器等方式来存储缓存。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 13.3  使用Flask-Assets优化静态资源

在服务器端加入缓存系统后，程序的响应速度会有非常明显地提升。但是对于客户端，我们还有一些优化工作要做。当页面被加载时，除了页面本身，同时被加载的还有页面中被引用的文件，每一个文件都会触发一个HTTP请求。我们可以在命令行输出看到对应的记录，除了HTML页面和Favicon，其中还包括多个JavaScript文件和CSS文件，同时下载大量文件必然会带来性能问题。在部署时我们一般会采取租用CDN服务（开源JavaScript库和CSS库各大CDN提供商会免费提供）或是用设立独立的静态资源服务器的方式进行优化，在此之前，我们可以在程序中对这些资源进行预处理。

在开发时，为了方便，我们常常会把JavaScript和CSS代码分为多个文件，并在文件中使用缩进、换行以及添加注释来增加可读性。因此，我们可以通过下面的方式来进行优化：

·对CSS和JavaScript文件进行压缩，去除换行、空白和注释，提高资源加载速度。

·分别合并多个CSS文件和JavaScript文件，减少页面加载的请求数。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20316.png)
提示

再次提示，为了便于管理，除非是从CND加载的资源，其他的扩展内置提供的资源文件建议你手动下载并保存到static目录下，这样可以统一处理，在部署时也会更加方便。

在本节，我们会介绍使用Flask-Assets扩展优化程序资源，对应的示例程序在helloflask/demos/assets目录下，确保当前工作目录在helloflask/demos/assets下并激活了虚拟环境，然后执行flask run命令运行程序：

- - - -




```

 cd cache
​ flask run

```
- - - -

Python包webassets提供了Web项目的资源管理功能，我们将使用集成webassets的Flask扩展Flask-Assets来实现资源优化功能，首先从Pipenv安装Flask-Assets及其依赖：

- - - -




```

$ pipenv install flask-assets

```
- - - -

然后导入Enviroment类，将其实例化为assets对象，传入程序实例app以初始化扩展：

- - - -




```

from flask import Flask
from flask_assets import Environment, Bundle

app = Flask(name)

assets = Environment(app)

```
- - - -

#### 13.3.1  注册资源集

初始化扩展后，我们需要注册资源，也就是定义哪些文件需要被压缩并打包成单个文件。通过实例化Bundle类，并传入资源的路径作为参数，我们可以定义一个资源集，如代码清单13-4所示。

代码清单13-4 assets/app.py：注册资源集

- - - -




```

from flask import Flask
from flask_assets import Environment, Bundle
...
css = Bundle('css/bootstrap.min.css',
             'css/bootstrap.css',
             'css/dropzone.min.css',
             'css/jquery.Jcrop.min.css',
             'css/style.css',
             filters='cssmin', output='gen/packed.css')

js = Bundle('js/jquery.min.js',
            'js/popper.min.js',
            'js/bootstrap.min.js',
            'js/bootstrap.js',
            'js/moment-with-locales.min.js',
            'js/dropzone.min.js',
            'js/jquery.Jcrop.min.js',
            filters='jsmin', output='gen/packed.js')

assets.register('js_all', js)
assets.register('css_all', css)

```
- - - -

我们在这里引入了许多JavaScript和CSS文件。在Flask-Assets中，资源集使用Bundle类实例表示，我们分别为JavaScript和CSS文件创建了资源集。Bundle类的构造方法接收任意数量的文件路径作为非关键字参数，这里所有的路径都是相对于程序包中或蓝本的静态文件夹而言的。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20317.png)
提示

扩展内置的资源也通过蓝本提供，因此也可以通过添加蓝本前缀来获取蓝本中的资源，比如bootstrap/css/bootstrap.min.css，不过并不推荐使用扩展内置资源。

我们需要使用filters参数来定义对文件编译时使用的处理工具，webassets的文档中列出了所有支持的过滤器（ [https://webassets.readthedocs.io/en/latest/builtin_filters.html](../Text/https://webassets.readthedocs.io/en/latest/builtin_filters.xhtml) ）。我们这里分别使用cssmin与jsmin来压缩CSS和JavaScript代码，为了在程序中使用它们，我们需要额外安装它们： 

- - - -




```

$ pipenv install jsmin cssmin

```
- - - -

我们使用参数output来指定被压缩、合并后的文件路径（同样是相对于static文件夹的路径）。这里会把所有的js文件输出到gen/packed.js中，所有的CSS文件输出到gen/packed.css中。

最后我们需要调用assets.register()方法来注册刚刚创建的两个资源集，传入资源集的名字作为第一个参数，表示资源集的Bundle对象作为第二个参数。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20117.png)
注意

某些依赖本地静态文件（比如CSS文件、图标、字体文件）的JavaScript或CSS文件不能直接打包，否则在生成的文件中调用将会无法正确获取对应的静态文件，比如Iconic图标或是CKEditor。对于CSS文件，你可以使用内置的cssrewrite过滤器对打包后的CSS文件中的相对路径进行修正，具体可以访问 [https://webassets.readthedocs.io/en/latest/builtin_filters.xhtml#filters-cssrewrite](../Text/https://webassets.readthedocs.io/en/latest/builtin_filters.xhtml#filters-cssrewrite) 了解。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20318.png)
提示

在使用Flask-CKEditor和Flask-Dropzone扩展时，因为对应的资源不是全局依赖，只需要在特定的页面才需要，所以没有必要打包进这里的资源集。

#### 13.3.2  生成资源集文件

当模板被第一次渲染时，Flask-Assets会自动处理注册的资源集并生成文件，构建优化后的资源文件会占用一定的时间，我们一般会在部署上线前使用下面的命令提前手动生成文件：

- - - -




```

$ flask assets build
Building bundle: gen/packed.css
Building bundle: gen/packed.js

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20319.png)
提示

当资源被修改后，发起新的请求时，Flask-Assets会自动重新更新压缩文件。当我们需要对部署后的程序进行更新时，可以在远程服务器上手动执行上面的命令并重新打包。另外，Flask-Assets会自动记录资源的版本，在资源更新后的请求后面更新文件MD5散列值，以便让用户的浏览器忽略缓存，重新请求更新后的文件，即Cache Busting。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20118.png)
注意

开发时不需要使用Flask-Assets进行资源优化，因为我们可能会频繁地修改JavaScript和CSS文件，重新生成资源合集会耗费不必要的时间。

#### 13.3.3  在模板中加载资源集

要在模板中加载我们注册的资源，得先在模板中使用assets标签创建一个资源块，并传入我们注册的资源集名称。这个块需要使用endassets标签关闭。在这个块中，我们可以使用ASSET_URL变量来获取指向处理后的资源集文件的URL，如代码清单13-5所示。

代码清单13-5 assets/templates/optimized.html：在模板中加载合并后的资源文件

- - - -




```

{% block styles %}
    {% assets "css_all" %}
        <link rel="stylesheet" href="{{ ASSET_URL }}">
    {% endassets %}
{% endblock %}
...
{% block scripts %}
    {% assets "js_all" %}

        <script type="text/javascript" src="{{ ASSET_URL }}"></script>

​    {% endassets %}
{% endblock %}

```
- - - -

这里我们把assets块定义在基模板中的styles块和scripts块中，因为这些资源集中包含所有要在基模板中加载的JavaScript和CSS文件，所以我们不用再使用扩展提供的资源加载函数。当在实际的程序中使用时，我们可以把上面的style块和scripts块直接定义在基模板中的相应位置，替换掉被打包的资源引用语句。

为了说明资源优化后的速度提升，我们可以进行一个简单的对比。在示例程序中，我们创建了foo和bar视图。foo视图渲染未进行资源优化的unoptimized.html模板，其中包含了大量的资源引用语句；bar视图渲染使用Flask-Assets的optimized.html模板，也就是我们在上一节介绍的模板。这两个页面引入的资源文件相同。对于没有进行优化的Foo页面，加载页面时会加载12个静态文件，文件的总体积为905KB，页面加载时间总计为3.36秒，如图13-3所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEdua9AAAAAC99Uc4921032736.jpg)
图13-3 优化前的资源加载情况

使用Flask-Assets对资源进行优化后，只会加载2个静态文件，文件的体积被缩小到811KB，页面加载时间缩减为2.14秒，如图13-4所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEL5aSAAAAAPNpcik262987179.jpg)
图13-4 优化后的资源加载请求

如果你运行了示例程序，可以分别访问 [http://localhost:5000/foo](http://localhost:5000/foo) 和 [http://localhost:5000/bar](http://localhost:5000/bar) 测试优化资源的前后对比。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20201.png)
附注

（1）除了JavaScript和CSS文件外，HTML响应也可以进行优化处理（去除空行、空白和注释），你可以通过其他Flask扩展或Jinja2扩展实现。不过，因为HTML页面每次都要动态生成，那么每个HTML响应都要进行优化，这么做会增加服务器端的压力，除非你需要应对非常大的访问量，否则一般不需要这么做。对于HTML、JavaScript、CSS和字体文件等静态资源，我们一般会在部署后通过Web服务器来使用Gzip或Brotli（简称br）等压缩算法对数据进行压缩传输，这样可以减小文件在传输过程中的体积（最高可以达到80%左右的压缩率），提高传输速度。

（2）如果页面中使用了大量图片，你可以使用工具对这些图片进行压缩优化以减少体积。多个小图片则可以使用工具拼接成单个图片文件，在使用时通过CSS获取，这种技术被称为CSS Sprite。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 13.4  本章小结

经过了测试和性能优化，我们的程序已经准备好进行部署了。如果说把程序上线相当于上台表演的话，那么测试和性能优化无疑是不可或缺的准备步骤。没有台下的努力和准备，台上的表现很可能会让我们失望。还好，我们已经准备好了。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

## 第14章

## 部署上线

经过上一章的准备，我们的程序已经准备好部署（Deployment）上线了。部署指的是把程序托管到拥有公网IP的远程服务器（计算机）上，这样程序才可以被互联网上的所有人通过IP或映射到IP的域名访问到。

本章新涉及的Python包如下所示：

·Flask-SSLify（0.1.5）

·主页： [https://github.com/kennethreitz/flask-sslify](https://github.com/kennethreitz/flask-sslify) 

·Gunicorn（19.8.1）

·主页： [http://www.gunicorn.org/](http://www.gunicorn.org/) 

·文档： [http://docs.gunicorn.org](http://docs.gunicorn.org) 

·源码： [https://github.com/benoitc/gunicorn](https://github.com/benoitc/gunicorn) Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 14.1  传统部署VS云部署

部署有很多种方式，我们需要根据程序的特性来综合考虑。一般来说，部署共分为传统部署和云部署两种。如果把部署程序比作为程序租房子的话，那么云部署就是精装修的公寓，我们的程序只需要接通电源就可以开始运行；而传统部署就是毛坯房，我们需要自己动手设置所有环境。

具体来说，传统部署指的是自己购买/租用远程服务器，然后把程序安装到服务器上的过程。这里的服务器和我们前面提及的Web服务器不同，它是指物理意义上的，可以用硬盘、内存等指标来形容的物理服务器或虚拟服务器，也被称为远程主机。从本质上讲，在远程主机上部署程序和在本地运行程序基本相同，只不过基于安全和性能的考虑我们要增加一些额外的步骤。

我们通常会通过虚拟主机服务提供商来租用虚拟主机，这些服务被称为IaaS（Infrastructure as a Service，设施即服务）。主流的选择有Amazon EC2、Google Compute Engine、Microsoft Azure、DigitalOcean、Linode以及国内的阿里云ECS等，其中DigitalOcean（ [https://www.digitalocean.com/](https://www.digitalocean.com/) ）、Linode（ [https://www.linode.com/](https://www.linode.com/) ）提供了每月5美元的经济型主机，包含1GB内存，20/25GB SSD硬盘，非常适合入门使用。 

传统部署比较灵活，一切都由你自己来掌控，不过同时也需要耗费较多的精力去进行环境搭设和维护，所以大型网站通常会有专门的服务器运维人员来负责服务器的管理和维护，如果你想深入学习，那么这中间还有很多可以探索的主题。如果你不想把时间都花费到运维上，只想尽快让你的程序部署上线，那么可以考虑使用云部署。

云部署即PaaS（Paltform as a Service，平台即服务）。简单来说，云部署服务提供了一个完善的平台，提供了所有底层基础设施，我们只需要推送程序代码即可。使用云部署可以省去配置服务器、设置数据库、配置网络服务器以及设置防火墙等步骤。使用简单的方式即可集成第三方工具、添加数据库、设置邮件服务等，使用起来非常灵活。当然，云部署的价格一般要比传统部署要高。

比较流行的PaaS有Heroku、Google App Engine、AWS Elastic Beanstalk、PythonAnywhere、Webfaction以及国内的Sina App Engine等。对于大型程序/商业项目，我们需要综合各方面的信息来做选择。作为起步来说，我建议使用Heroku（ [https://heroku.com/](https://heroku.com/) ）或PythonAnywhere（ [https://pythonanywhere.com](https://pythonanywhere.com) ），因为这两者的自由度较大，免费用户可用的资源限额也较多。本章我们将介绍如何在Heroku和PythonAnywhere上部署Flask程序。其他平台的部署步骤大同小异，可以参考各自的文档。当程序规模逐渐发展后，可以考虑升级服务器配置或是考虑迁移到传统部署。 

本章我们将以Bluelog程序作为示例来分别演示在传统的Linux服务器上以及云部署平台PythonAnywhere和Heroku部署程序。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20320.png)
提示

如果你从GitHub上复制了示例程序Bluelog，可以切换到该项目根目录下然后执行git checkout deploy签出程序的新版本。程序的新版本添加了一些部署准备操作。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20202.png)
附注

除了这两种部署形式，常见的部署形式还有静态部署。静态部署是先借助工具将程序静态化处理，比如使用扩展Frozen-Flask（ [http://github.com/SimonSapin/Frozen-Flask/](http://github.com/SimonSapin/Frozen-Flask/) ），静态处理就是把程序中的所有动态页面全部转换成对应的HTML文件，分目录放置。静态处理后的程序部署成本非常低，而且有大量免费的静态部署服务，比如GitHub Pages（ [https://pages.github.com](https://pages.github.com) ）、Netlify（ [https://www.netlify.com/](https://www.netlify.com/) ）等。当然，不是所有的程序都适合静态处理，这种方式一般适用于不需要接收用户输入、不产生动态输出的程序，比如个人博客。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 14.2  基本部署流程

无论是使用传统部署还是云部署，我们都要考虑如何将程序代码推送到服务器中，并考虑如何推送更新。部署时所使用的工具和开发时会有所不同。开发时我们使用Flask内置的开发服务器来运行程序，并使用flask run启动这个服务器，同时会使用FLASK_APP环境变量来给出程序实例的位置；部署时我们将使用更加完善的WSGI服务器来运行程序，这时启动服务器的方法依使用的库而定，而且我们需要手动给出程序实例所在的模块和实例名称。另外，对于使用类组织配置的程序，在开发时我们使用名称为development的配置，而部署时则使用production配置。

Flask官方推荐将程序像Python包那样添加一个setup.py文件，然后通过打包构建生成分发包，将分发包上传到服务器并安装到虚拟环境中。实际上，这种方式引入了不必要的复杂度。对于程序来说，通过Git来推送代码的方式更加简单。你可以按照你的喜好选择部署方式，如果你更倾向于Flask官方推荐的做法，那么需要在项目根目录创建setup.py文件，并通过MANIFEST.in文件来指定包数据，具体可以参考第15章的介绍。

如果你将程序代码托管在在线代码托管平台（比如GitHub、BitBucket、GitLab等），那么使用Git部署程序的过程非常简单，和在你自己的电脑上运行本书提供的示例程序的过程基本相同，流程大致如下：

1）在本地执行测试。

2）将文件添加到Git仓库并提交（git add&git commit）。

3）在本地将代码推送到代码托管平台（git push）。

4）在远程主机上从代码托管平台复制程序仓库（git clone）。

5）创建虚拟环境并安装依赖。

6）创建实例文件夹，添加部署特定的配置文件或是创建.env文件存储环境变量并导入。

7）初始化程序和数据库，创建迁移环境。

8）使用Web服务器运行程序。

这种部署方法的最基本的部署流程示意图如图14-1所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEEoREAAAAAPSBDEU324219947.jpg)
图14-1 Git部署基本流程

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20203.png)
附注

除了使用在线代码托管平台，你还可以在远程主机上设置一个私有的Git服务器，具体可以访问 [https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server](https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server) 了解。 

更新程序的步骤基本相同，如下所示：

1）在本地执行测试。

2）将文件添加到Git仓库并提交（git add&git commit）。

3）在本地将代码推送到代码托管平台（git push）。

4）在远程主机上从代码托管平台拉取程序仓库（git pull）。

5）如果有依赖变动，或是数据库表结构变动，那么执行依赖安装和数据库迁移操作。

6）重启Web服务器。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20321.png)
提示

（1）借助Git提供的服务器端钩子（Server-Side Hooks），比如post-revive钩子，我们可以实现部署操作的自动化。通过定义钩子触发的脚本，我们可以让远程主机的Git服务器在接收到本地的代码推送后自动执行相应的更新和重启Web服务器等操作。如果是使用在线代码托管平台，比如GitHub和BitBucket，需要在项目设置中进行对应的设置。具体可以参考 [https://gist.github.com/oodavid/1809044](https://gist.github.com/oodavid/1809044) 。 

（2）在实际的部署中，对于大型程序，或多人协作开发的程序，我们通常会为程序设置持续集成系统，通过设置Git钩子，当有人向远程主机的主分支推送代码后会自动触发CI系统进行构建测试，测试通过后才会将改动集成到程序中。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20204.png)
附注

除了使用Python包和Git进行部署外，另外一种逐渐流行的方式是使用容器技术部署程序。简单地说，借助容器管理系统，比如Docker（ [https://www.docker.com/](https://www.docker.com/) ），我们可以在本地开发时就把程序以及包括操作系统在内的所有依赖封装成镜像，这样可以直接运行在各种服务器环境中，省去了重复的调试和部署操作。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 14.3  部署前的准备

除了前两章的自动化测试和性能优化，在部署前我们还有一些工作要做。

#### 14.3.1  更新程序配置

生产环境下需要不同的配置，我们在开发时已经通过使用Python类对生产配置进行了分离，并且对某些包含敏感信息的配置变量优先从环境变量读取，比如数据库URL、Email服务器配置信息等。在部署到远程主机上后，我们仍然通过将环境变量写到.env文件来设置关键配置，现在，我们的任务是将这些信息提前写到本地的.env文件中。

首先，我们需要为保存程序密钥的SECRET_KEY配置变量生成一个随机字符，更换开发时填入的占位字符，比如：

- - - -




```

SECRET_KEY=\x8dYai\x06r\x11\xdd\xd7\xf1\x1c\xd0

```
- - - -

随机密钥的生成方式有很多。比如，os模块的urandom()方法可以用来生成随机密码，它接收字节长度作为参数：

- - - -




```

> > > import os
> > > os.urandom(12)
> > > '\xf0?a\x9a\\\xff\xd4;\x0c\xcbHi'

```
- - - -

复制返回的字符作为密钥使用就可以了。

如果你使用Python 3.6版本，那么可以使用secrets模块提供的token_bytes()、token_hex()、token_urlsafe()方法，这些方法接收字节长度作为参数。比如：

- - - -




```

> > > import secrets
> > > token_urlsafe(16)
> > > 'Drmhze6EPcv0fN_81Bj-nA'

```
- - - -

另外，我们也可以使用uuid模块来生成随机字符：

- - - -




```

> > > import uuid
> > > uuid.uuid4().hex
> > > '3d6f45a5fc12445dbac2f59c3b6c7cb1'

```
- - - -

在生产环境下我们仍需要执行某些flask命令，而执行flask命令需要正确设置FLASK_APP环境变量。这个变量在我们项目根目录下的.flaskenv文件中已经定义，并且这个文件被提交到Git仓库中，所以不需要重复写入.env文件中。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20119.png)
注意

在生产环境下，我们需要将FLASK_CONFIG变量设置为production，这可以确保在生产环境下执行flask命令时加载的是生产配置（工厂函数会优先从这个环境变量里读取配置名称）。另外，我们还需要将FLASK_ENV变量设为production（覆盖.flaskenv中的设置），用来确保命令执行时处于正确的环境设置。我们将在远程主机上创建.env文件后再手动写入这两个变量，具体会在后面介绍。

在PythonAnywhere部署程序时，因为PythonAnywhere使用的数据库服务会在5分钟（300秒）断开连接，我们需要将Flask-SQLAlchemy提供SQLALCHEMY_POOL_RECYCLE配置变量的值设为300以下，它用来设置数据库连接池的回收时间，比如：

- - - -




```

SQLALCHEMY_POOL_RECYCLE = 280

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20120.png)
注意

.env文件包含敏感信息，不能提交进Git仓库。你可以考虑在远程主机上重新创建这个文件，将本地内容复制过去，后面会具体介绍。另外，你也可以使用SCP或SFCP将这个文件上传到远程主机。SCP指Secure Copy Protocol，SFTP指SSH File Transfer Protocol，两者都是基于SSH实现的在主机之间安全传输文件的协议，同时也指代实现这个协议的程序。如果你使用Windows系统，可以使用WinSCP（ [https://winscp.net/](../Text/https://winscp.net/) ）来实现同样的效果。 

#### 14.3.2  创建生产环境专用的程序实例

生产环境下的程序自然要加载生产配置，我们需要在项目的根目录下创建一个wsgi.py脚本（这里的命名只是约定，你可以使用其他名称），在这个模块中使用工厂函数create_app()创建一个程序实例，传入生产环境配置名production，如下所示：

- - - -




```

from bluelog import create_app

app = create_app('production')

```
- - - -

这个程序实例专用于部署时运行。在生产环境下，我们需要使用生产服务器运行实例，这时就可以从这个文件中导入这个程序实例，比如：

- - - -




```

from foo_server import serve
from wsgi import app

serve(app, '0.0.0.0:80')

```
- - - -

#### 14.3.3  设置迁移工具

除非是用于部署测试，否则设置迁移工具这一步必不可少，这可以让你在保留原数据的同时对数据库结构进行更新。在第5章，我们介绍了如何使用集成了Alembic的扩展Flask-Migrate，首先使用Pipenv安装：

- - - -




```

$ pipenv install flask-migrate

```
- - - -

在程序中，实例化Flask-Migrate提供的Migrate类，进行初始化操作。因为Bluelog使用了工厂函数创建程序实例，所以我们需要在extensions.py脚本中实例化Migrate类，在工厂函数中对该实例调用init_app()方法，传入app和db对象，具体可以到源码仓库中查看。

我们可以提前在本地生成迁移文件夹并执行一次初始迁移：

- - - -




```

 flask db init
​ flask db migrate -m "Initial migration"

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20322.png)
提示

对于要部署到Heroku的程序来说，生成迁移文件夹和创建迁移脚本的操作必须在本地进行，后面会具体介绍。

#### 14.3.4  程序日志

在开始介绍部署之前，我们得先考虑一下日志问题。虽然我们为程序编写了相对完善的测试，而且顺利通过了测试，程序还是有可能在你意想不到的地方出错。比如，在代码之外的地方，各种意外情况都可能出现：服务器超载、数据库写入异常、受到恶意攻击、各种库之间出现不兼容等。

在第3章，我们通过app.errorhandler装饰器为几种常见的错误类型注册了错误处理器。在生产环境下，当程序出现错误时，用户会看到一个错误页面，但我们（开发者/运维人员）却什么也不知道。这时把错误信息记录下来会有助于调试和修复。在开发时，我们可以通过Werkzeug内置的调试器来查看错误堆栈，或是在命令行输出中查看日志。但是在生产环境中，我们没法使用上面的方式获取日志，这时就需要记录日志。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20205.png)
附注

这里不会详细介绍Python日志系统，如果你对Python的logging模块不熟悉，可以阅读Python文档中的入门教程（ [https://docs.python.org/3/howto/logging.xhtml#logging-basic-tutorial](../Text/https://docs.python.org/3/howto/logging.xhtml#logging-basic-tutorial) ）。 

Flask通过Python标准库的logging模块提供了一个日志记录器（logger）对象，它的名称为flask.app，可以通过app.logger属性获取。我们可以像往常那样，对这个logger对象调用debug()、info()、warning()、error()、exception()和critical()方法来触发相应等级的日志事件。比如：

- - - -




```

app.logger.warning('A wraning message. ')

```
- - - -

当日志记录器等级未设置时（即logging.NOSET），有效等级（effective level）为WARN-ING；如果开启了调试模式，那么日志记录器（logger）的等级会被设为DEBUG。如果没有配置日志处理器（log handler），Flask会添加一个默认的处理器，类型为StreamHandler，它会把日志输出到stderr（显示在命令行窗口）。下面我们会介绍两种常用的日志处理器，分别是将日志存储到文件的RotatingFileHandler处理器和通过Email发送日志的SMTPHandler处理器。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20323.png)
提示

其他常用的日志处理器可以访问 [https://docs.python.org/3/howto/logging.xhtml#useful-handlers](../Text/https://docs.python.org/3/howto/logging.xhtml#useful-handlers) 查看。 

1.将日志写入文件

以Bluelog为例，为了便于组织代码，我们在程序包的构造文件中创建一个register_logger()函数为程序实例注册日志处理器，在工厂函数中调用这个函数并传入程序实例，这个函数的内容如代码清单14-1所示。

代码清单14-1 bluelog/__init__.py注册文件日志处理器

- - - -




```

import logging
from logging.handlers import RotatingFileHandler

def create_app(config_name=None):
    ...
    register_logger(app)

def register_logger():
    app.logger.setLevel(logging.INFO)

```
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

file_handler = RotatingFileHandler('logs/bluelog.log', maxBytes=10 * 1024 *1024, backupCount=10)
file_handler.setFormatter(formatter)
file_handler.setLevel(logging.INFO)

if not app.debug:
    app.logger.addHandler(file_handler)



```

```
- - - -

为了让日志记录器记录INFO等级的日志事件，我们首先将app.logger的等级设为INFO。然后我们创建一个logging.Formatter对象设置日志的输出格式。为了避免日积月累产生一个巨大的日志文件，我们使用RotatingFileHandler类（从logging.handlers模块导入）创建一个轮转文件类型的日志处理器，实例化这个类传入日志文件的目标路径、最大文件尺寸和备份数量。当日志文件的大小超过实例化时传入的maxBytes参数设定的值时（单位为字节byte，我们这里设为10MB），它会循环覆盖之前的记录；将backupCount参数设为10会依次创建10个日志文件，10个文件全部存满10MB后会开始覆盖之前的文件。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20324.png)
提示

这里我们传入logs/bluelog.log作为日志文件路径，为了让日志文件顺利创建，我们需要在项目根目录下创建一个logs文件夹。不过日志文件并不需要添加到Git仓库中，你可以在logs目录下创建一个.gitkeep文件，并在.gitignore中写入一个*.log规则，这会确保将logs目录添加到Git仓库，但是忽略所有以.log结尾的日志文件。

我们使用setFormatter()方法设置处理器输出的日志格式，使用setLevel()方法将文件日志处理器的接收日志等级设为INFO。

最后，我们对app.logger调用addHandler()方法将处理器注册到logger对象中，添加if判断确保在调试模式下不会添加处理器。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20325.png)
提示

（1）app.debug属性存储用来判断程序是否开启了调试模式的布尔值。当FLASK_ENV环境变量的值为development时，app.debug会返回True，否则返回False。在程序中，你可以通过app.env属性获取FLASK_ENV的设置值。

（2）另外还有一个TimedRotatingFileHandler类，它会根据设定的时间间隔（通过实例化时传入的参数设定）来定期覆盖日志数据。

（3）当部署到生产环境时，对于使用UNIX系统的传统部署方式来说，除了使用文件存储日志，也可以把日志输出到系统守护进程syslog中，这通过SysLogHandler类实现；类似地，Windows系统则可以使用NTEventLogHandler类将日志写入系统事件日志。

2.云部署平台的日志

本节要介绍的两个云部署平台会从stdout（标准输出）和stderr（标准错误输出）收集日志，如果要把程序部署到这两个平台，我们需要创建一个StreamHandler类型（从logging模块直接导入）的日志处理器来替代上面的RotatingFileHandler处理器。因为Flask内置的日志处理器即为StreamHandler类型，所以我们可以直接使用这个处理器（flask.logging.default_handler）。这个处理器只会在没有添加日志处理器时才会被添加，所以我们可以手动导入并添加到日志记录器对象上：

- - - -




```

import logging
from flask.logging import default_handler

def register_logger():
    ...
    default_handler.setLevel(logging.INFO)
    if not app.debug:
        ...
        app.logger.addHandler(default_handler)

```
- - - -

3.通过邮件发送关键日志

在生产环境中，低等级的信息可以记录到日志文件中，而关键的信息（比如ERROR等级以上）则需要通过邮件发送给管理员，以便及时修复问题。

对于ERROR等级及以上的关键日志，我们通常需要更加详细的出错信息，以便更迅速地排查和解决问题。为了在日志信息中插入触发这个日志事件的请求信息，我们创建一个自定义的RequestFormatter类，它继承自logging.Formatter类，添加了几个自定义字段来插入请求信息，如代码清单14-2所示。

代码清单14-2 bluelog/__init__.py：在日志中插入请求信息

- - - -




```

import logging

def register_logger():
    class RequestFormatter(logging.Formatter):
        def format(self, record):
            record.url = request.url
            record.remote_addr = request.remote_addr
            return super(RequestFormatter, self).format(record)

```
request_formatter = RequestFormatter(
    '[%(asctime)s] %(remote_addr)s requested %(url)s\n'
    '%(levelname)s in %(module)s: %(message)s'
)



```

```
- - - -

使用SMTPHandler类可以创建一个SMTP处理器，传入的参数大多从相应的Flask-Mail配置变量获取。我们将这个邮件日志处理器的等级设为logging.ERROR，当发生ERROR等级及以上的日志事件时会将日志通过邮件发送给管理员，如代码清单14-3所示。

代码清单14-3 bluelog/__init__.py：注册邮件日志处理器

- - - -




```

import os
import logging
from logging.handlers import SMTPHandler

def register_logger():
    ...
    mail_handler = SMTPHandler(
        mailhost=os.getenv('MAIL_SERVER'),
        fromaddr=os.getenv('MAIL_USERNAME'),
        toaddrs=os.getenv('BLUELOG_ADMIN_EMAIL'),
        subject='Application Error',
        credentials=(os.getenv('MAIL_USERNAME'), os.getenv('MAIL_PASSWORD')))
    mail_handler.setLevel(logging.ERROR)
    mail_handler.setFormatter(request_formatter)

```
if not app.debug:
    ...
    app.logger.addHandler(mail_handler)



```

```
- - - -

值得一提的是，除了使用传统的日志记录，我们还可以使用第三方错误追踪工具来处理程序中的错误。流行的选择是Sentry（ [http://sentry.io](http://sentry.io) ），当在程序中集成Sentry后，它可以在程序出现异常时通过我们设置的各种方式发送提醒（除了邮件，还可以集成Slack、Whatsapp、IRC等第三方工具）。更重要的是，我们可以在Sentry的控制面板中查看关于这个异常的相关代码、上下文变量的值、函数调用堆栈，以及异常触发的次数、涉及的客户端信息等一系列数据，这能够帮助我们及时找出问题的根源并解决问题。另外，使用Sentry还可以方便地为程序添加一个用户反馈功能。 

#### 14.3.5  手动导入环境变量

在开发时，因为安装了python-dotenv，使用flask run命令启动开发服务器时Flask会自动导入存储在.flaskenv或.env文件中的环境变量。在生产环境下，我们需要使用性能更高的生产服务器，所以不能再使用这个命令启动程序，这时我们需要手动导入环境变量。

我们应该尽可能地提前导入环境变量操作，这样才能确保程序中获取环境变量的代码正常工作，因此最佳的导入位置就是在wsgi.py脚本中，其次是程序包构造文件的顶部。在wsgi.py脚本中，我们使用python-dotenv提供的load_dotenv()函数手动导入.env文件中设置的环境变量，如下所示：

- - - -




```

from dotenv import load_dotenv

dotenv_path = os.path.join(os.path.dirname(file), '.env')
if os.path.exists(dotenv_path):
    load_dotenv(dotenv_path)

from bluelog import create_app
app = create_app('production')

```
- - - -

#### 14.3.6  HTTPS转发

一个可选但强烈推荐的步骤是为网站购买SSL证书，以实现对HTTP的加密传输。如果你不想购买商业SSL证书，可以尝试使用免费的证书服务，比如Let’s Encrypt（ [https://letsencrypt.org/](https://letsencrypt.org/) ）、ZeroSSL（ [https://zerossl.com/](https://zerossl.com/) ）等，你可以访问各自的文档来查看证书的申请和安装流程。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20326.png)
提示

对于部署在云平台的程序，如果不设置自定义域名，那么可以直接使用Heroku和PythonAnywhere提供的SSL证书。

设置好证书后，我们需要强制所有发到程序的请求通过HTTPS，具体的方法是拦截不安全的请求并重定向到HTTPS。这个工作可以交给扩展Flask-SSLify处理，首先使用Pipenv安装：

- - - -




```

$ pipenv install flask-sslify

```
- - - -

导入并实例化SSLify类：

- - - -




```

from flask_sslify import SSLify

sslify = SSLify()

```
- - - -

最后对sslify对象调用init_app()方法，传入程序实例app以初始化扩展：

- - - -




```

sslify.init_app(app)

```
- - - -

现在，Flask-SSLify会自动为我们的程序处理请求。我们可以通过配置键SSL_DISABLED来设置关闭SSL转发功能。因为只有当程序在生产环境下设置SSL证书后才可用，所以我们需要在配置基类中将其设为True，而在生产配置中设为False以开启SSL转发。

当程序做好一切部署准备后，我们可以将代码提交进Git仓库，并推送到远程仓库： Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

- - - -




```

 git add .
​ git commit -m "Ready for deploy"
$ git push

```
- - - -

 

### 14.4  部署到Linux服务器

传统部署就意味着我们要自己搭建一个服务器环境。在此之前，你需要做下面这些任务：

1）租用一个远程主机。租用成功后你会获得主机的IP和root密码。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20327.png)
提示

选择要安装的服务器操作系统时，建议选择Linux Ubuntu16.04.4 LTS，因为本节的操作是基于该Linux发行版的。

2）（可选）购买一个域名。域名作为互联网中唯一的标识，其他人可以通过这个域名访问到你的程序，这样就不用通过一长串无意义的数字IP来访问你的程序。流行的域名购买服务有Godaddy、NameCheap等。

3）（可选）域名解析，即把域名指向服务器所在的IP。域名提供商通常会免费提供这个功能，为了保证解析的稳定性，最好使用国内的第三方域名解析服务，比如DNSPod（ [https://www.dnspod.cn/](https://www.dnspod.cn/) ）。 

#### 14.4.1  使用OpenSSH登录远程主机

如果你不习惯使用命令行，那么这对你来说将是个坏消息：你只能通过命令行来操作远程主机。当你获取了远程主机的IP和root密码，就可以使用OpenSSH来连接服务器：

- - - -




```

$ ssh root@your_server_ip

```
- - - -

比如：

- - - -




```

$ ssh root@123.45.56.78

```
- - - -

如果你已经注册了域名并解析到对应的IP，也可以使用域名代替IP，比如：

- - - -




```

$ ssh root@helloflask.com

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20206.png)
附注

SSH（ [https://www.ssh.com/ssh/](https://www.ssh.com/ssh/) ）是一种用于远程连接Linux主机的加密协议，也是系统管理员最基本的工具之一。这里的OpenSSH（ [http://www.openssh.com/](http://www.openssh.com/) ）是基于SSH协议实现的开源程序，Ubuntu内置了这个软件。 

如果你使用Windows系统，那么可以使用PuTTY（ [http://www.putty.org/](http://www.putty.org/) ）替代，或是使用Git Bash内置的OpenSSH。 

输入密码后，你会看到类似下面的提示，因为是第一次连接，所以本地主机会请求确认远程主机的身份，输入yes按下Enter即可：

- - - -




```

The authenticity of host '128.19.128.156 (128.19.128.156)' can't be established.
ECDSA key fingerprint is SHA256:Cwwd1iOGBU17IH2wAqRrNI1yZ5o4AGfLaNPo8ZvvWIc.
Are you sure you want to continue connecting (yes/no)?

```
- - - -

现在你会看到命令行提示符变为远程主机的提示符，比如root@your server name：～$，这说明你已经成功登录了远程主机（使用exit命令可以登出）。

#### 14.4.2  安装基本库和工具

连接到远程主机后，首先更新系统可安装的包列表，并对可升级的包进行升级：

- - - -




```

 apt update
​ apt upgrade

```
- - - -

使用Root用户部署代码或运行Web服务器容易带来安全风险，我们可以创建一个新用户，并赋予其root权限（超级用户）：

- - - -




```

 adduser greyli
​ usermod -aG sudo greyli

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20328.png)
提示

（1）默认添加用户输入密码后会提示输入用户信息（比如地址电话之类），用来填充Gecos字段，这些是可选的，你可以一路按Enter跳过，或是在输入adduser命令时添加--gecos选项来关闭，即adduser --gecos""greyli。

（2）这里的greyli是示例用的用户名，你可以自由更改。在后面我们会使用greyli@123.45.67.89来作为远程主机名称示例。

现在切换到新创建的用户：

- - - -




```

$ su greyli

```
- - - -

接着需要安装必备的包和开发工具，在命令前添加sudo以执行管理员操作。如果你使用Python 2，执行下面的命令：

- - - -




```

$ sudo apt install python-dev python-pip

```
- - - -

如果你使用Python3，则使用下面的命令：

- - - -




```

$ sudo apt install python3-dev python3-pip

```
- - - -

上面命令中的python（3）-dev包含Python2/3和一些基础的包，python（3）-pip用来安装pip。安装过程中会请求输入y进行确认，你也可以在apt install命令后添加-y选项来省略这个确认。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20329.png)
提示

（1）Ubuntu 16.04LTS默认包含Python3.5和Git，所以我们不必再安装这两个程序。如果你需要使用Python2.7版本，可以通过包python-minimal来安装。

（2）访问Ubuntu包存档（ [https://packages.ubuntu.com/](https://packages.ubuntu.com/) ）可以搜索具体的包信息。 

下面使用pip3（如果你使用Python 2，这里则使用pip）安装Pipenv：

- - - -




```

$ sudo -H pip3 install pipenv

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20207.png)
附注

如果你不想全局安装，可以添加--user选项执行用户安装（即pip install --user pipenv），并手动将用户基础二进制目录添加到PATH环境变量中，具体可参考 [https://docs.pipenv.org/install/#installing-pipenv](https://docs.pipenv.org/install/#installing-pipenv) 。 

作为现实中的程序，我们还需要安装额外的程序。最基础的，我们要安装数据库服务器，比如MySQL、Postgres、Redis或是MongoDB等。除了数据库服务器，如果程序需要发送邮件，那么还要安装MTA（Mail Transport Agent，邮件传输代理），比如Sendmail（ [http://sendmail.org](http://sendmail.org) ）、Postfix（ [http://www.postfix.org/](http://www.postfix.org/) ）等。如果程序使用了Celery，还要安装RabbitMQ、Redis等。关于如何安装这些程序对应的包，并运行相应的服务器，你可以访问各自的文档进行了解。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20121.png)
注意

自己搭建一个邮件服务器比较麻烦，因为有很多棘手的问题需要考虑（垃圾邮件、病毒等）。简单的解决办法是使用第三方服务，比如SendGrid、Mailgun等。

#### 14.4.3  安全防护措施

我们要对服务器进行一些安全设置，让我们从最基本的方面入手——使用SSH密钥（SSH key）来代替密码作为认证方式。

1.使用SSH密钥登录

通过输入密码来登录远程主机比较麻烦，而且不安全，更安全和方便的做法是通过SSH密钥进行认证，为此你需要在你自己的电脑上先生成一个SSH密钥对。你可以新创建一个命令行会话，通过OpenSSH内置的ssh-keygen来生成SSH密钥对：

- - - -




```

$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/path/to/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /path/to/.ssh/id_rsa.

Your public key has been saved in /path/to/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:m+tknrZlamdmKG+7RZm6c9TZRUQp1M5StmS9P/qO+R0 ...
The key's randomart image is:
+---[RSA 2048]----+
|            ...o=|
|             . Bo|
|              O.o|
|           o . =.|
|        S +. o...|
|         =. o ...|
|        o+   .E.|
|      .+O*  .o o|
|       B%@   o++.|
+----[SHA256]-----+

```
- - - -

按下这个命令后会弹出提示符请求你输入密钥保存的路径和口令设置，你可以全部使用默认值，直接按下Enter即可。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20122.png)
注意

如果上面的命令输出/path/to/.ssh/id_rsa already exists.Overwrite（y/n）？，那么说明你已经创建密钥对，这时你可以使用已经生成的密钥，或是指定一个新的路径。如果你输入y，这将会覆盖原有的密钥，请谨慎操作。

如果你使用Windows系统，可以使用Git Bash来执行上面的操作，或是随PuTTY一起安装的PuTTYgen.exe程序来通过图形界面来生成（具体可以参考 [https://www.ssh.com/ssh/putty/windows/puttygen](https://www.ssh.com/ssh/putty/windows/puttygen) ）。生成完成后，你会得到两个保存密钥的文件： 

·id_rsa.pub：保存你的公钥（public key），可以用来提供给第三方作为你的认证凭据。

·id_rsa：保存你的私钥（private key），用来在认证时进行配对，不要公开这个文件。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20330.png)
提示

密钥默认保存到home目录（～）下的.ssh文件夹中，即～/.ssh。在Linux或macOS中类似home/greyli/.ssh，在Windows中类似C/Users/Administrator/.ssh。

现在你需要把公钥保存到远程主机上，具体来说，就是将公钥（id_rsa.pub）的内容添加到远程主机的～/.ssh/authorized_keys文件中。这可以通过好几种方式实现。最简单的方式是通过ssh-copy-id程序，输入你的远程主机地址作为参数：

- - - -




```

$ ssh-copy-id greyli@123.45.67.89
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
greyli@123.45.67.89's password:
Number of key(s) added: 1
Now try logging into the machine, with:   "ssh 'greyli@123.45.67.89'"
and check to make sure that only the key(s) you wanted were added.

```
- - - -

输入密码后，就会看到添加成功的提示。然后在远程主机中使用下面的命令给相应目录设置合适的权限：

- - - -




```

 chmod go-w ~/
​ chmod 700 ~/.ssh
$ chmod 600 ~/.ssh/authorized_keys

```
- - - -

如果你的系统中没有ssh-copy-id，那么可以手动复制。首先使用cat命令输出公钥的内容：

- - - -




```

$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABDdHrJRTBgvqG21vy3cZI9Nj...省略

```
- - - -

复制输出的公钥值备用，重新返回与远程主机建立连接的命令行窗口，输入下面几个命令：

- - - -




```

 mkdir -p ~/.ssh
​ echo 你的公钥值 >> ~/.ssh/authorized_keys
 chmod go-w ~/
​ chmod 700 ~/.ssh
$ chmod 600 ~/.ssh/authorized_keys

```
- - - -

第一条命令用来确保远程主机上的～/.ssh目录存在，如果不存在则创建；第二条命令将你的公钥值写入到对应的文件中，使用你刚刚复制的内容替换掉命令里的中文；后面的命令用来给相应的目录设置合适的权限。

现在我们不输入密码即可建立SSH连接，你可以创建一个新的命令行窗口进行测试。

2.关闭密码登录

既然我们可以不用输入密码就能登录远程主机，那么有必要关闭密码登录功能，这样可以大幅度提高安全系数。这通过编辑SSH配置文件（/etc/ssh/sshd_config）实现，我们使用内置的nano或vi文本编辑器打开对应的文件进行编辑：

- - - -




```

$ sudo nano /etc/ssh/sshd_config

```
- - - -

打开配置文件后，你需要将下面这一行中的yes改为no来关闭密码登录：

- - - -




```

# Change to no to disable tunnelled clear text passwords

PasswordAuthentication no

```
- - - -

可选的是，你还可以通过将这行的yes改为no来关闭root用户登录，这样可以进一步增强服务器安全性：

- - - -




```

PermitRootLogin no

```
- - - -

完成编辑后，可以按下Crtl+O写入，然后按下Enter确认文件路径，最后按下Crtl+X退出文本编辑器。现在重启SSH服务即可让配置生效：

- - - -




```

$ sudo service ssh restart

```
- - - -

3.设置防火墙

Ubuntu默认安装了ufw，即Uncomplicated Firewall（ [https://wiki.ubuntu.com/Uncomplicated-Firewall](https://wiki.ubuntu.com/Uncomplicated-Firewall) ），我们需要使用它来设置开放的端口： 

- - - -




```

 sudo ufw allow 22
​ sudo ufw allow 80
$ sudo ufw allow 443

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20331.png)
提示

如果你使用SMTP发送邮件，那么还需要允许SMTP使用的端口，比如25、465或587。

通过上面的命令，我们将仅开放远程主机的22端口（SSH）、80端口（HTTP）、443端口（HTTPS）。更新规则后可以使用下面的命令来开启防火墙：

- - - -




```

$ sudo ufw enable
Command may disrupt existing ssh connections. Proceed with operation (y|n)? y
Firewall is active and enabled on system startup

```
- - - -

现在你可以通过下面的命令查看防火墙的状态：

- - - -




```

$ sudo ufw status
Status: active

To                         Action      From

------

22                         ALLOW       Anywhere
80                         ALLOW       Anywhere
443                        ALLOW       Anywhere
22 (v6)                    ALLOW       Anywhere (v6)
80 (v6)                    ALLOW       Anywhere (v6)
443 (v6)                   ALLOW       Anywhere (v6)

```
- - - -

#### 14.4.4  推送代码并初始化程序环境

下一步是把我们的程序上传到服务器，这可以有很多种方式实现。因为我们将示例程序代码托管在GitHub上，所以最简单的方式还是直接从GitHub的Git服务器上复制仓库到远程主机：

- - - -




```

 cd ~
​ git clone https://github.com/greyli/bluelog.git

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20332.png)
提示

如果你在GitHub上Fork了示例程序，并在本地改造了你自己版本的程序，可以提交（git add&git commit）并推送代码（git push）到GitHub，然后在这里复制你自己版本的程序仓库（将上面的greyli替换成你的用户名）。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20208.png)
附注

GitHub的免费账户只能创建公开仓库，为此你可以考虑使用BitBucket（ [https://bitbucket.org](https://bitbucket.org) ），它提供不限数量的免费私有仓库。另外，你也可以自己创建一个Git服务器，只需要创建一个git用户，设置SSH密钥认证，创建对应的空白仓库，并在本地与远程仓库建立连接即可，具体可以访问 [https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server](https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server) 了解。 

切换进仓库目录，使用Pipenv创建虚拟环境并安装依赖，最后激活虚拟环境：

- - - -




```

 cd bluelog
​ pipenv install
$ pipenv shell

```
- - - -

在程序的配置文件中，包含敏感信息的配置都从环境变量中读取。在开发时，我们将这些环境变量定义在.env文件夹中。在部署时，为了让程序正常运行，我们需要在远程主机的项目目录中也创建一个.env文件，并将本地的.env文件内容复制到这个文件中：

- - - -




```

$ nano .env

```
- - - -

为了确保执行命令时配置和环境正确设置，我们还需要在.env文件中为FLASK_ENV变量和自定义的FLASK_CONFIG变量设置正确的值：

- - - -




```

FLASK_ENV=production
FLASK_CONFIG=production

```
- - - -

最后我们需要执行程序的初始化操作，如果你使用在第5章介绍的Flask-Migrate扩展来设置迁移环境，那么使用下面的命令还可以更新数据库：

- - - -




```

$ flask db upgrade

```
- - - -

如果没有使用Flask-Migrate，那么就使用下面的命令创建数据库表：

- - - -




```

$ flask initdb

```
- - - -

初始化程序，创建博客管理员账户：

- - - -




```

$ flask init

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20333.png)
提示

你需要在程序中导入并实例化Flask-Migrate提供的扩展类的同时进行初始化操作，具体参见第5章相关内容。

现在，我们的程序已经准备好运行了。

#### 14.4.5  使用Gunicorn运行程序

在开发时，我们使用flask run命令启动的开发服务器是由Werkzeug提供的。细分的话，Werkzeug提供的这个开发服务器应该被称为WSGI服务器，而不是单纯意义上的Web服务器。在生产环境中，我们需要一个更强健、性能更高的WSGI服务器。这些WSGI服务器也被称为独立WSGI容器（Standalone WSGI Container），因为它们可以承载我们编写的WSGI程序，然后处理HTTP请求和响应。这通常有很多选择，比如Gunicorn（ [http://gunicorn.org/](http://gunicorn.org/) ）、uWSGI（ [http://uwsgi-docs.readthedocs.io/en/latest/](http://uwsgi-docs.readthedocs.io/en/latest/) ）、Gevent（ [http://www.gevent.org/](http://www.gevent.org/) ）、Waitress（ [https://docs.pylonsproject.org/projects/waitress/en/latest/](https://docs.pylonsproject.org/projects/waitress/en/latest/) ）等。通常我们会根据程序的特点来选择，比如，对于一个小型的个人博客，使用Gevent就足够了。主流的选择是使用Gunicorn和uWSGI。在这里我们将使用Gunicorn（意为Green Unicorn），它使用起来相对简单，容易配置，而且性能优秀。我们先在远程主机中使用Pipenv安装它： 

- - - -




```

$ pipenv install gunicorn

```
- - - -

为了方便进行测试，我们可以临时设置防火墙以允许对8000端口的访问：

- - - -




```

$ sudo ufw allow 8000

```
- - - -

Gunicorn使用下面的命令模式来运行一个WGSI程序：

- - - -




```

$ gunicorn [OPTIONS] 模块名: 变量名

```
- - - -

这里的变量名即要运行的WSGI可调用对象，也就是我们使用Flask创建的程序实例，而模块名即包含程序实例的模块。在准备环节，我们已经在项目根目录下创建了一个包含生产环境下的程序实例的wsgi.py模块（如果你还没有创建，可以使用nano wsgi.py命令在这里创建），所以使用下面的命令即可运行程序：

- - - -




```

$ gunicorn --workers=4 wsgi:app

```
- - - -

在上面的命令中，我们使用--workers选项来定义worker（即工作线程）的数量。这里的数量并不是越多越好，事实上，Gunicorn只需要4～12个worker进程就可以每秒处理成百上千个请求。通常来说，worker的数量建议为（2×CPU核心数）+1。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20334.png)
提示

默认的worker类型为同步worker，作为替代，你也可以使用异步worker。要使用异步worker，你首先要安装其他异步处理库（比如gevent、eventlet、tornado），然后在命令中通过-k选项设置对应的worker类，比如gunicorn-k gevent。通常情况下，有两种情况需要使用异步worker：第一，单独使用Gunicorn运行程序时，你的程序需要处理大量并发请求。第二，当使用Web服务器作为代理运行在Gunicorn前面时，这时的并发数量并不是关键，使用同步worker即可，除非你有大量的耗时计算需要处理。

Gunicorn默认监听本地机的8000端口，这里的本地机指的是远程主机。为了能够在外部访问，我们可以使用--bind选项来设置程序运行的主机地址和端口，比如：

- - - -




```

$ gunicorn --workers=4 --bind=0.0.0.0:8000 wsgi:app

```
- - - -

上面的命令等同于：

- - - -




```

$ gunicorn -w 4 -b 0.0.0.0:8000 wsgi:app

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20209.png)
附注

如果你设置了SSL证书，那么可以通过下面的方式运行这个启动命令：$gunicorn --certfile=<证书文件>--keyfile=<证书密钥文件>--bind 0.0.0.0：443 test：app

现在打开浏览器访问服务器域名的8000端口（比如 [http://helloflask.com:8000](http://helloflask.com:8000) ）应该可以看到你的程序主页。如果你没有设置域名，那么可以通过服务器公网IP访问，比如 [http://123.45.67.89:8000](http://123.45.67.89:8000) 。确保一切正常后，按下Crtl+C停止Gunicorn，然后使用下面的命令删除创建的临时规则： 

- - - -




```

$ sudo ufw delete allow 8000

```
- - - -

通过HTTP访问程序时，80端口是服务器的默认端口， [http://helloflask.com](http://helloflask.com) 和 [http://hello-flask.com:80](http://hello-flask.com:80) 是相同的。这里测试时我们没有指定为80端口，因为1024以下的端口需要超级用户权限，我们将使用Web服务器来监听80端口，具体后面会介绍。 

#### 14.4.6  使用Nginx提供反向代理

像Gunicorn这类WSGI服务器内置了Web服务器，所以我们不需要Web服务器也可以与客户端交换数据，处理请求和响应。但内置的Web服务器不够强健，虽然程序已经可以运行，但是更流行的部署方式是使用一个常规的Web服务器运行在前端，为WSGI服务器提供反向代理，如图14-2所示。

流行的开源Web服务器有Nginx（ [http://nginx.org/](http://nginx.org/) ）、Apache（ [https://www.apache.org/](https://www.apache.org/) ）等，因为我们上面使用了Gunicorn，所以这里选择使用和Gunicorn集成良好的Nginx。首先使用下面的命令安装Nginx： 

- - - -




```

$ sudo apt install nginx

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEQ_aBAAAAANGH8V4861553098.jpg)
图14-2 设置反向代理

在这种模式下，Nginx作为代理服务器，监听来自外部的80端口的请求；而Gunicorn负责监听本地机8000端口的请求。Nginx会把来自外部的请求转发给Gunicorn处理，接收到响应后再返回给客户端。这样做有下面这些好处：

·提高处理静态文件的效率。Nginx处理静态文件的速度非常快，而且可以对静态文件设置缓存。

·提高安全系数。使用它可以避免直接暴露WSGI服务器，而且可以作为防火墙来防御网络攻击。

·提高程序处理能力。设置反向代理可以缓冲请求，对请求进行预处理，交给WSGI服务器一个完整的HTTP请求。还可以设置负载均衡，优化请求处理效率。

当使用反向代理服务器后，Gunicorn不需要再监听外部请求，而是直接监听本地机的某个端口。我们可以使用默认值，即本地机的8000端口。不过现在还不用着急运行，我们需要先来配置Nginx。

当我们安装了Nginx后，它会自动运行，现在本地访问远程主机的IP地址，会看到Nginx提供的测试页面，如图14-3所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEQXDiAAAAAAMf3U0284645588.jpg)
图14-3 Nginx测试页面

我们可以在Nginx的默认配置文件（/etc/nginx/nginx.conf）中写入程序配置，但通常情况下，为了便于组织，我们可以在/etc/nginx/sites-enabled/或是/etc/nginx/conf.d/目录下为我们的Flask程序创建单独的Nginx配置文件。这个目录下的default文件存储了上面提到的测试页面的配置，也是作为一个配置文件示例，你可以修改它来作为程序配置，但为了更直观这里我们将直接删除它，然后使用nano为我们的程序创建一个新的配置文件（编写etc/下的配置文件需要超级用户权限，因此要添加sudo）：

- - - -




```

 sudo rm /etc/nginx/sites-enabled/default
​ sudo nano /etc/nginx/sites-enabled/bluelog

```
- - - -

Nginx使用指令来组织配置。直接写在配置文件中的是全局指令，定义了Nginx的一些通用设置。其他的指令通常写在使用块指令定义的块中，块使用花括号包围。可用的块指令及其说明如表14-1所示。

表14-1 Nginx配置的常用指令

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEDvAxAAAAAHZtmCE381060762.jpg)

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20335.png)
提示

其他的语法规则包括：块通过花括号“{}”指定；每一行指令以“；”结尾；以“#”开头的是注释。

在/etc/nginx/sites-enabled目录下的配置文件可以直接定义server块，而不必添加http父块，因为这个文件的内容会被自动插入到全局配置文件（/etc/nginx/nginx.conf）的http块中。代码清单14-4是我们创建的配置定义。

代码清单14-4 /etc/nginx/sites-enabled/bluelog：Nginx配置

- - - -




```

server {
    listen 80 default_server;
    server_name _;  # 如果你映射了域名，那么可以写在这里
    access_log  /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

```
location / {
    proxy_pass http://127.0.0.1:8000;  # 转发的地址，即Gunicorn运行的地址
    proxy_redirect     off;

    proxy_set_header   Host                 $host;
    proxy_set_header   X-Real-IP            $remote_addr;
    proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto    $scheme;
}

location /static {  # 处理静态文件夹中的静态文件
    alias /home/greyli/bluelog/bluelog/static/;
    expires 30d;  # 设置缓存过期时间
}



```

}

```
- - - -

在这个server块中，listen指令设置监听80端口，然后使用server_name设置被转发请求的IP或域名，这里使用_作为通配符（catch-all）。如果你注册了域名并设置了域名解析，可以这样写前两行：

- - - -




```

server {
    listen 80;
    server_name example.com;
    ...
}

```
- - - -

在server块中我们创建两个location块。第一个location块为HTTP规则“/”设置转发，proxy_pass指定设置转发的目标位置，即本地机的8000端口，我们待会将要让Gunicorn服务器监听这个地址；proxy_set_header指令用来重写一些请求首部，以便让程序正常工作；第二个location块用来将发往/static路径下的请求发给Nginx处理，并使用alias指令设置这个URL对应文件系统中的具体路径。expires 30d设置缓存时间为30天。当客户端发来静态文件的请求时会由Nginx直接从静态文件目录获取，这要比使用Flask获取快得多。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20123.png)
注意

这时需要考虑到扩展提供的静态文件问题，因为扩展内置的静态文件目录在虚拟环境的扩展包目录下，我们需要匹配到正确的路径，这也是为什么我不推荐使用扩展内置资源的原因之一。

Nginx还有很多可用的配置选项。比如，你还可以使用它来设置Gzip压缩，这里的配置只是一个简单的示例，更多设置请访问文档（ [http://nginx.org/en/docs/](http://nginx.org/en/docs/) ）了解。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20210.png)
附注

对于HTTPS转发，除了使用Flask-SSLify扩展，也可以通过Nginx实现：在我们前面创建的配置文件中新建一个server块监听443端口，并为80端口设置转发。

更新配置文件后，我们可以通过下面的命令来测试语法正确性：

- - - -



```

$ sudo nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

```
- - - -

如果一切正常，那么现在可以重启Nginx让配置生效：

- - - -



```

$ sudo service nginx restart

```
- - - -

当使用反向代理服务器后，Gunicorn不需要再监听外部请求，而是直接监听本地机的某个端口。我们可以使用默认值，即本地机的8000端口。不过现在还不用着急运行，我们需要先来配置Nginx。

最后，我们使用下面的命令运行Gunicorn，这会默认监听本地机的8000端口，即我们在Nginx设置的转发目标地址：

- - - -




```

$ gunicorn -w 4 wsgi:app

```
- - - -

现在打开浏览器直接访问服务器域名（比如 [http://helloflask.com](http://helloflask.com) ）应该可以看到你的程序主页。如果你没有设置域名，那么可以通过服务器公网IP访问，比如 [http://123.45.67.89](http://123.45.67.89) 。 

#### 14.4.7  使用Supervisor管理进程

在前面，我们直接通过命令来运行Gunicorn，这并不十分可靠。我们需要一个工具来自动在后台运行它，同时监控它的运行状况，并在系统出错或是重启时自动重启程序，最终的部署架构如图14-4所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEXiRNAAAAAFtwvi0937905850.jpg)
图14-4 最终的部署架构

虽然可以通过创建systemd服务文件来让Ubuntu的引导系统自动启动相关服务，但更方便的是使用类似Supervisor的进程管理工具。Supervisor（ [http://supervisord.org/](http://supervisord.org/) ）是一个使用Python编写的UNIX-like系统进程管理工具，它可以管理和某个项目相关的所有服务。按下Crtl+C停止上面运行的Gunicorn，然后使用下面的命令安装Supervisor： 

- - - -




```

$ sudo apt install supervisor

```
- - - -

安装Supervisor后，它会自动在/etc/supervisor目录下生成一个包含全局配置的配置文件，名为supervisord.conf的配置文件（INI风格语法）来定义进程相关的命令等信息。和Nginx类似，我们也可以将程序相关的配置写在这里，但是为了便于管理，我们可以为程序配置创建单独的配置文件。这个全局配置默认会将/etc/supervisor/conf.d目录下的配置文件也包含在全局配置文件中，所以我们创建一个bluelog.conf存储程序配置：这个文件可以放在/etc/supervisord.conf路径下。我们使用nano来创建这个文件：

- - - -




```

$ sudo nano /etc/supervisor/conf.d/bluelog.conf

```
- - - -

它的用法和Tox很相似，通过预定义每个进程的启动命令、目录和用户等信息。我们可以简化启动的步骤。我们把上面的多个启动相关服务的命令定义在一起，如下所示：

- - - -




```

[program:bluelog]
command=pipenv run gunicorn -w 4 wsgi:app
directory=/home/greyli/bluelog
user=greyli
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true

```
- - - -

通过[program]定义一个bluelog程序，其中用command定义命令，我们在命令前添加pipenv run以便在虚拟环境中执行命令；directory和user则分别用来设置执行命令的工作目录和用户；通过将autostart和autorestart设为true开启自动启动和自动重启；将stopasgroup和killasgroup设为true则会确保在关闭程序时停止所有相关的子进程。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20336.png)
提示

通过这种方式，你可以自己添加更多的节，比如为rabbitmq和celery worker定义相应的程序。

我们在command参数定义的命令中调用了pipenv run命令，而Pipenv内部使用Click调用命令，为了让Click在Unix以及Python3环境下能够正确处理编码问题，我们需要将环境变量LC_ALL和LANG设为C.UTF-8或en_US.UTF-8，这可以在supervisord.conf配置文件中写入：

- - - -




```

$ sudo nano /etc/supervisor/supervisord.conf

```
- - - -

我们需要在[supervisord]节下添加下面这行定义：

- - - -




```

environment=LC_ALL='en_US.UTF-8',LANG='en_US.UTF-8'

```
- - - -

现在，我们可以通过下面的命令重新启动supervisor服务以便让配置生效：

- - - -




```

$ sudo service supervisor restart

```
- - - -

现在配置中的bluelog程序会在后台被自动执行，访问域名或IP即可打开程序，我们的部署流程基本上到这里就结束了。下面会简单介绍一下Supervisor管理程序的方法。

你可以通过supervisor提供的命令行工具supervisorctl来查看和操作相关程序：

- - - -




```

$ sudo supervisorctl
bluelog                 RUNNING   pid 6853, uptime 0:22:30
supervisor > stop bluelog  # 停止bluelog
supervisor > start bluelog  # 启动bluelog
supervisor > tail bluelog stderr  # 查看错误日志
...
supervisor > help  # 查看所有可用的命令

# default commands (type help <topic>):

add    exit      open  reload  restart   start   tail
avail  fg        pid   remove  shutdown  status  update
clear  maintail  quit  reread  signal    stop    version

```
- - - -

除了在supervisorctl提供的shell中输入命令，我们也可以直接为supervisorctl命令添加参数执行相关命令，比如：

- - - -




```

You can't use 'macro parameter character #' in math mode sudo supervisorctl reread  # 重新读取配置
 sudo supervisorctl update  # 更新以便让配置生效
You can't use 'macro parameter character #' in math mode sudo supervisorctl bluelog stop  # 停止bluelog
 sudo supervisorctl bluelog start  # 启动bluelog

```
- - - -

后面我们会使用这些命令来对程序进行更新操作。

除了命令行工具supervisorctl，Supervisor还提供了Web客户端，你可以通过在/etc/super-visor/supervisord.conf中写入下面的配置来开启：

- - - -




```

[inet_http_server]
port=*:9001
username=your_username  # 设置一个用户名
password=your_password  # 设置一个密码

```
- - - -

为了允许访问9001端口，我们需要设置防火墙：

- - - -




```

$ sudo ufw allow 9001

```
- - - -

现在打开浏览器访问服务器所在域名或IP的9001端口（比如 [http://123.45.67.89:9001](http://123.45.67.89:9001) ），然后输入在配置文件中设置的用户名和密码即可打开Supervisor管理页面。你可以在Web客户端中查看服务器上定义的所有Supervisor程序的运行状态，并执行相应的操作，如图14-5所示。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEVFfwAAAAAP-jYW0815330003.jpg)
图14-5 Supervisor程序管理

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20211.png)
附注

完整的配置选项请访问Supervisor的文档（ [http://supervisord.org/configuration.html](http://supervisord.org/configuration.xhtml) ）了解。 

#### 14.4.8  更新部署后的程序

更新一次程序的大致流程如下：

1）在本地更新代码。

2）通过生成虚拟数据在浏览器中手动调试。

3）调试满意后执行一系列测试。

4）测试通过后将代码推送到代码托管平台，触发持续集成服务器进行测试（可选）。

5）登录远程主机，使用git pull命令拉取更新。

6）执行必要的操作，比如更新数据库结构，安装新的依赖等。

7）重新启动Gunicorn。

我们在本地更新了程序后，首先需要将改动提交进本地Git仓库（git add&git commit），然后将改动推送（git push）到代码托管平台。在远程主机上，第5～7步对应的命令如下所示：

- - - -




```

You can't use 'macro parameter character #' in math mode git pull  # 拉取更新
 sudo supervisorctl stop bluelog  # 关闭bluelog程序
You can't use 'macro parameter character #' in math mode flask db upgrade  # 更新数据库，更新依赖等可选的操作
 sudo supervisorctl start bluelog  # 启动bluelog程序

```
- - - -

因为程序比较简单，我们手动完成了整个部署和更新流程，如果你需要将程序部署到多个服务器中，可以考虑使用Fabric（ [http://www.fabfile.org/](http://www.fabfile.org/) ）来实现部署的自动化。Fabric的作用类似能够实现测试自动化的Tox，通过将部署时需要执行的一系列命令预定义在命令函数中，并预先写入单个或多个服务器的主机地址和密码，直接执行本地命令就可以在多个主机上进行部署操作。如果你有非常多的服务器需要管理，那么可以考虑使用SaltStack（ [https://saltstack.com/](https://saltstack.com/) ）或Ansible（ [https://www.ansible.com/](https://www.ansible.com/) ）。 

当使用自动化部署工具时，我们可以在项目仓库内预先创建好所有的配置文件，比如Nginx和Supervisor的配置文件。在部署时直接执行复制操作（cp）将这些文件复制到对应的目录下。另一方面，将配置文件放到项目文件夹中可以添加到Git仓库，更便于管理和控制。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 14.5  部署到PythonAnywhere

从名字可以看出来，PythonAnywhere只提供对Python程序的支持，因此对我们的Flask程序来说，使用起来会更加方便。它支持在线编辑脚本，执行Shell命令，提供固定的硬盘存储空间（免费账户的限额为512MB），你可以把它看成一个在线的集成开发环境。因为程序可以快速部署，非常适合用来做实验。首先，你需要访问 [https://www.pythonanywhere.com/registration/register/beginner/](https://www.pythonanywhere.com/registration/register/beginner/) 注册一个免费账户。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20337.png)
提示

你在注册时输入的用户名（username）将作为为你分配的Linux用户名称，同时也会作为为你分配的域名，即https://<你的用户名>.pythonanywhere.com，后面我们将会以helloflask作为示例用户名。

#### 14.5.1  反向代理设置

在传统部署中，我们可以在Nginx的配置文件中重写请求首部。在云部署平台中，我们没有权限修改反向代理服务器的配置文件，因此可以使用Werkzeug提供的中间件ProxyFix来（第16章会介绍关于中间件的具体内容）对反向代理转发的请求进行必要的修正。在工厂函数中的程序实例创建后将程序的wsgi_app属性更新为ProxyFix类实例，传入原属性：

- - - -




```

from werkzeug.contrib.fixers import ProxyFix

app.wsgi_app = ProxyFix(app.wsgi_app)

```
- - - -

#### 14.5.2  创建PythonAnywhere程序

完成注册进入PythonAnywhere的仪表盘（Dashboard）后，可以单击Web标签中的“Create a New web application”来创建新的Web程序，如图14-6所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEGAHXAAAAAA-5zmE469431233.jpg)
图14-6 创建PythonAnywhere程序

免费账户只能创建一个程序，程序的名称即创建时填写的用户名（username）。相应地，你的程序的域名将是 [https://.pythonanywhere.com](https://&lt;your_username%3E.pythonanywhere.com) 的形式。另外，PythonAnywhere为你分配的文件目录为home/<your_username>。 

PythonAnywhere默认提供0.11和0.12版本的Flask，因为我们需要使用最新版，同时为了更灵活地定义其他设置，这里选择了手动配置，如图14-7所示。

#### 14.5.3  推送代码并初始化程序环境

在PythonAnywhere上部署程序的过程和我们在前面介绍的传统部署非常相似，不过它已经帮我们完成了包括创建Linux用户、安装WSGI服务器和Web服务器等一系列基础操作。

在Consoles标签下，我们可以创建各种类型的命令行会话：各个版本的Python和IPython、Bash、MySQL等。我们需要创建一个Bash会话（bash即Linux系统中默认的shell）来执行系统命令，如图14-8所示。

在打开的命令行窗口中，我们使用Git从GitHub上复制程序仓库：

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEFbNnAAAAAH0hmQM698533669.jpg)
图14-7 选择手动配置Web框架

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEasVXAAAAAAN2_RA674617294.jpg)
图14-8 创建Bash会话

- - - -




```

$ git clone https://github.com/greyli/bluelog.git

```
- - - -

接着我们可以使用同样的方式在项目根目录内创建一个.env文件，写入必要的环境变量值，比如SECRET_KEY（直接复制本地的.env文件内容即可）：

- - - -




```

 cd bluelog
​ nano .env

```
- - - -

为了确保执行命令时配置和环境正确设置，我们还需要在.env文件中为FLASK_ENV变量和自定义的FLASK_CONFIG变量设置正确的值：

- - - -




```

FLASK_ENV=production
FLASK_CONFIG=production

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20338.png)
提示

对于付费账户，你可以使用ssh连接你的账户（ssh<username>@ssh.pythonanywhere.com），同时也可以使用scp或WinSCP来操作文件。并且可以创建远程仓库，进行一些设置后可以在本地push代码后自动触发程序更新并重载。

#### 14.5.4  创建数据库

如果部署的程序不使用数据库，或是使用SQLite，你可以直接跳过本节。PythonAnywhere提供MySQL和PostgreSQL两种选项，免费账户可以使用MySQL。在仪表盘的Database标签下为MySQL设置一个密码，然后MySQL服务器会自动运行，如图14-9所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEN5gZAAAAAOG8UBQ238653495.jpg)
图14-9 初始化MySQL

创建完成后，你会看到MySQL服务器的各类信息，如图14-10所示。

在重定向后的页面，你可以看到数据库的主机地址、用户名、数据库名称，通过这些信息可以构建数据库URI。在程序中，我们需要更新配置变量SQLALCHEMY_DATABASE_URI的值，以便让SQLAlchemy可以连接数据库服务器，因为生产配置中的这个值首先从环境变量DATABASE_URL读取，所以你可以在.env中定义这个值。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEcyYoAAAAAERbvTc871716455.jpg)
图14-10 查看MySQL连接信息

#### 14.5.5  设置虚拟环境

继续回到前面打开的Bash页面，我们首先要安装Pipenv：

- - - -




```

$ pip3 install --user pipenv

```
- - - -

因为我们没有sudo权限，除了在虚拟环境中执行安装外，在使用pip安装Python包时，需要添加--user选项。下面执行一些常规的命令，具体作用不再赘述：

- - - -




```

 cd bluelog
​ pipenv install
 pipenv shell
​ flask db upgrade
$ flask init

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20339.png)
提示

如果没有使用Flask-Migrate，那么就使用flask initdb命令创建数据库表，替代掉flask db upgrade命令。

在创建虚拟环境后，我们需要在Web标签下设置虚拟环境的路径，如图14-11所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEI8KDAAAAAM8sqMw610380662.jpg)
图14-11 编辑虚拟环境位置

你可以使用下面的命令获取项目对应的虚拟环境路径：

- - - -




```

$ pipenv --venv

```
- - - -

#### 14.5.6  静态文件

与我们在14.4.6节中使用Nginx来加载静态文件一样，这里也需要告诉PythonAnywhere我们的静态文件目录，以便直接使用反向代理服务器加载。和我们在Nginx中为静态文件创建的location块类似，我们需要在Web标签下的Static files部分添加URL和对应的文件路径，如图14-12所示。

#### 14.5.7  运行和更新程序

在运行程序之前，我们要修改PythonAnywhere提供的WSGI配置文件，导入我们的程序实例，类似我们在准备环节创建的wsgi.py。这个文件在创建PythonAnywhere程序时，就已经创建好了。事实上，你也必须在PythonAnywhere为你创建的WSGI文件中创建或导入程序实例，并将程序实例命名为application。WSGI服务器会读取这个文件，获取这个变量对应的WSGI可调用对象。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEKCZfAAAAAMwLE2w812590528.jpg)
图14-12 设置静态文件

在Web标签下的Code部分，单击“WSGI configuration file”对应的链接打开这个文件进行编辑。这个文件中原有的内容是一个默认的WSGI程序和一些示例说明，你可以全部删掉，然后创建下面的内容：

- - - -




```

import sys

path = '/home/helloflask/bluelog'
if path not in sys.path:
    sys.path.append(path)

from wsgi import app as application

```
- - - -

因为这个WSGI文件并不在我们项目的根目录中，而是在var/www/目录下，我们需要先将项目所在的路径添加到系统路径（sys.path）中，这样我们可以直接从项目根目录下的wsgi.py模块中导入app实例并重命名为application。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20340.png)
提示

如果你的项目中没有提前创建wsgi.py文件，作为替代，你也可以直接在这里从bluelog包导入工厂函数create_app()，然后调用工厂函数创建程序实例并传入production配置名称，注意要将程序实例命名为application。

单击右上角的Save按钮即可保存更改，如图14-13所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEbqJKAAAAAMawC8U669598068.jpg)
图14-13 编辑WSGI配置文件

因为在上面设置了虚拟环境和静态文件映射规则，我们需要先重载程序，单击Web标签下的“Reload<your application url>”按钮，这时访问 [https://<username>.pythonanywhere.com](https://username.pythonanywhere.com) 应该就能看到程序的主页了。如果出现错误，你可以访问Web标签下的Log部分查看对应的错误日志（Error log）。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20212.png)
附注

免费账户需要每三个月单击一次Web标签下的“Run until 3 months from today”按钮来激活程序。

当需要更新程序时，与在Linux部署部分介绍的内容相同。我们在本地更新了程序后，首先需要将改动提交进本地Git仓库（git add&git commit），然后将改动推送到代码托管平台。在远程主机上，我们使用git pull命令拉取代码，然后执行数据库更新等必要的操作，最后单击Reload按钮重启程序即可完成更新。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20213.png)
附注

免费账户不能建立SMTP连接（发往Gmail服务器除外），也就是说，除了使用Gmail的外部SMTP服务器，我们只能使用事务邮件服务（SendGrid、Mailgun等）的Web API来发送邮件（通过HTTP/HTTPS），具体可以参考第6章的相关内容。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 14.6  部署到Heroku

Heroku是比较老牌的PaaS，建立于2007年，也是目前最成熟、完善的PaaS之一。它支持多种编程语言，而且提供了丰富的第三方服务（Add-ons），这会让你的程序具有很高的灵活度。它提供的文档非常完善，可以让你很快上手。在此之前，你需要访问 [https://heroku.com/](https://heroku.com/) 注册一个Heroku的免费账户。Heroku提供了多种方式来部署程序，比如使用Git部署、容器部署、通过连接到GitHub仓库或Dropbox部署，本节将会介绍其中的两种主要方式：使用Heroku Git部署本地程序和从GitHub部署。 

首先，我们需要在项目的根目录中添加一个Procfile文件。这个文件用来指定运行程序的命令，使用<process type>：<command>的形式来定义一个进程，每个进程一行。最基本的是web进程类型，它用来指定执行启动Web服务器的命令，我们在这里指定Gunicorn的运行命令，文件内容如下所示：

- - - -




```

web: gunicorn wsgi:app --log-file -

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20341.png)
提示

因为Heroku从stdout和stderr收集日志，所以这里将--log-file选项设为“-”以便让Gunicorn的日志输出到stdout。

#### 14.6.1  通过Heroku Git部署

Heroku CLI（Heroku Command Line Interface）是Heroku提供的用于执行部署等操作的命令行工具，使用它可以完成几乎所有的操作。macOS系统可使用Homebrew安装：

- - - -




```

$ brew install heroku/brew/heroku

```
- - - -

Linux Ubuntu可以使用下面的命令安装：

- - - -




```

$ sudo snap install heroku

```
- - - -

Windows和其他系统可以通过下载安装包进行安装，具体可以访问 [https://cli.heroku.com/](https://cli.heroku.com/) 了解。 

为了验证安装是否成功，我们可以使用下面的命令查看Heroku CLI版本：

- - - -




```

$ heroku --version
heroku-cli/6.0.0-010a227 (darwin-x64) node-v8.0.0

```
- - - -

现在使用heroku login命令登录Heroku，输入你在注册账户时设置的邮箱地址和密码：

- - - -




```

$ heroku login
Enter your Heroku credentials.
Email: greyli@example.com
Password: ***
Logined as greyli@example.com

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20214.png)
附注

执行heroku help可以查看所有可用的命令。

1.创建Heroku程序

登录成功后，确保当前工作目录在要部署的项目的根目录下并且包含一个Git仓库，然后使用heroku create命令可以创建一个Heroku程序：

- - - -




```

$ heroku create
Creating app... done, ? sleepy-meadow-81798
https://sleepy-meadow-81798.herokuapp.com/ | https://git.heroku.com/sleepy-meadow-81798.git

```
- - - -

Heroku会为你随机分配一个程序名，然后返回为程序分配的域名和在Heroku提供的Git服务器中为程序创建的Git远程仓库地址。分配的程序域名将被用来访问程序，通过程序名称构建，形式为 [https://<程序名>.herokuapp.com](https://%E7%A8%8B%E5%BA%8F%E5%90%8D.herokuapp.com) ，比如 [https://helloflask.herokuapp.com](https://helloflask.herokuapp.com) 。 

你可以在heroku create命令后附加参数来自定义创建的程序名称，比如我们将用来作为示例的helloflask：

- - - -




```

$ heroku create helloflask
Creating helloflask... done
https://helloflask.herokuapp.com/ | https://git.heroku.com/helloflask.git

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20342.png)
提示

因为程序名称会作为域名的子域名部分，所以可能会出现重名不可用的情况，这时会显示“Name is already taken”，你可以多试几个名字。免费账户最多可以创建5个程序，你可以执行heroku apps命令查看所有已创建的程序。

create命令会为当前目录下的Git仓库设置一个名为heroku的远程仓库，对应你的程序在Heroku的Git服务器上的远程仓库。

除了通过命令行创建程序，你也可以通过Heroku的Web界面（ [https://heroku.com](https://heroku.com) ）完成这些工作。如果你已经通过Web界面创建了程序，那么可以使用下面的命令手动为本地仓库添加Heroku远程仓库，使用-a选项指定程序名称： 

- - - -




```

$ heroku git:remote -a helloflask

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20124.png)
注意

因为我们当前目录的Git仓库已经和heroku程序所在的远程仓库建立关联，所以在运行heroku命令时不必指定操作的目标程序，否则需要使用-a或--app选项来给出程序的名称作为命令执行的目标程序，后面不再提示。

2.临时文件系统

在Heroku中，程序运行在被称为Dyno的容器中，每个Dyno都会建立一份程序文件的拷贝（免费账户只有1个Dyno可用），因此无法保证文件数据的一致性，所以每个Dyno停止运行后会直接清除掉相关文件。也就是说，除了我们使用Git提交的文件除外，所有在Heorku上运行程序过程中创建的文件将不会永久保存，而且会在一天内被重置。对于这种情况，我们需要采取下面的措施来避免出错：

·因为SQLite使用文件作为数据库，无法持久化写入文件的数据，我们需要使用Heroku提供的数据库服务来替代SQLite。

·生成迁移环境和迁移脚本的操作始终在本地执行，也就是在本地执行flask db init（只需要执行一次）和flask db migrate命令，当代码提交到Heroku上后，再执行flask db upgrade。

·用户上传文件使用Heroku提供的存储服务或是其他第三方文件存储服务。

·日志输出到stderr和stdout，以便写入到Heroku的日志系统。

·将.env提交到Git仓库，以便推送到Heroku上，仅适用于私有仓库。

对于第2条和第4条，我们已经在14.3节完成了，第3条暂不需要。我们将在下一节介绍如何使用Heroku提供的免费的PostgreSQL服务。

3.设置数据库

Heroku支持通过Add-on（扩展）来为程序接入其他服务，免费账户可以使用Heroku提供的PostgreSQL数据存储，最多可用10 000行数据。使用下面的命令添加免费的hobby-dev类型的PostgreSQL Addon：

- - - -




```

$ heroku addons:create heroku-postgresql:hobby-dev
Creating heroku-postgresql:hobby-dev on ? helloflask... free
...

```
- - - -

hobby-dev类型的数据库存在诸多限制，比如最高可以使用10 000行数据（当数据超过7000行后会收到提示邮件），最大连接数为20。使用heroku pg命令可以查看数据库的详情：

- - - -




```

$ heroku pg
=== DATABASE_URL
Plan:                  Hobby-dev
Status:                Available
Connections:           0/20
PG Version:            10.3
Created:               2018-05-08 03:12 UTC
Data Size:             7.6 MB
Tables:                0
Rows:                  0/10000 (In compliance)
Fork/Follow:           Unsupported
Rollback:              Unsupported
Continuous Protection: Off
Add-on:                postgresql-transparent-20461

```
- - - -

添加成功后，我们可以通过heroku config命令查看程序的环境变量，其中有包含数据库URL的DATABASE_URL变量：

- - - -




```

$ heroku config
=== helloflask Config Vars
DATABASE_URL: postgres://oiaukivyycqqhg:035dc6737931bb939643628f907a301190ba01d62387043b5001c1835a00dbcc@ec2-54-235-204-221.compute-1.amazonaws.com:5432/d8tr8lgcsk0j

```
- - - -

不过我们并不需要直接把数据库URL写入配置，因为Heroku会把这个URL保存在Heroku的系统环境变量DATABASE_URL中，所以我们可以在程序中直接读取这个值。在Bluelog以及其他几个示例程序中，生产配置均会优先从DATABASE_URL环境变量读取数据库URL，所以程序不需要做出改动：

- - - -




```

basedir = os.path.abspath(os.path.dirname(file))
dev_db = 'sqlite:///' + os.path.join(basedir, 'data.db')
...
SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URL', dev_db)

```
- - - -

另外，使用config：set命令也可以为Heroku程序所在的远程运行环境设置环境变量，比如：

- - - -




```

$ heroku config:set MAIL_USERNAME=greyli@example.com

```
- - - -

如果你没有把.env提交到Git仓库，那么就需要使用这种方式来设置相应的环境变量。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20215.png)
附注

你也可以使用Addon添加其他服务，比如用于发送电子邮件的SendGrid和Mailgun等（Heroku也支持使用外部SMTP服务器，比如Gmail等）。另外，如果你要使用Celery，可以使用作为Addon的RabbitMQ。

使用heroku addons命令可以查看程序添加的所有addon：

- - - -




```

$ heroku addons

```
- - - -

4.本地测试

Heroku提供了本地运行功能，我们可以模拟一个真实的Heroku线上运行环境。虽然这一步不是必须的，但是建议你先进行本地测试，这样可以避免不必要的Bug，本地运行会让调试错误更加方便。尤其是对于已经部署过的程序，在更新之前进行实际的运行测试非常重要。

本地测试的第一步是安装在Heroku上运行程序所需要的依赖：

- - - -




```

$ pipenv install gunicorn psycopg2

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20343.png)
提示

在Heroku的服务器上运行程序时同样需要这些依赖，所以确保使用pipenv安装，它会自动把这两个包加入Pipfile中。

上面的命令分别安装Gunicorn和PostgreSQL的Python接口库——Psycopg2。为了在本地测试，我们还需要安装并运行PostgreSQL服务器，访问PostgreSQL网站的下载页面（ [https://www.postgresql.org/download/](https://www.postgresql.org/download/) ）了解更多信息。安装并运行PostgreSQL服务器后，我们需要把PostgreSQL服务器运行的URL设为环境变量DATABASE_URL的值。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20344.png)
提示

如果你使用Linux系统，需要安装libpq-dev系统包。

接着，使用pipenv shell命令激活虚拟环境，并执行创建数据库等初始化操作：

- - - -




```

 pipenv shell
​ flask db upgrade # 如果没有使用Flask-Migrate 则使用flask initdb
$ flask init

```
- - - -

在Linux或macOS系统中，使用下面的命令运行程序：

- - - -




```

$ heroku local web

```
- - - -

因为Gunicorn不支持Windows系统，我们需要使用Flask内置的开发服务器来运行程序。为此你需要编写一个Procfile.windows文件，它和Procfile类似，不过包含Windows系统特定的启动命令，如下所示：

- - - -




```

web: flask run

```
- - - -

然后使用下面的命令运行程序：

- - - -




```

$ heroku local web -f Procfile.windows

```
- - - -

现在，你可以访问 [http://localhost:5000](http://localhost:5000) 查看程序是否正常运行，如果一切正常，就可以准备推送代码到Heroku上了。 

5.推送代码

使用git remote命令可以查看当前本地仓库的远端，添加-v显示详细地址：

- - - -




```

$ git remote -v
heroku https://git.heroku.com/helloflask.git (fetch)
heroku https://git.heroku.com/helloflask.git (push)

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20345.png)
提示

如果你的程序同时托管在GitHub或BitBucket上，你还可以在上面命令的输出中看到这些平台建立的远程仓库，一般会命名为origin。

因为Heroku为我们的程序创建了远程Git仓库，所以我们在推送代码时不必在使用其他代码托管平台中转，而是直接推送到Heroku上的Git远程仓库：

- - - -




```

$ git push heroku master
...
remote: -----> Python app detected
remote: -----> Installing pip
remote: -----> Installing dependencies with Pipenv 11.8.2…
remote:        Installing dependencies from Pipfile.lock (b3ae48)…
remote: -----> Discovering process types
remote:        Procfile declares types -> web
remote: -----> Launching...
remote:        Released v5
remote:        https://helloflask.herokuapp.com/ deployed to Heroku
remote: Verifying deploy... done.

```
- - - -

代码推送后，Heroku会自动尝试构建程序，首先会识别项目中的Pipfile或requirements.txt文件，并尝试从这两个文件中寻找依赖并安装。最后使用Procfile文件中使用web指定定义的命令来启动Web服务器。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20125.png)
注意

因为Heroku会自动处理环境隔离、依赖安装等工作，我们必须在Pipfile或require-ments.txt中列出所有的依赖。如果你没有进行本地测试，那么需要手动将运行程序所需的gunicorn和psycopg2依赖包添加到Pipfile中的[packages]节下，同时还要使用pip-env lock命令更新Pipfile.lock文件。

Heroku默认使用的Python解释器版本为Python-3.6.4，如果你需要使用Python2，可以在Pipfile中使用[requires]节指定被支持的Python2版本：

- - - -




```

[requires]
python_full_version = "2.7.14"

```
- - - -

在使用Pipenv时，我们可以通过pipenv run<command>命令在虚拟环境下执行命令，类似的是，我们可以使用heroku run<command>命令来执行Heroku远程命令。我们现在已经把程序推送到了Heroku上的Git远程仓库，这里使用heroku run执行命令的当前目录就是我们的Heroku程序的项目根目录。

现在使用下面的命令创建并更新数据库表：

- - - -




```

 heroku run flask db upgrade
Running flask db upgrade on helloflask... \ starting, run.4654 (Free)
...
​ heroku run flask init
...

```
- - - -

除了使用heroku run命令，我们也可以执行bash命令打开一个完整的远程命令行会话，与建立SSH连接类似（使用exit命令退出）：

- - - -




```

$ heroku run bash
Running bash on helloflask... - starting, run.6426 (Free)

```
- - - -

最后使用下面的命令重启程序：

- - - -




```

$ heroku restart

```
- - - -

现在访问程序的域名（即 [https://程序名.herokuapp.com](https://%E7%A8%8B%E5%BA%8F%E5%90%8D.herokuapp.com) ）应该可以看到程序已经在运行了，你也可以使用下面的命令快速使用默认的浏览器打开： 

- - - -




```

$ heroku open

```
- - - -

Heroku使用dyno hour来作为计算程序资源用量的单位，每月有550小时的免费额度。因为免费账户只可以使用1个Dyno，也就意味着程序可以持续运行550个小时。使用heroku ps命令可以查看当前剩余的dyno hour额度：

- - - -




```

$ heroku ps
Free dyno hours quota remaining this month: 550h 0m (100%)
=== web (Free): gunicorn wsgi:app --log-file - (1)
web.1: up 2017/12/02 18:19:21 +0800 (~ 6m ago)

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20216.png)
附注

Heroku上免费账户创建的程序运行时使用的Dyno类型为Web Dyno，这种类型的Dyno如果30分钟内没有流量产生，会进入休眠状态（唤醒操作会造成一些延迟），休眠状态不会消耗资源额度。

6.查看日志

如果程序没有正常运行，你可以通过heroku logs命令查看日志：

- - - -




```

$ heroku logs

```
- - - -

默认显示100条日志，使用--num选项可以指定数量，最高为1500条。我们也可以使用下面的命令查看实时的日志输出（使用Crtl+C退出）：

- - - -




```

$ heroku logs --tail

```
- - - -

7.部署更新

当我们在本地更新了程序后，我们首先需要将改动提交到本地Git仓库（git add&git com-mit），然后就可以使用git push命令将改动推送到Heroku上对应的远程仓库：

- - - -




```

You can't use 'macro parameter character #' in math mode heroku maintenance:on # 开启维护，这时访问程序会显示维护页面
 git push heroku master # 推送代码
You can't use 'macro parameter character #' in math mode heroku restart # 重启程序
 heroku maintenance:off # 关闭维护

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20346.png)
提示

确保将改动添加到Git仓库（git add）并提交（git commit），这样改动才会推送（git push）到Heroku上。

其中的heroku maintenance命令用来设置显示/关闭默认的维护页面。

#### 14.6.2  使用GitHub部署

除了使用Heroku CLI和Git在本地部署，我们还可以直接使用GitHub部署。确保你的程序仓库内包含Procfile文件，并且Pipfile中包含Gunicorn和Psycopg2，Pipfile.lock也保持同步（手动更改Pipfile后需要使用pipenv lock命令更新），而且数据库连接优先从环境变量DATABASE_URL读取。

当我们的程序推送到GitHub后，我们可以访问Heroku的Web页面，登录账号后依次单击“New”和“Create new app”打开创建程序页面，输入程序名称后即可创建一个Heroku程序，创建后在仪表盘的deploy标签中选择“GitHub”选项，然后单击Connect to GitHub按钮，如图14-14所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCELj3fAAAAAJphNhQ631500633.jpg)
图14-14 连接到GitHub

在弹出的页面同意授权后，我们可以在页面中的“Deployment method”部分输入仓库名称进行搜索，并在相应的仓库右侧单击“Connect”按钮建立连接，如图14-15所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCETt_AAAAAAO9o9KA647927810.jpg)
图14-15 选择程序仓库

建立连接后，我们可以在“Automatic deploys”部分设置开启自动部署。开启后，每当仓库有变动时，Heroku会自动把变动集成到运行的程序中。你还可以勾选Wait for CI to pass before deploy选项，这样只有通过仓库设置的CI测试的推送才会被部署到程序中。最后单击“Manual deploy”部分的“Deploy Branch”按钮即可部署对应分支的程序，如图14-16所示。

单击部署后，Heroku会自动读取仓库中的Procfile文件，并直接从requirements.txt或Pipfile文件中安装依赖，页面下方会显示部署过程的日志输出。部署成功后会显示“Your app was successfully deployed.”，你可以单击“View”按钮或直接输入URL来访问程序。

当使用GitHub部署时，设置程序名称、设置数据库、添加add-ons、查看日志等操作可以在Web端完成。如果你愿意，也可以使用Heroku CLI，这时需要使用--app或-a选项在执行命令时通过Heroku程序名指定程序：

- - - -




```

$ heroku logs -a <app name>

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEetIHAAAAALFEWjg007072759.jpg)
图14-16 设置并部署程序 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 14.7  下一步做什么？

恭喜你，不管使用哪种方式，现在你的程序已经部署上线了。尽管如此，我们的工作还没有结束，比如，首先你还需要考虑SEO（Search Engine Optimization，搜索引擎优化）问题。如何让搜索引擎更快更全面地收录你的网站，以便让你的网站在相关关键字的搜索结果中靠前显示。下面是一些最基础的工作：

1）在HTML页面中添加必要的meta标签，比如keyword、description等。

2）在Google和Baidu等搜索引擎主动提交网站，申请收录（这通常会涉及验证网站所有权等步骤）。

3）添加一个sitemap.xml文件（即站点地图），在文件中列出程序中所有可以访问的URL列表。你可以参考这个snippet（ [http://flask.pocoo.org/snippets/108/](http://flask.pocoo.org/snippets/108/) ）创建，或是使用Flask-SiteMap扩展（ [https://github.com/inveniosoftware/flask-sitemap](https://github.com/inveniosoftware/flask-sitemap) ）。搜索引擎的爬虫（爬取网络上内容的程序）会解析这个文件，你也可以手动提交。 

4）添加一个robots.txt（ [http://www.robotstxt.org/](http://www.robotstxt.org/) ）文件，和sitemap.xml的作用相反，这个文件用来告诉搜索引擎的内容爬虫不要收录哪些资源。比如，你肯定不想让用户在搜索引擎上的相关结果中看到后台管理的登录页面。下面是一个示例： 

- - - -




```

User-agent: *
Disallow: /admin
Disallow: /upload

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20217.png)
附注

和robots.txt相关联的还有一个humans.txt（ [http://humanstxt.org/](http://humanstxt.org/) ），它的动机是为了注明制作网站/程序的作者，算作是网站的Credits部分。你可以访问 [https://www.google.com/humans.txt](https://www.google.com/humans.txt) 查看Google的hunmans.txt文件。 

我们可以把robots.txt、humans.txt以及sitemap.xml等文件放到程序static文件夹的根目录。不过，这些文件都需要直接通过网站域名根目录访问到，比如 [http://example.com/robot.txt](http://example.com/robot.txt) ，而我们程序默认的静态文件URL为/static，所以我们需要单独创建一个视图来提供（serve）这些文件，比如： 

- - - -




```

@app.route('/robots.txt')
@app.route('/sitemap.xml')
def static_from_root():
    return send_from_directory(app.static_folder, request.path[1:])

```
- - - -

除了搜索引擎优化，你还可以考虑进行UEO（User Experience Optimization，用户体验优化）。UEO的方式有很多，随着移动设备越来越多，最基本也要对程序进行移动端优化。你可以使用Google提供的LightHouse（ [https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/) ）对页面性能进行分析。 

另外，一般的IaaS和PaaS服务提供商都会提供Web监控数据，用来查看CPU、硬盘、网络、系统负载等数据。如果你想自己搭建监控系统，可以考虑使用开源的Icinga2（ [https://www.icinga.com/products/icinga-2/](https://www.icinga.com/products/icinga-2/) ）、Nagios（ [https://www.nagios.org/](https://www.nagios.org/) ），或是在线监控服务DataDog（ [www.datadoghq.com](http://www.datadoghq.com) ）等。 

最后，你还需要收集用户数据（流量统计与分析），这通常会使用第三方服务，比如Google Analytics（ [https://analytics.google.com/](https://analytics.google.com/) ）、百度统计（ [https://tongji.baidu.com](https://tongji.baidu.com) ）等。通过以用户的视角分析使用程序的方式，可以有针对性地调整程序的功能。日志包含用户访问的数据，也是研究用户行为以改进网站和程序的重要资料，你可以使用日志分析服务来进行分析，比如Splunk（ [https://www.splunk.com/](https://www.splunk.com/) ）。 

网站优化通常不是一步到位的，正确的做法是在网站上线后根据需要来逐渐进行有针对性的优化。事实上，把程序部署上线只是一个开始。关于服务器的架构设计和维护包含大量知识和技巧，你需要阅读其他书籍来进一步学习。我们在13章介绍的缓存、静态资源以及数据库等方面也可以在部署后通过各种方式进行优化。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 14.8  本章小结

从写下第一行代码到把一个程序部署上线，整个过程就像是历经艰辛终于把孩子抚养成人。是的，You are Online。不管你是否感到激动，你都为互联网添加了一个新成员。

扩展虽然不是Flask的核心内容，但在Flask开发中却是不可或缺的一部分，下一章我们会通过一个真实的扩展实例来学习Flask扩展的编写。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

## 第15章

## Flask扩展开发

扩展和我们编写的程序很相似。事实上，Flask扩展就是Python库，只不过它使用“Flask的语言”说话。比如，它也像我们的程序一样使用Flask提供的诸多功能：它们可以创建蓝本，获取配置，加载静态文件，使用上下文全局变量。只要你熟悉了Flask，Flask扩展的编写对你来说并不是难事。

Flask扩展通常分为两类：一类是纯功能的实现，比如提供用户认证功能的Flask-Login；另一类是对已有的库和工具的包装，比如Flask-SQLAlchemy就包装了SQLAlchemy。我们本章要学习编写的扩展就属于后一种，这种扩展可以理解为“胶水”或“适配器”，它让其他的Python库或JavaScript库与Flask程序更方便结合，简化了集成操作，并提供一些有用的辅助功能。

本章新涉及的Python包如下所示：

·setuptools（39.0.1）

·主页： [https://github.com/pypa/setuptools](https://github.com/pypa/setuptools) 

·文档： [https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/) 

·wheel（0.31.0）

·主页： [https://github.com/pypa/wheel](https://github.com/pypa/wheel) 

·文档： [https://wheel.readthedocs.io](https://wheel.readthedocs.io) 

·twine（1.11.0）

·主页： [https://github.com/pypa/twine](https://github.com/pypa/twine) 

·文档： [http://twine.readthedocs.io](http://twine.readthedocs.io) 

·readme_renderer（20.0）

·主页： [https://github.com/pypa/readme_renderer](https://github.com/pypa/readme_renderer) Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 15.1  扩展的命名

编写扩展的第一步，就是起个好名字。抛开代码质量不说，一个简单、易记的名称会吸引更多的人来使用和参与开发。一般情况下，对于集成第三方库的扩展会使用第三方库名称来命名，比如我们将要编写的Flask-Share扩展集成了JavaScript库share.js（ [https://github.com/overtrue/share.js](https://github.com/overtrue/share.js) ），它的主要作用就是允许你在模板中创建社交分享（social share）组件，如图15-1所示。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEPfjdAAAAABaP3VA305781927.jpg)
图15-1 在页面上添加社交分享组件

按照既成的约定，扩展的名称使用“Flask-<功能/第三方库名>”或是“<功能/第三方库名>-Flask”的形式，这两部分以连字符相连，比如Flask-Share和Frozen-Flask。而扩展的包名称则是小写加下划线的形式，而且必须是“flask_<名称>”的形式，比如flask_share。包名称就是我们在使用时在Python脚本中导入的名称。

因为扩展需要注册并上传到PyPI后才可以使用pip或Pipenv等工具安装，所以起名字前最好确保所选的名字没有被注册。我们可以事先在 [https://pypi.org](https://pypi.org) 上进行搜索，已经被注册的名称无法被再次注册。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20218.png)
附注

目前还没有遗弃包的回收机制，这个机制有望在PEP 541（ [https://www.python.org/dev/peps/pep-0541/](https://www.python.org/dev/peps/pep-0541/) ）被接收后建立。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 15.2  扩展项目骨架

一个扩展，在项目文件层面就是一个Python开源项目。对于一个最小的项目来说，唯一必需的只有程序脚本和setup.py。但是为了便于开发和协作，其他文件也是必不可少的。一般来说，扩展项目由下面这些文件组成：

·存储扩展代码的程序包或模块（必需）

·setup.py（必需）

·示例程序

·文档

·测试脚本或包

·README（说明文档）

·LISCENCE（许可证文件）

·CHANGES（版本变更记录）

·.gitignore

·……

如果扩展需要使用静态文件或模板，那么我们需要在程序包内像其他Flask项目一样创建static和templates文件夹。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20219.png)
附注

完整的开源项目应该包含开源许可证。开源许可证（license）是开源项目的授权许可协议，规定了对于项目可以做和不可以做的事情。Flask社区建议扩展使用BSD、MIT等相对宽松的协议，关于各个协议的比较可以在这个网站上了解： [https://choosealicense.com/](https://choosealicense.com/) 。许可证文件一般无后缀名，但也可添加.txt等后缀。 

通常情况下，我们会开源Flask扩展，以吸引更多的人参与开发。在本章，我们编写的扩展会使用Git进行版本控制，并将代码托管在GitHub上。如果你还不熟悉如何创建、参与开源项目，可以通过 [https://opensource.guide/](https://opensource.guide/) 学习。 

使用GitHub可以方便地创建一个开源项目。注册并登录Github后，单击右上方导航栏的“+”图标，然后选择New repository（新仓库）打开创建新仓库页面，如图15-2所示。

我们在仓库创建页面设置项目的名称、描述，并选择相应的.gitignore文件以及许可证。如果勾选了“Initialize this repository with a README”选项，这会在初始化项目仓库时添加一个README.md文件（使用Markdown语法），用于撰写项目概况。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20220.png)
附注

README是开源项目的自述文件，它常常会包含项目的介绍、使用方法示例、作者信息等内容。一份好的README可以帮助使用者快速上手，也会吸引潜在的贡献者参与项目。

创建成功后，可以从Github上把项目仓库复制到本地：

- - - -




```

$ git clone https://github.com/greyli/flask-share.git

```
- - - -

我们将使用包来组织程序，从一开始就使用Python包组织程序可以让你更容易适应逐渐扩大的程序规模，而且可以支持在包内提供静态资源。切换进flask-share文件夹后，我们创建一个flask_share文件夹，在文件夹内创建一个__init__.py文件，这会让flask_share变成包，我们的代码将存储在__init__.py文件中。其他的文件我们会在后面一步步创建。

在扩展的开发中，我们仍然使用Pipenv来管理依赖，首先在项目根目录创建虚拟环境：

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEIlAsAAAAAIb_6xY004338109.jpg)
图15-2 在Github上创建项目仓库

- - - -




```

 pipenv install
​ pipenv shell

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20221.png)
附注

（1）如果你想快速创建一个新的扩展，那么可以使用PyPA提供的示例项目（ [https://github.com/pypa/sampleproject](https://github.com/pypa/sampleproject) ），它包含了一个Python项目的基本结构。 

（2）PyPA指Python Packaging Authority（ [https://www.pypa.io/](https://www.pypa.io/) ），是一个维护众多和Py-thon打包相关的项目的工作组。我们在前面使用的pip、Pipfile、virtualenv、Setuptools以及下面要介绍的readme_render、twine等项目都是由该小组创建并维护的，具体项目列表可参考Github上的账户主页： [https://github.com/pypa](https://github.com/pypa) 。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 15.3  编写扩展类

在大多数情况下，扩展需要创建一个类来实现集成机制，并通过实例化这个类获得的扩展对象来提供主要的功能接口。在编写程序时，当我们要使用某个扩展，我们通常会实例化扩展类，并传入程序实例app以进行初始化。所谓的初始化就是进行一些基本设置，比如获取程序的配置，设置Jinja2环境，向模板上下文中添加变量或是注册各类处理函数等，进行这些操作无一例外都需要获取程序实例。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20347.png)
提示

如果不需要进行初始化操作，那么扩展也可以不创建扩展类。

在扩展类的构造方法中，我们接收程序实例app作为参数。为了支持工厂模式（使用工厂函数创建程序实例），我们要创建一个init_app()方法，它同样接收app作为参数。在构造方法中，我们将app参数默认值设为None，而且不会直接执行初始化操作，而是调用init_app()方法，并传入app。这样无论是实例化时传入程序实例，还是在工厂函数中对扩展类实例调用init_app()方法传入程序实例，最终执行的操作都会保持一致，一个典型的示例如代码清单15-1所示。

代码清单15-1 flask_share/__init__.py：创建扩展类

- - - -




```

class Share(object):
    def init(self, app=None):
        if app is not None:
            self.init_app(app)

```
def init_app(self, app):
    pass  # 初始化操作



```

```
- - - -

在init_app()方法中，我们通常第一个执行的初始化操作是将扩展添加到app.extensions属性中。从0.7版本开始，Flask在程序实例上提供了一个app.extensions字典，可以用来存储扩展特定的状态，比如数据库引擎、发信服务器配置的对象等。当某个扩展A依赖于另一个扩展B时，在扩展A中也可以通过这个字典来判断是否已经完成了扩展B的初始化。

app.extensions字典的键必须是扩展名后一部分的小写形式，比如“flask_share”扩展的键必须是“share”。为了支持0.7以前的版本，需要在设置字典前检查是否存在这个属性，如果不存在就先创建，如代码清单15-2所示。

代码清单15-2 flask_share/__init__.py：注册扩展到app.extensions字典

- - - -




```

class Share(object):
    ...
    def init_app(app):
        ...
        if not hasattr(app, 'extensions'):
            app.extensions = {}
        app.extensions['share'] = self

```
- - - -

这样，我们在其他地方需要获取状态信息时，就可以使用current_app.extensions['share']获取。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20348.png)
提示

和扩展类一样，将扩展类添加到app.extensions字典也不是必需的。

因为社交组件在模板中创建，我们需要提供用于生成HTML代码的方法，为了让这个方法可以在模板中调用，我们需要在init_app()方法中把扩展类添加到模板上下文中：

- - - -




```

class Share(object):
    ...
    def init_app(self, app):
        ...
        app.jinja_env.globals['share'] = self

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20349.png)
提示

这里使用app.jinja_env.globals字典将扩展类设置为模板全局对象share。根据我们在第3章介绍的创建模板全局变量/上下文变量的多种方法，你也可以单独创建一个方法，然后附加app.context_processor装饰器，更简单的做法是直接作为方法并搭配lambda使用：app.context_processor（lambda：{'share'：self}）。

在Flask-Share中我们把扩展类同时作为实现主要功能的类。为了更好地解耦扩展功能，你也可以把实际的程序功能使用另一个类实现。比如，我们使用Share作为实现扩展主要机制的类。另外再创建一个ShareComponent类，用来实现创建社交分享组件的功能，并把它添加到模板上下文中。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 15.4  添加扩展配置

为了方便组织，并避免与其他扩展或用户自定义的配置发生冲突，我们一般在扩展的配置变量名称前加入包含扩展名称的前缀，比如Flask-Share使用的三个变量SHARE_SITES、SHARE_MOBILE_SITES和SHARE_HIDE_ON_MOBILE均使用SHARE作为前缀。这三个配置变量在init_app()方法中设置默认值，如代码清单15-3所示。

代码清单15-3 flask_share/__init__.py：设置配置默认值

- - - -




```

class Share(object):
    ...
    def init_app(app):
        ...
        app.config.setdefault('SHARE_SITES', 'weibo, wechat, douban, facebook, twitter, google, linkedin, qq, qzone')
        app.config.setdefault('SHARE_MOBILE_SITES', 'weibo, douban, qq, qzone')
        app.config.setdefault('SHARE_HIDE_ON_MOBILE', False)

```
- - - -

当扩展类Share被实例化，或是init_app()方法被调用时，这些配置变量会被设置默认值，并添加到app.config字典中。这些配置的具体作用下面会详细介绍。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20350.png)
提示

Python字典的setdefault方法和get方法很相似，都可以获取一个键的值，并且提供第二个参数作为默认值。但和get()不同的是，如果字典中没有对应的键（即用户没有自行设置这个配置变量），setfault()会使用第二个参数的默认值作为值来把这个键值对添加到字典中。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 15.5  实现扩展功能

单纯使用share.js时，需要进行下面的两步在页面上加入一个社交分享组件：

1）加载JavaScript和CSS文件。

2）在页面HTML文件中添加一个div元素，将class属性设置为“social-share”，并通过data-*属性来进行配置。。

为了让它在Flask程序中更方便使用，我们将通过扩展Flask-Share提供下面这些功能：

1）在模板中提供load()方法资源。

2）在模板中提供create()方法创建社交分享组件。

3）提供各种配置变量来对社交分享组件进行自定义。

另外，为了优化在移动设备上的体验，我们还要提供在移动设备上隐藏社交组件的设置。下面让我们来一步步实现这些功能。

#### 15.5.1  加载静态资源

对于扩展要集成的对象，如果是Python库，那么我们只需要在setup.py中将其列为安装依赖；如果是JavaScript库，我们则需要在模板中加载资源。

对于后者来说，如果不需要额外的设置，那么加载资源的操作最好交由用户（开发者）自己实现。为了方便开发，我们可以创建一个附加的load()方法，用来在模板中生成加载资源的代码，如代码清单15-4所示。

代码清单15-4 flask_share/__init__.py：创建load()方法

- - - -




```

class Share(object):
    ...
    @staticmethod
    def load(css_url=None, js_url=None):
        if css_url is None:
            css_url = 'https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css'
        if js_url is None:
            js_url = 'https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js'
        return Markup('''<link rel="stylesheet" href="%s" type="text/css">\n

            <script src="%s"></script>''' % (css_url, js_url))

```
- - - -

简单来说，这个load()方法会返回包含CSS文件URL的<link>标签和包含JavaScript文件URL的<script>标签。这里使用了Markup类将返回的字符标记为安全字符，避免被Jinja2转义。

默认情况下，资源将会从CDN加载。作为替代选项，用户也可以在使用laod()方法时传递参数css_url和js_url来指定资源的URL。更进一步，你也可以在load()方法中接收version参数来设置资源的版本。

为了便于开发，我们也可以在扩展中提供静态资源。和普通的Flask程序相同，我们在程序包flask_share目录下新建一个static文件夹，下载对应的资源保存到static目录下，然后在扩展对象Share的init_app()方法中创建一个蓝本来提供资源，如代码清单15-5所示。

代码清单15-5 flask_share/__init__.py：在init_app()方法中创建蓝本

- - - -




```

class Share(object):
    def init(self, app=None):
        if app is not None:
            self.init_app(app)

```
def init_app(self, app):

    blueprint = Blueprint('share', __name__, static_folder='static' ,
        static_url_path='/share' + app.static_url_path))
    app.register_blueprint(blueprint)



```

```
- - - -

在实例化蓝本类时，我们将蓝本的名称设为share，并使用static_url_path关键字指定了静态文件的URL规则，因此这些文件的路径将以/share/static开头。像往常一样，我们使用app.register_blueprint()方法将蓝本对象blueprint注册到程序实例上。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20351.png)
提示

因为用户通过实例化Flask类时传入static_url_path参数可以自定义静态文件路径，这里为了和用户的设置保持一致，使用app.static_url_path属性拼接，即'/share'+app.static_url_path。

为了支持用户设置是否使用内置资源，我们添加一个名为SHARE_SERVE_LOCAL的配置变量，默认为False：

- - - -




```

app.config.setdefault('SHARE_SERVE_LOCAL', False)

```
- - - -

最后，我们在load()方法中添加一个if判断，如果用户将这个配置设为True，就加载static目录下的静态资源：

- - - -




```

@staticmethod
    def load(css_url=None, js_url=None):
        if current_app.config['SHARE_SERVE_LOCAL']:
            css_url = url_for('share.static', filename='css/share.min.css')
            js_url = url_for('share.static', filename='js/share.min.js')
        ...

```
- - - -

注意，为了能够支持多个程序实例，我们在这里通过全局对象current_app获取config字典。在其他方法中也需要使用current_app，而不是在init_app()方法创建一个self.app属性。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20126.png)
注意

获取蓝本下的资源要在端点前添加蓝本名称，即share.static。

#### 15.5.2  创建分享组件

创建社交分享组件的实质就是在HTML模板中添加一段HTML代码，并根据配置值对这段代码进行相应地调整，我们创建一个create()方法，用于返回创建社交组件的HTML代码，如代码清单15-6所示。

代码清单15-6 flask_share/__init__.py：创建create()方法

- - - -




```

class Share(object):
    ...
    @staticmethod
    def create(title='', sites=None, mobile_sites=None, align='left', addition_class=''):
        if sites is None:
            sites = current_app.config['SHARE_SITES']
        if mobile_sites is None:
            mobile_sites = current_app.config['SHARE_MOBILE_SITES']
        return Markup('''<div class="social-share %s" data-sites="%s" data-mobile-sites="%s" align="%s">%s</div>
        ''' % (addition_class, sites, mobile_sites, align, title))

```
- - - -

为了更灵活地定制分享组件，我们在create()方法中接收sites和mobile_sites参数来设置显示的分享站点以及在移动设备上显示的分享站点，这个参数值会优先于对应的配置变量的值。另外，我们还添加了title、align和addition_class参数，它们分别用于设置分享组件左侧的文字、分享组件的对齐方式以及附加的样式类。在模板中，只需要调用这个方法即可创建分享部件，比如本章图片中的社交组件即可通过下面的代码创建：

- - - -




```

{{ share.create(title='分享到：') }}

```
- - - -

#### 15.5.3  在移动设备上隐藏

这些分享按钮在移动设备上的使用体验并不是很好。以Twitter为例，因为这些按钮调用了Web端的分享API，在移动设备的浏览器中单击它会跳转到Twitter的网站（ [https://twitter.com](https://twitter.com) ），而不是手机中安装的Twitter客户端。share.js本身并没有提供在移动设备上隐藏分享组件的功能，我们可以在扩展中添加这个功能。 

在Flask中，要判断一个请求是否是发自移动设备，最简单的办法就是读取请求报文中的User Agent信息。Flask（Werkzeug）把User Agent的值解析在request.user_agent属性中，而通过request.user_agent.platform属性则可以查看请求客户端的平台信息。我们创建一个包含所有移动设备平台名称的正则表达式，然后使用请求的request.user_agent.platform值与之匹配，如果匹配成功，就说明请求发自移动设备，如代码清单15-7所示。

代码清单15-7 flask_share/__init__.py：判断请求的设备类型

- - - -




```

class Share(object):
    ...
    @staticmethod
    def create(title='', sites=None, mobile_sites=None, align='left', addition_class=None):
        if current_app.config['SHARE_HIDE_ON_MOBILE']:
            platform = request.user_agent.platform
            mobile_pattern = re.compile('android|fennec|iemobile|iphone|opera (?:mini|mobi)')
            m = re.match(mobile_pattern, platform)
            if m is not None:
                return ''
        ...

```
- - - -

移动设备隐藏通过配置变量SHARE_HIDE_ON_MOBILE控制，一旦这个配置设为True，并且当前请求的platform参数匹配成功，create()方法就会返回空字符串，从而起到了隐藏分享组件的效果。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 15.6  开源发布前的准备

现在，我们已经基本完成了扩展的编写，但是离能够开源发布还需要做一些工作。作为一个开源项目，为了让它易于使用和维护，注释、文档、示例等基本元素不可或缺。

#### 15.6.1  添加文档字符串与注释

为了方便其他开发者和未来的自己阅读代码，我们给代码添加了文档字符串和注释，如代码清单15-8所示。

代码清单15-8 flask_share/__init__.py：添加文档字符串和注释

- - - -




```

"""
    Flask-Share

```
    Create social share component in Jinja2 tempalte based on share.js.
    :copyright: (c) 2017 by Grey Li.
    :license: MIT, see LICENSE for more details.
"""
import re

from flask import current_app, url_for, Markup, Blueprint, request

class Share(object):
    def __init__(self, app=None):
        if app is not None:
            self.init_app(app)

```
def init_app(self, app):
    blueprint = Blueprint('share', name)
    app.register_blueprint(blueprint)

​    if not hasattr(app, 'extensions'):
​        app.extensions = {}
​    app.extensions['share'] = self

    # default settings
​    app.config.setdefault('SHARE_SERVE_LOCAL', False)
​    app.config.setdefault('SHARE_SITES', 'weibo, wechat, douban, facebook, twitter, google, linkedin, qq, qzone')
​    app.config.setdefault('SHARE_MOBILE_SITES', 'weibo, douban, qq, qzone')
​    app.config.setdefault('SHARE_HIDE_ON_MOBILE', True)

@staticmethod
def load(css_url=None, js_url=None, serve_local=False):
    """Load share.js resources.

​    :param css_url: if set, will be used as css url.
​    :param js_url: if set, will be used as js url.
​    :param serve_local: if set to True, the local resource will be used.
​    """
​    ...

@staticmethod
def create(title='', sites=None, mobile_sites=None, align='left', addition_class=None):
    """Create a share component.

​    :param title: the prompt dispalyed on the left of the share component.
​    :param sites: a string that consist of sites, separate by comma.
​                supported site name: weibo, wechat, douban, facebook, twitter, google, linkedin, qq, qzone.
​                  for example: 'weibo, wechat, qq'.
​    :param mobile_sites: the sites displayed on mobile.
​    :param align: the align of the share component, default to 'left'.
​    :param addition_class: the style class added to the share component.
​    """
​    ...


```

```
- - - -

当然，尽管我们在介绍上推后了这部分内容，但实际上添加文档字符串和注释的工作是和开发同步进行的。


提示

这里的文档字符串使用了基于Sphinx的reStructureText格式，以便于使用Sphinx自动提取文档字符串生成格式良好的API文档。

#### 15.6.2  编写README与文档

关于README和文档的安排有两种情况：

1）当项目非常小的时候，如果在README中就可以概括所有必需的内容，那么可以不提供单独的文档。

2）如果项目比较大/复杂，我们就要考虑编写详细的文档，最好分多个文件来组织文档的内容。这时的README就可以不介绍具体的安装、使用等内容，而是给出文档等资源的地址。对于Python项目，我们通常使用Sphinx+Github+Readthedocs的工作流来编写和部署文档。


提示

除了将文档部署到Read the Docs（ https://readthedocs.org ）上，另一个选择是使用Python社区提供的文档部署服务 https://pythonhosted.org/ ，不过Python社区目前已计划取消文档托管服务，这个网站也将会被弃用，请考虑把文档转移到Read the Docs上。 

README应该尽量简单，只需要简明扼要地介绍一下项目，然后附上相关的链接。Flask-Share的README介绍了这个扩展的安装并提供了一个简单的示例，具体可以在项目的Github仓库页面查看（ https://github.com/greyli/flask-share ）。在GitHub中，项目根目录下的README文件将会显示在项目的GitHub主页上，同时支持Markdown和reStructureText格式。 

除了README和文档，我们还可以添加其他可选的文件，比如编写贡献注意事项的CONTRIBUTING，记录项目版本变化的CHANGES，记录贡献者的CONTRIBUTORS，或是记录待办事项的TODO等。


提示

这里的相关文件最好使用reStructureText格式，这样在文档里可以直接引用这些文件内容。

#### 15.6.3  为打包做准备

为了便于分发程序，我们必须对项目进行打包（packaging），这是让你的程序可以使用pip、Pipenv或其他工具从PyPI安装的必要步骤。Python包通常使用setuptools进行打包（packaging），它是标准库distutils模块的增强版，也是目前Python社区推荐的打包工具。


附注

（1）本小节仅介绍打包的简单流程，关于Python项目打包与分发的详细教程，可以在 https://packaging.python.org/ 上看到。另外，你还可以访问setuptools的官方文档查看详细用法。 

（2）如果你使用Python 2>=2.7.9或Python 3>=3.4，那么setuptools已经安装好了；安装pip时，setuptools会被作为依赖被安装；当使用Pipenv或virtualenv创建虚拟环境时也会自动安装setuptools，因此不用手动安装。

1.创建setup.py

在打包之前，你要在项目的根目录下创建一个setup.py文件。大多数Python包都有一个setup.py文件，这个文件定义了Python包的元数据，比如包的版本、名称、作者信息等。更重要的是，通过setup.py可以对打包安装等行为进行非常详细的配置。Flask-Share中的setup.py如代码清单15-9所示。

代码清单15-9 setup.py：安装脚本

- - - -



```

"""
    Flask-Share

```

​    Create social share component in Jinja2 template based on share.js.
​     (c) 2017 by Grey Li.
​    :license: MIT, see LICENSE for more details.
"""
from os import path
from codecs import open
from setuptools import setup

basedir = path.abspath(path.dirname(file))

# Get the long description from the README file

with open(path.join(basedir, 'README.md'), encoding='utf-8') as f:
    long_description = f.read()

setup(
    name='Flask-Share',  # 包名称
    version='0.1.0',  # 版本
    url='https://github.com/greyli/flask-share',
    license='MIT',
    author='Grey Li',
    author_email='withlihui@gmail.com',
    description='Create social share component in Jinja2 template based on share.js.',
    long_description=long_description,
    long_description_content_type='text/markdown',  # 长描述内容类型
    platforms='any',
    packages=['flask_share'],  # 包含的包列表
    zip_safe=False,
    test_suite='test_flask_share',
    include_package_data=True,
    install_requires=[
        'Flask'
    ],
    keywords='flask extension development',
    classifiers=[
        'Development Status :: 3 - Alpha',
        'Environment :: Web Environment',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: MIT License',
        'Programming Language :: Python',
        'Programming Language :: Python :: 2',
        'Programming Language :: Python :: 2.7',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.3',
        'Programming Language :: Python :: 3.4',
        'Programming Language :: Python :: 3.5',
        'Programming Language :: Python :: 3.6',
        'Topic :: Internet :: WWW/HTTP :: Dynamic Content',
        'Topic :: Software Development :: Libraries :: Python Modules'
    ]
)

```
- - - -

首先你需要从setuptools中导入setup()函数，然后使用一系列关键字参数来指定包的元数据和选项。setup()函数的主要参数及说明如表15-1所示。

表15-1 setup()函数主要参数及说明

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEOSiaAAAAAB2x278197183950.jpg)

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20355.png)
提示

完整可用的分类词列表在 [https://pypi.python.org/pypi?%3Aaction=list_classifiers](../Text/https://pypi.python.org/pypi?%3Aaction=list_classifiers) 可以看到。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20223.png)
附注

开源项目的版本一般用两种约定规则，一种是常规的语义化格式：“主版本号.子版本号.修正版本号，具体可以参考Semantic Versioning 2.0.0（ [http://semver.org/](../Text/http://semver.org/) ）。另一种是使用日期来作为版本号，即CalVer（Calendar Versioning），比如2018.5.8，我们前面使用过的pytz、Pipenv、Ubuntu等项目都采用这种版本命名方式，具体可以访问 [https://calver.org/](../Text/https://calver.org/) 了解。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20356.png)
提示

packages参数是要安装的包的列表，包括子包。如果程序结构复杂，包含多个子包，可以使用setuptools提供的find_packages()函数来自动寻找包。你需要从setuptools中导入这个函数，然后将它的调用赋给packages，即“packages=find_packages()”。

值得特别提及的是参数install_requires的用法，它可以用来声明Python包的安装依赖，虽然和Pipfile很相似，但并不是重复事物。首先，我们应该区分两个容易被误解的概念：程序（application）和库（library），前者是库的消费者，比如我们编写的Web程序；后者则为程序或其他库提供服务，比如Flask。install_requires定义了Python包的最小化的抽象依赖（abstract），不需要固定版本号，它通常被用于在各类工具库（library）中，比如Flask或是我们编写的Flask-Share。而Pipfile/Pipfile.lock包含所有的具体依赖（concrete）和固定的版本号，可以用来复现完整可用的程序运行环境，通常被用来在特定的程序中，比如我们编写的SayHello等程序。

除了install_requires，我们还可以使用test_requires参数指定测试时的依赖，因为我们在test_suite参数中给出了我们的测试模块，后面我们可以使用下面的命令运行测试：

- - - -




```

$ python setup.py test

```
- - - -

另外，extra_requires可以用来定义额外依赖。因为Pipenv的使用还不够普及，如果你想让使用传统方式的开发者也可以方便地参与开发，除了使用Pipenv生成requirements.txt文件外，可以将开发依赖同时声明到extra_requires参数中。这个参数通过字典中的键来定义额外依赖的组名称和对应的依赖列表，比如：

- - - -




```

extras_require={
        'dev': [
            'coverage',
            'flake8',
            'tox',
        ],
 },

```
- - - -

安装时，只需要在包名称后添加“[dev]”即可同时安装dev键对应的额外依赖列表：

- - - -




```

$ pip install -e ".[dev]"

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20357.png)
提示

完整的参数列表可以在 [http://setuptools.readthedocs.io/en/latest/setuptools.xhtml#metadata](../Text/http://setuptools.readthedocs.io/en/latest/setuptools.xhtml#metadata) 上看到。 

当你使用pip show命令查看某个Python包的信息时，或是访问Python包的PyPI页面时看到的信息就是在setup.py中定义的。

扩展上传到PyPI页面后，会拥有一个项目页面，我们在setup.py脚本中填写的大部分信息会被解析显示在项目页面。以Flask-Share在PyPI上的主页（ [https://pypi.org/project/Flask-Share/](https://pypi.org/project/Flask-Share/) ）为例，如图15-3所示。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEFt-0AAAAAFfn-0o738329001.jpg)
图15-3 PyPI页面与setup.py脚本的关系

从图15-3中可以看出，PyPI页面的主体介绍内容是long_description参数的值。如果要显示的内容较少，可以直接写在setup.py脚本的文档字符串中（即脚本最上方使用三个双引号括起来的文本），然后将long_description参数指定为__doc__变量。

在代码清单15-9中，我们读取README.md文件的内容作为long_description参数的值。需要注意的是，默认情况下，PyPI会将long_descripion的值作为reStructureText格式渲染，如果不支持则渲染为纯文本。因为我们的README使用的是Markdown格式，这里需要添加一个额外的long_description_content_type参数，将长描述的内容类型设为Markdown：

- - - -




```

long_description_content_type='text/markdown',

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20127.png)
注意

为了支持使用Markdown格式的长描述，确保将setuptools，wheel和twine更新到本章开头列出的版式或是最新版本。

如果你使用reStructureText格式的README作为long_description的值，需要注意，PyPI使用的reStructureText解析器并不是Sphinx，所以你要使用标准的reStructureText语法。为了确保渲染为期望的效果，我们可以使用readme_renderer包对reStructureText格式的README进行检查，首先使用Pipenv安装：

- - - -




```

$ pipenv install readme_renderer --dev

```
- - - -

然后运行下面的命令进行检查：

- - - -




```

$ python setup.py check -r -s
running check

```
- - - -

如果没有错误输出，那么说明一切正常。

2.添加包数据

除了程序包中的Python脚本，还有其他文件我们希望也一并被打包，比如模板文件和静态文件。最简单灵活的方式是创建一个MANIFEST.in文件来指定这些数据，如下所示：

- - - -




```

graft flask_share/static
include LICENSE test_flask_share.py

```
- - - -

文件中包含的test_flask_share.py是我们的单元测试文件，后面会具体介绍。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20128.png)
注意

当使用MANIFEST.in文件指定包数据时，我们需要在setup()方法中将参数include_package_data需要被设为True。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20358.png)
提示

当使用setuptools打包项目时，不用显式地声明加入README，因为在打包时它会自动将README、setup.py、setup.cfg和MANIFEST.in添加进去。

在manifest文件中，我们使用“命令目录名/文件模式”的形式来声明一条文件规则，可用的命令如表15-2所示。

表15-2 manifest文件命令

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXCEPhbQAAAAAK-4nzQ131677543.jpg)

#### 15.6.4  编写示例程序

为了方便用户快速了解扩展的用法并且体验扩展的实际效果，我们有必要提供一个简单的示例程序。示例程序通常在一开始是作为开发扩展时的调试程序，被存储在程序包的example或examples文件夹里。

测试实例程序时需要导入扩展，因此可以先在本地安装扩展，创建好setup.py脚本后，使用下面的命令即可在本地安装程序包：

- - - -




```

$ pipenv install <path>

```
- - - -

因为我们的程序包是在当前目录下，可以使用“.”来表示当前目录：

- - - -




```

$ pipenv install -e .

```
- - - -

其中-e是--editable选项的简写，这个选项用来开启开发模式。开发模式是指在安装包的同时允许对代码进行修改，而不用重复进行安装。当安装程序时，通过install_requires参数指定的依赖包会同时被自动安装。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20359.png)
提示

（1）在激活虚拟环境的情况下，上面两个命令分别相当于python setup.py install和python setup.py develop命令，你可以输入python setup.py --help-commands查看所有可用的命令。

（2）示例程序仅需要包含在Git仓库中，不需要被打包，因此不用在MANIFEST.in文件中列出。

#### 15.6.5  编写单元测试

为了确保扩展Flask-Share可以按照预期工作，我们需要编写相应的单元测试。test_flask_share.py脚本中包含了几个简单的测试，如代码清单15-10所示。

代码清单15-10 flask-share/test_flask_share.py：单元测试

- - - -




```

import unittest

from flask import Flask, render_template_string, current_app

from flask_share import Share

class ShareTestCase(unittest.TestCase):

```
def setUp(self):
    self.mobile_agent = {'HTTP_USER_AGENT': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) \
    AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1'}

    app = Flask(__name__)
    app.testing = True
    self.share = Share(app)

    @app.route('/')
    def index():
        return render_template_string('{{ share.load() }}\n{{ share.create() }}')

    self.context = app.app_context()
    self.context.push()
    self.client = app.test_client()

def tearDown(self):
    self.context.pop()
...
def test_create_on_mobile(self):
    current_app.config['SHARE_HIDE_ON_MOBILE'] = True
    response = self.client.get('/', environ_base=self.mobile_agent)
    data = response.get_data(as_text=True)
    self.assertIn('social-share.min.js', data)
    self.assertNotIn('<div class="social-share', data)



```

```
- - - -

这些测试都非常简单，所以出于篇幅的考虑没有全部列出来。唯一值得介绍的是最后一个测试，它会测试移动设备客户端发起请求时分享组件的隐藏功能。

我们首先在setUp()方法中做了这些工作：创建一个测试用的程序实例，初始化扩展，添加了一个简单的视图函数，创建测试客户端，推送程序上下文。在test_create_on_mobile()方法里，我们使用测试客户端的get()方法发起GET请求，这里传入了一个environ_base参数来覆盖默认的WSGI环境的默认值。对应的self.mobile_agent是一个字典，HTTP_USER_AGENT对应的值是iPhone的User Agent字符串。

除了单元测试，项目中还要进行测试覆盖率和PEP8检查。Coverage.py同时支持将配置存储在setup.cfg文件中。不过在这个文件中，需要将第12章介绍的[run]改为[coverage：run]以包含完整的命令。另外Flake8也支持将配置写到setup.cfg，所以我们可以统一将这两个工具的配置写在setup.cfg中。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20224.png)
附注

setup.cfg是针对setup.py的配置文件，它可以对setup.py支持的命令进行配置（要查看所有的命令可执行$setup.py --help-commands）或设置其他选项值。当配置命令时，被中括号括住的是对应的命令，下面的键值对则是配置参数和对应的值。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20360.png)
提示

当测试项目增多时，你可以使用Tox（ [https://github.com/tox-dev/tox](https://github.com/tox-dev/tox) ）来简化测试流程。使用Tox可以对各类测试的依赖、命令等进行预定义，并在不同的Python版本下创建虚拟环境测试包的安装和其他各类测试，另外还可以与CI系统集成，你可以在项目仓库中查看Tox的配置文件tox.ini。对于开源项目，使用在线的CI系统会让开源协作更加轻松，Flask-Share使用与GitHub集成并对开源项目免费的Travis-CI实现持续集成，具体的配置文件travis.yml可以在项目仓库中查看。 

现在，开发工作已经基本完成了，下面我们会学习如何把它发布到PyPI上。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 15.7  发布到PyPI

在前面的开发中，当我们需要安装某个扩展时，只需要打开命令行，输入pipenv install或是pip install和扩展的名称，然后按下Enter键，比如：

- - - -




```

$ pip install < 扩展名>

```
- - - -

我们当前也希望自己编写的扩展也可以通过这种方式进行安装，这就是我们本节要完成的工作。

#### 15.7.1  创建PyPI账号

为了能够把Python包（也就是我们的扩展）上传到PyPI，我们首先要注册一个PyPI账号。访问 [https://pypi.org/](https://pypi.org/) ，在导航栏右侧单击Register并填写注册表单，完成Email验证后即可完成注册。 

为了避免每次进行包上传和更新操作时都需要输入用户名和密码，我们可以在本地创建一个.pypirc文件存储PyPI账户和密码，这会在上传包时用到。这个文件需要放在$HOME/.pypirc，Linux和macOS系统的文件位置存储在系统根目录下，即～/.pypirc；在Windows系统一般存储在Administrator文件夹下，即C：\Users\Administrator\.pypric。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20225.png)
附注

.pypric文件可以使用任意文本编辑器创建，在Windows系统中也可以使用记事本程序创建。

文件的内容示例如下所示：

- - - -




```

[distutils]
index-servers =
    pypi

[pypi]
username:用户名
password:密码

```
- - - -

你需要在对应的位置填写你的PyPI用户名和密码，下面是一个虚拟的例子：

- - - -




```

[distutils]
index-servers =
    pypi

[pypi]
username:greyli
password:mypassword

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20129.png)
注意

这会将密码以明文的形式保存，请注意限制对该文件的访问权限，以确保密码不会泄露。作为替代，你也可以考虑使用keyring（ [https://github.com/jaraco/keyring](https://github.com/jaraco/keyring) ）存储敏感数据。 

#### 15.7.2  使用setuptools打包

创建了setup.py脚本后，我们就可以使用setuptools提供的多个命令进行打包，打包的格式一般有三种：Egg、Source Distribution和Wheel，它们打包后的文件后缀分别为.egg、.tar.gz和.whl。目前Egg已不推荐使用，取代它的Wheel是目前Python官方推荐的新一代打包格式，具体内容定义在PEP 427（ [https://www.python.org/dev/peps/pep-0427](https://www.python.org/dev/peps/pep-0427) ）。和其他两种格式相比，Wheel有很多优点。比如，Wheel在打包时会对包进行构建，所以安装时就省去了这个过程，安装速度比Source Distribution格式更快。 

Wheel包有三种类型：纯Python Wheel、平台Wheel和通用Wheel。这是因为Wheel是进行提前构建后生成的二进制文件，根据代码对Python2、Python3的兼容性以及是否使用了C扩展，Wheel会生成特定Python版本或操作系统的文件，这部分内容具体可以参考 [https://packaging.python.org/tutorials/distributing-packages/#wheels](https://packaging.python.org/tutorials/distributing-packages/#wheels) 。当使用Pipenv或virtualenv创建虚拟环境时也会自动安装wheel，因此不用手动安装（如果没有使用虚拟环境，可以通过pip install wheel命令安装）。 

为了让程序能够在各种版本的操作系统、Python中使用pip安装，我们最好同时提供Source Distribution和Wheel两种格式。当使用pip安装包时，会优先使用Wheel包，如果没有Wheel包或版本和当前的Python版本或操作系统不匹配，则使用Source Distribution包。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20226.png)
附注

目前大部分主流的Python包都提供了Wheel包文件，具体信息可以在 [https://python-wheels.com/](https://python-wheels.com/) 上看到。 

使用下面的命令创建Source Distributions包：

- - - -




```

$ python setup.py sdist

```
- - - -

使用下面的命令创建Wheel包：

- - - -



```

$ python setup.py bdist_wheel

```
- - - -

一般在使用时，我们会合并这两个打包命令，即：

- - - -



```

$ python setup.py sdist bdist_wheel

```
- - - -

这会在你的项目文件夹中创建一个dist文件夹，然后分别生成这两种格式的包文件，这就是我们后面要上传到PyPI的包文件。

如果要打包的程序同时支持Python2和Python3且没有在Python中使用C扩展（即纯Python），那么可以在上面的bdist_wheel命令后加入——universal选项，这会创建一个“Universal Wheels”（通用Wheel）。因为我们的扩展同时支持Python2和Python3，而且没有使用C扩展，所以可以加入这个参数。为了避免后面每次发布新版本打包时都需要手动输入这个参数，我们可以在setup.cfg文件吸入这个选项，如下所示：

- - - -



```

[metadata]
license_file = LICENSE

[bdist_wheel]
universal = 1

```
- - - -

这个文件使用INI风格语法，bdist_wheel节表示为bdist_wheel命令设置配置，universal=1则表示开启universal参数。额外添加的metadata节用来设置元数据，将license_file选项设为开源许可证文件名可以将其打包进wheel包中。

#### 15.7.3  使用twine上传

twine是一个用来与PyPI交互的实用工具，目前它支持注册项目和上传分发包。使用它可以替代旧的python setup.py upload上传方式，因为它使用HTTPS连接，所以会更加安全。我们先安装它：

- - - -




```

$ pipenv install twine --dev

```
- - - -

上传过程非常简单（如果是第一次上传，twine会自动注册项目），只需要一行命令：

- - - -




```

$ twine upload dist/*

```
- - - -

这会上传我们在dist目录下生成的包文件。稍等一会儿，你就可以使用链接 [https://pypi.org/project/<扩展名称>/](https://pypi.org/project/%E6%89%A9%E5%B1%95%E5%90%8D%E7%A7%B0/) 访问上传后的PyPI项目主页，比如 [https://pypi.org/project/Flask-Share](https://pypi.org/project/Flask-Share) 。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20361.png)
提示

如果你担心实际的操作失误会影响到包的发布，也可以先使用Test PyPI（ [https://test.pypi.org/](https://test.pypi.org/) ）进行测试，这是Python社区提供的测试版本的PyPI站点。具体可以参考 [https://packaging.python.org/guides/using-testpypi/](https://packaging.python.org/guides/using-testpypi/) 。 

现在将项目文件添加到Git仓库，并推送到GitHub远程仓库：

- - - -




```

 git add .
​ git commit -m "Ready for first release"
$ git push

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20362.png)
提示

在实际的开发中，你应该分成多个commit来提交文件创建和变动，即每次创建文件和修改文件后执行git add和git commit命令。

然后创建一个Git标签（Tag），标签的名称使用扩展初始版本的版本号，即“0.1.0”，最后推送到GitHub：

- - - -




```

 git tag –a 0.1.0 –m "Bump version number to 0.1.0"
​ git push origm 0.1.0 # 或使用git push --tags 推送所有标签

```
- - - -

这会在Github自动生成一个Release，如图15-4所示。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 15.8  编写良好的扩展

一个合格的Flask扩展至少应该符合下面的要求：

·命名符合规范（Flask-Foo或Foo-Flask）。

·使用相对宽松的开源许可证（MIT/BSD等）。

·支持工厂模式（添加init_app()方法）。

·支持同时运行的多程序实例（使用current_app获取程序实例）。

·包含setup.py脚本，并列出所有安装依赖。

·包含单元测试

·编写文档并在线发布

·上传到PyPI

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXCEP3OwAAAAAIF7uvo576042216.jpg)
图15-4 在GitHub上创建Release

扩展有很多种类别，这里我们使用的例子是一个集成JavaScript库的简单扩展，但我们已经了解了编写Flask扩展的通用知识。在编写扩展的过程中，我们可以向其他扩展学习。除了本书中提及的扩展外，你还可以到PyPI（ [https://pypi.org/](https://pypi.org/) ）、GitHub（ [https://github.com/](https://github.com/) ）以及BitBucket（ [https://bitbucket.com](https://bitbucket.com) ）上搜索其他扩展。 

另外，Flask官方网站上的“Flask扩展登记”页面（ [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/) ）列出了一些被认可的扩展，如果你想让自己编写的扩展也出现在这个列表中，首先确保你的扩展符合满足Flask文档中列出的“被认可扩展（Approved Extensions）”检查清单（ [http://flask.pocoo.org/docs/latest/extensiondev/#approved-extensions](http://flask.pocoo.org/docs/latest/extensiondev/#approved-extensions) ）。然后在Flask网站所在的Github仓库（ [https://github.com/pallets/flask-website/](https://github.com/pallets/flask-website/) ）中找到扩展注册文件（ [https://github.com/pallets/flask-website/blob/master/flask_website/listings/extensions.py](https://github.com/pallets/flask-website/blob/master/flask_website/listings/extensions.py) ）。最后根据你的扩展的相关信息创建一个Extension类实例，扩展信息分别对应Extension构造方法的各个参数，并把它添加到extensions列表结尾。以Flask-Share为例，这个类实例如下所示： 

- - - -




```

Extension('Flask-Share', 'Grey Li',
    description='''

        <p>Adds <a href="http://openid.net/">OpenID</a> support to Flask.
    ''',
    github='greyli/flask-share',
    docs='http://pythonhosted.org/Flask-Share/',
    ),

```
- - - -

Fork并修改文件后提交Pull Request，等到项目负责人审核通过后，就可以在 [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/) 上看到你的扩展了。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 15.9  本章小结

学习完这一章后，你已经有能力编写自己的扩展了。如果你发现某些重复劳动可以通过一个Flask扩展来避免，而且这个扩展还没有出现，那么快动手吧，为Flask社区的繁荣尽一份力！

下一章，我们将到Flask内部一探究竟，了解它是如何工作的，这会让我们在编写Web程序时更加顺手。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

## 第16章

## Flask工作原理与机制解析

在本章，我们将深入到Flask这个魔法盒子的内部去一探究竟。Flask的上下文是如何实现的？Werkzeug和Flask是什么关系？蓝本到底是什么？这一系列疑问都会在这个过程中得到答案。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20227.png)
附注

为了方便理解，本章中出现的源码会根据需要来省略。另外，脚本中不必要的英文注释会被删掉，在必要的地方会添加简短的中文注释。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 16.1  阅读Flask源码

在开始之前，有些读者难免会有疑问：为什么要阅读源码呢？一般来说，阅读源码通常会出于下面的目的：

·了解某个功能的具体实现。

·学习Flask的设计模式和代码组织方式

通过阅读源码，我们可以在日常开发中更加得心应手，而且在出现错误时可以更好地理解和解决问题。另外，Flask的代码非常Pythonic，而且有丰富的文档字符串，学习和阅读优美的代码也会有助于我们自己编写出优美的代码，而且探索本身也是一种乐趣。

本节我们会学习如何获取Flask源码，并且学习如何阅读源码。同时，我们还会在这个过程中学习使用PyCharm来辅助阅读。

#### 16.1.1  获取Flask源码

当我们使用pip或Pipenv安装Flask时，Flask会和其他包一样被安装到Python解释器中的site-packages目录下。如果仅仅是想阅读Flask的代码，site-packages包中的flask包并不方便获取，而且如果我们不小心修改了其中的代码，会导致运行其他依赖Flask的项目出错。更方便的做法是将Github上的Flask仓库复制到本地：

- - - -




```

$ git clone https://github.com/pallets/flask.git

```
- - - -

这样Flask是作为一个单独的项目存在，而且仓库中还包含了Flask的所有Git提交（Com-mit）历史，我们可以查看Flask从诞生（第一次提交）到最新版本的所有提交记录和发布版本。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20363.png)
提示

除了Flask的代码（程序包flask）外，Flask项目文件夹里包含了很多文件，比如文档、示例程序、测试等，这些内容在本章暂不展开介绍。

#### 16.1.2  如何阅读源码

大多数文本编辑器都可以用来阅读源码，但文本编辑器更多的特性是为了方便地写代码。而在阅读源码时，我们会有不一样的需求。比如我们需要理清函数调用关系，了解一个模块的代码结构，或是进行断点调试等。这些工作IDE可以更好地胜任（尤其是面对复杂庞大的项目时），所以在这里我们仍然使用本书开篇介绍的PyCharm作为源码阅读工具。PyCharm的安装和基本使用已经在第1章介绍过，这里不再赘述。

借助PyCharm提供的功能，我们既可以从宏观上了解整个Flask项目的结构，又可以在代码中层层深入地探索或是自由地穿梭。下面我们就来了解阅读Flask源码的主要方式，对于PyCharm的使用介绍会穿插在文章中。

在开始之前，我们要在PyCharm中打开Flask仓库的文件夹，并将其创建为新项目。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20228.png)
附注

在PyCharm中，大多数功能都可以通过快捷键打开。但是因为快键键因操作系统而异，所以文中并没有列出来。PyCharm提供的快键键索引表可以在“导航栏——Help——Keymap Reference”中看到。

1.立足整体

在阅读代码时，我们不需要关注Flask代码实现中的所有细节。如果把某个项目的源码比作大树，那么我们重点要关注的是树的主干和分支，而不是所有的树叶。

从结构上来说，Flask各个模块联系紧密，并不适合挨个模块从头到尾的线性阅读。我们需要先从整体上了解Flask，就像是读书先看目录一样。对于一个项目来说，我们需要了解flask包由哪些包和模块组成，各个模块又包含哪些类和函数，分别负责实现什么功能。

我们当前打开的Flask版本是最新版本（1.0.2），单击左侧的project标签可以打开项目目录工具栏，其中包含了项目的整个文件目录结构，如图16-1所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXCEX2YpAAAAAC7e_8g322131594.jpg)
图16-1 Flask项目文件结构

从程序包flask中各个模块的名称我们基本就能知道它们的作用，具体说明如表16-1所示。

表16-1 Flask程序包各模块分析表

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXCEVnlyAAAAAIaTr-Q204434064.jpg)

我们并不需要了解所有模块的具体实现，对于某些不重要的模块，我们只需要知道大概的实现方法既可，比如cli.py、debughelpers.py。我们需要关注的是实现Flask核心功能的模块，比如WSGI交互、蓝本、上下文等。

除了查看项目的文件结构，我们还可以查看某个脚本的代码结构。以flask包中的app.py为例，在PyCharm中，我们双击app.py文件打开后，可以单击左侧的structure标签打开脚本结构工具栏，其中列出了当前脚本的所有symbol，如图16-2所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20229.png)
附注

在PyCharm中，Symbol一词指的是Python中的类/函数/方法/变量等可被标识出来的对象。

点开类前面的展开箭头，可以看到该类包含的方法和属性。树形结构中使用图标表示symbol的类别，“f”表示function（函数）、“m”表示method（方法），c表示class（类）、v表示variable（变量）。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXGEH3KTAAAAAAUqXT0780832042.jpg)
图16-2 app.py脚本结构

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20230.png)
附注

PyCharm中的symbol图标与对应含义可以在PyCharm的帮助文档中（ [https://www.jetbrains.com/help/pycharm/symbols.html](https://www.jetbrains.com/help/pycharm/symbols.xhtml) ）看到。 

你还会发现有些图标左上方有一个小锁头的标志，而且这些函数或方法的名字都是以下划线开始。这在Python中是一个约定，即命名以下划线开头的函数/方法是在内部使用的（private）。关于这个约定的具体内容可以在PEP 8中看到。

掌握Flask的整体结构还有一个有效的方法就是阅读Flask的API文档（ [http://flask.pocoo.org/docs/latest/api/](http://flask.pocoo.org/docs/latest/api/) ）。API文档中包含了所有Flask的主要类、函数以及它们的文档字符串（Doc-string）。这些文档字符串描述了主要功能，还列出了各个参数的类型和作用。在阅读源码时，我们也可以通过这些文档字符串来了解相关的用法。掌握Flask的整体结构会为我们的进一步阅读打下基础。 

2.逐个击破

在了解了Flask的整体结构后，我们就可以尝试从某一个功能点入手，了解具体的实现方法。在这种阅读方式下，我们可以从某一个函数或类开始，不断地深入。比如我们想了解消息闪现flash的功能是如何实现的，就可以从flash()函数出发。

PyCharm提供了强大的搜索功能，单击菜单栏上的Navigate，我们可以看到PyCharm提供的各种搜索功能，可以搜索文件、类、函数、方法。

单击Navigate——Symbol，在弹出的窗口中输入flash即可定位到flash()函数定义的位置，如图16-3所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXGENr9PAAAAACdBJhc399171390.jpg)
图16-3 搜索symbol

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20364.png)
提示

我们也可以双击Shift键打开全局搜索（Search Everywhere），全局搜索会搜索所有相关的symbol、文件、操作等。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20231.png)
附注

代码中，在某个symbol的名称上单击右键——Find Usages，可以找到整个项目中所有使用这个类/函数/方法等的位置。

在阅读源码时，我们需要带着两个问题去读：

·这段代码实现了什么功能？

·它是如何实现的？

通过全局搜索，我们找到了flash()函数，如代码清单16-1所示。

代码清单16-1 flask/helpers.py：flash()函数

- - - -




```

def flash(message, category='message'):
    """向下一个请求闪现消息。"""
    flashes = session.get('flashes', [])
    flashes.append((category, message))
    session['flashes'] = flashes
    message_flashed.send(current_app._get_current_object(),
                         message=message, category=category)

```
- - - -

在flash()函数中，我们能够大概了解这几行代码：首先从session获取_flashes键对应的消息列表，如果没有获取到将创建空列表作为默认值，然后将调用flash()函数时传入的消息和列表作为元组传入这个列表，最后再次将消息列表以_flashes作为键传入session中。

这里出现了一个不熟悉的message_flashed对象。这时如果我们想查看这些对象的定义，不需要再使用搜索功能，因为PyCharm还提供了非常方便的目标跳转功能。按住Crtl键就可以进入“超链接模式”，所有的Symbol都会变成可以单击的超链接，我们可以通过单击来跳转到目标对象定义的位置。在日常开发中，这种功能也非常有用。比如我们在调用某个库提供的hello()函数时，不知道可用的参数有哪些，就可以在“超链接模式”下直接跳转到目标hello()定义的位置了解用法。

通过跳转到message_flashed的定义，我们可以大概了解这个对象的功能：在信息闪现后发送的一个信号。不过，既然我们是要了解消息闪现的原理，那么正确的做法是暂时把message_flashed的具体实现作为一个黑盒放在一边，仅仅需要了解大概的功能就可以了。

在模板中，我们使用get_flashed_message()函数获取消息，那么再次搜索找到它（其实它就在flash()函数下面），如代码清单16-2所示。

代码清单16-2 flask/helpers.py：get_flashed_messages()函数

- - - -




```

def get_flashed_messages(with_categories=False, category_filter=[]):
    """从session中拉取消息并返回。"""
    flashes = request_ctx_stack.top.flashes
    if flashes is None:
        _request_ctx_stack.top.flashes = flashes = session.pop('flashes') \
            if '_flashes' in session else []
    if category_filter:  # 类别过滤
        flashes = list(filter(lambda f: f[0] in category_filter, flashes))
    if not with_categories:  # 判断是否返回消息类别
        return [x[1] for x in flashes]
    return flashes

```
- - - -

我们看到代码中先是从_request_ctx_stack.top.flashes获取闪现的消息，不过从变量名可以看出这是请求上下文堆栈的顶部，不过基于同样的理由，我们也暂时把_request_ctx_stack.top看做黑盒。如果没有获取到，那么再从session对象里获取。如果设置了category_filter和with_categories参数，那么则对消息列表进行相应修改，最后返回消息列表。对于这些参数的功能，文档字符串中都给出了很详细的介绍。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20232.png)
附注

实际源码中的文档字符串格式也许让你感到困惑，其实这些标记是reStructureText标记，是为了更方便使用Sphinx生成API文档。

3.由简入繁

许多介绍Linux的书籍都会建议读者先阅读Linux 0.x版本（即初期版本）的代码，因为早期的代码仅保留了核心特性，而且代码量较少，容易阅读和理解。Flask的源码也是这样，所以你可以先从Flask早期版本开始阅读。Flask最早发行的0.1版本只包含一个核心脚本——flask.py，不算空行大概只有四百多行代码，非常mini。我们使用下面的命令签出0.1版本的代码：

- - - -




```

 cd flask
​ git checkout 0.1

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20365.png)
提示

如果命令行的当前目录已经在flask项目根目录中，那么可以省略第一行命令。

签出后，你会发现Flask的仓库中除了项目相关的代码外，只有一个flask.py，这就是我们要阅读的对象。这个版本的代码非常适合阅读，也是了解Flask核心原理的最佳版本。以我们在上一节介绍过的flash()函数为例，在0.1版本中，这个函数只有一行代码：

- - - -




```

def flash(message):
    session['flashes'] = (session.get('flashes', [])) + [message]

```
- - - -

通过这种对比，我们也可以了解到Flask的变化，思考这些变化会加深我们对相关知识的理解。

在PyCharm中，我们可以在窗口下方的Version Control（版本控制）工具栏中查看到所有的代码提交记录，如图16-4所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXGEGnUHAAAAAKcp9Jo835523623.jpg)
图16-4 查看Git提交记录

单击任意提交记录，在右侧区域就会显示该提交修改的文件，以及提交的具体信息。在任意一个提交上单击右键选择Checkout Revision即可签出这一版本的仓库。单击右侧区域上方的Show Diff按钮，可以查看该变动与当前版本的对比，如图16-5所示。

提交记录右侧的标签图标表示对应的Git标签，每个标签通常对应着一个Release版本，单击右上方设置图标后选择Show Tag Name可以查看标签的名称。虽然PyCharm提供了完整的Git功能，但大部分的Git操作使用命令行会更方便灵活一些。

在阅读下面的内容之前，请先阅读完0.1版本的flask.py源码，这个脚本可以按从头到尾的顺序阅读。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXGEWIyaAAAAAC3KA0Y977991711.jpg)
图16-5 查看版本对比

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20366.png)
提示

作为替代，你也可以阅读我提供的注解版本（ [https://github.com/greyli/flask-origin](https://github.com/greyli/flask-origin) ）。在这个注解版本中，英文的注释被适当删减后替换成了中文注释。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20130.png)
注意

在0.1版本的Flask中，有些用法和Flask的当前版本已经有很大出入，所以不要把其中的代码实现直接应用到开发中。

4.单步调试

单步调试是指通过每次只执行一行代码或函数来进行调试的方法。在单步调试中，你可以实时观察代码执行的流程，了解每一步的数据变化情况，并且可以随时修改对应的代码。单步调试通常用来在开发时调试程序，找出错误的代码。在阅读源码时，我们也可以使用这种方式来了解代码执行和调用的流程（调用栈）。

尤为重要的是，在单步调试模式下，代码是包含上下文信息（比如我们可以看到所有变量的具体值）的，可以说是“活”的代码，这让调试和了解代码运行状况变得非常方便。

断点（Breakpoint）是开始单步调试的起点，当程序执行到断点时会停止自动执行，控制权将交给你。PyCharm基于Python DeBugger实现了非常方便的调试功能。在PyCharm中，设置断点非常简单。只需要在代码行左侧的gutter区域（空白处）单击鼠标左键，即可在这一行设置断点，断点的位置会显示一个红色的实心圆。比如，在下图中的Flask程序中，我们把断点设置在index视图内的return语句上，如图16-6所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXGEGHQ1AAAAADQsb5E984010143.jpg)
图16-6 设置调试断点

设置断点后，我们需要使用PyCharm的调试模式启动程序，单击菜单栏右侧的Debug Run按钮（绿色虫子图标）或按Shift+F9。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20233.png)
附注

代码中的错误通常被称为Bug（虫子）。这个典故起源于1946年，操作员Grace Hopper在Mark II计算机中抓出一只导致故障的飞蛾，并记录在日志上。代指排错、调试的词语Debug（Debugging）也因此而来。

当代码运行到断点的位置时，会在调试工具栏显示断点调试的结果，如图16-7所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXGEWQWhAAAAAKcoaIM811422300.jpg)
图16-7 调试工具栏

PyCharm会自动列出断点之前的调用记录，单击任意一个记录，编辑器区域会显示对应的代码（编辑区会以深蓝色背景显示当前正在调用的代码行），而变量区域会显示这一步的变量情况。另外，对应的变量值也会以墨绿色显示在代码中。通过调试工具栏我们可以看到从我们使用flask run命令所调用的flask-script.py脚本开始，一直到处理请求，再到我们设置断点的地方，这整个过程中的调用情况。

你可以通过调试工具栏上方的步进工具栏来执行步进操作，常用的步进按钮的介绍如图16-8所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20234.png)
附注

你也可以直接使用内置的pdb模块（Python DeBugger）或是集成IPython的ipdb（ [https://github.com/gotcha/ipdb](https://github.com/gotcha/ipdb) ）来进行单步调试。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXGEHW-ZAAAAAFUIWYA699864767.jpg)
图16-8 步进按钮说明

#### 16.1.3  Flask发行版本分析

在阅读完0.1版本的Flask源码后，我们需要继续前进，但是我们是否有必要阅读每一个发行版本呢？当然不用。有些版本只是修正了少量错误，添加了一些额外的特性，这类版本可以跳过。Flask当前最新的版本是1.0.2。主要的Flask发行版本及其变化如表16-2所示。

表16-2 Flask版本分析

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXGERKigAAAAALGIH78236337278.jpg)

如果你打算从头开始了解Flask的变化，那么比较值得阅读的版本是0.1、0.4、0.5、0.7以及最新版本1.0，其他版本大部分的变动都是在重构、优化代码以及修复错误，因此可以略过。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20235.png)
附注

完整的发行版本变更说明可以在 [http://flask.pocoo.org/docs/latest/changelog/](http://flask.pocoo.org/docs/latest/changelog/) 看到。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

### 16.2  Flask的设计理念

本节我们会从设计者的视角来了解Flask的一些实现。

#### 16.2.1  “微”框架

在官方介绍中，Flask被称为微框架，那么这里的“微”是什么意思呢？基于我们前面的介绍以及大量的实践，想必你已经了解地差不多了。这里的“微”并不意味着Flask功能简陋，而是指其保留核心且易于扩展。有许多Web程序不需要后台管理、用户认证、权限管理，有些甚至不需要表单或数据库，所以Flask并没有内置这类功能，而是把这些功能都交给扩展或用户自己实现。正因为如此，从只需要渲染模板的小项目，到需要各种功能的大项目，Flask几乎能够适应各种情况。Flask的这一设计理念正印证了《Zen of Python》里的这一句：

“Simple is better than complex.”

#### 16.2.2  两个核心依赖

虽然Flask保持简单的核心，但它主要依赖两个库——Werkzeug和Jinja。Python Web框架都需要处理WSGI交互，而Werkzeug本身就是一个非常优秀的WSGI工具库，几乎没有理由不使用它，为什么要重新发明轮子（引入Jinja2）呢？

如果你阅读了Flask源码，会发现Flask与Werkzeug的联系非常紧密。从路由处理，到请求解析，再到响应的封装，以及上下文和各种数据结构都离不开Werkzeug，有些函数（比如redirect、abort）甚至是直接从Werkzeug引入的。如果要深入了解Flask的实现原理，必然躲不开Werkzeug。

引入Jinja2主要是因为大多数Web程序都需要渲染模板，与Jinja2集成可以减少大量的工作。除此之外，Flask扩展常常需要处理模板，而集成Jinja2方便了扩展的开发。不过，Flask并不限制你选择其他模板引擎，比如Mako（ [http://www.makotemplates.org/](http://www.makotemplates.org/) ）、Genshi（ [http://genshi.edgewall.org/](http://genshi.edgewall.org/) ）等。 

#### 16.2.3  显式程序对象

在一些Python Web框架中，一个视图函数可能类似这样：

- - - -



```

from example_framework import route

@route('/')
def index():
    return 'Hello World!'

```
- - - -

而在Flask中，则需要这样：

- - - -




```

from flask import Flask
app = Flask(name)

@app.route('/')
def index():
    return 'Hello World!'

```
- - - -

你应该看到其中的区别了，Flask中存在一个显式的程序对象，我们需要在全局空间中创建它。这样设计主要有下面几个原因：

·前一种方式（隐式程序对象）在同一时间内只能有一个实例存在，而显式的程序对象允许多个程序实例存在。

·允许你通过子类化Flask类来改变程序行为。

·Flask需要通过传入的包名称来定位资源（模板和静态文件）。

·允许通过工厂函数来创建程序实例，可以在不同的地方传入不同的配置来创建不同的程序实例。

·允许通过蓝本来模块化程序。

另外，这个设计也印证了《Zen of Python》里的这一条：“Explicit is better than implicit.”

#### 16.2.4  本地上下文

在多线程环境下，要想让所有视图函数都获取请求对象。最直接的方法就是在调用视图函数时将所有需要的数据作为参数传递进去，但这样一来程序逻辑就变得冗余且不易于维护。另一种方法是将这些数据设为全局变量，但是如果直接将请求对象设为全局变量，那么必然会在不同的线程中导致混乱（非线程安全）。本地线程（thread locals）的出现解决了这些问题。

本地线程就是一个全局对象，你可以使用一种特定线程且线程安全的方式来存储和获取数据。也就是说，同一个变量在不同的线程内拥有各自的值，互不干扰。实现原理其实很简单，就是根据线程的ID来存取数据。Flask没有使用标准库的threading.local()，而是使用了Werkzeug自己实现的本地线程对象werkzeug.local.Local()，后者增加了对Greenlet的优先支持。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20236.png)
附注

Greenlet（ [https://github.com/python-greenlet/greenlet](https://github.com/python-greenlet/greenlet) ）是以C扩展形式接入Python的轻量级协程。 

Flask使用本地线程来让上下文代理对象全局可访问，比如request、session、current_app、g，这些对象被称为本地上下文对象（context locals）。因此，在不基于线程、greenlet或单进程实现的并发服务器上，这些代理对象将无法正常工作，但好在仅有少部分服务器不被支持。Flask的设计初衷是为了让传统Web程序的开发更加简单和迅速，而不是用来开发大型程序或异步服务器的。但是Flask的可扩展性却提供了无限的可能性，除了使用扩展，我们还可以子类化Flask类，或是为程序添加中间件。

#### 16.2.5  三种程序状态

Flask提供的四个本地上下文对象分别在特定的程序状态下绑定实际的对象。如果我们在访问或使用它们时还没有绑定，那么就会看到初学者经常见到的RuntimeError异常。

在Flask中存在三种状态，分别是程序设置状态（application setup state）、程序运行状态（application runtime state）和请求运行状态（request runtime state）。

1.程序设置状态

当Flask类被实例化，也就是创建程序实例app后，就进入了程序设置状态。这时所有的全局对象都没有被绑定：

- - - -




```

> > > from flask import Flask, current_app, g, request, session
> > > app = Flask(__name__)
> > > current_app, g, request, session
> > > (<LocalProxy unbound>,
> > > <LocalProxy unbound>,
> > > <LocalProxy unbound>,
> > > <LocalProxy unbound>)

```
- - - -

2.程序运行状态

当Flask程序启动，但是还没有请求进入时，Flask进入了程序运行状态。在这种状态下，程序上下文对象current_app和g都绑定了各自的对象。使用flask shell命令打开的Python shell默认就是这种状态，我们也可以在普通的Python shell中通过手动推送程序上下文来模拟：

- - - -




```

> > > from flask import Flask, current_app, g, request, session
> > > app = Flask(__name__)
> > > ctx = app.app_context()
> > > ctx.push()
> > > current_app, g, request, session
> > > (<Flask '__main__'>,
> > > <flask.g of '__main__'>,
> > > <LocalProxy unbound>,
> > > <LocalProxy unbound>)
> > > ctx.pop()

```
- - - -

在上面的代码中，我们手动使用app_context()方法创建了程序上下文，然后调用push()方法把它推送到程序上下文堆栈里。默认情况下，当请求进入的时候，程序上下文会随着请求上下文一起被自动激活。但是在没有请求进入的场景，比如离线脚本、测试，或是进行交互式调试的时候，手动推送程序上下文以进入程序运行状态会非常方便。

3.请求运行状态

当请求进入的时候，或是使用test_request_context()方法、test_client()方法时，Flask会进入请求运行状态。因为当请求上下文被推送时，程序上下文也会被自动推送，所以在这个状态下4个全局对象都会被绑定，我们可以通过手动推送请求上下文模拟：

- - - -




```

> > > from flask import Flask, current_app, g, request, session
> > > app = Flask(__name__)
> > > ctx = app.test_request_context()
> > > ctx.push()
> > > current_app, g, request, session
> > > (<Flask '__main__'>,
> > > <flask.g of '__main__'>,
> > > <Request 'http://localhost/' [GET]>,
> > > <NullSession {}>)
> > > ctx.pop()

```
- - - -

这也是为什么你可以直接在视图函数和相应的回调函数里直接使用这些上下文对象，而不用推送上下文——Flask在处理请求时会自动帮你推送请求上下文和程序上下文。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20131.png)
注意

这里因为没有设置程序密钥，所以session是表示无效session的NullSession类实例。后面我们会详细了解。

#### 16.2.6  丰富的自定义支持

Flask的灵活不仅体现在易于扩展，不限制项目结构，也体现在其内部的高度可定制化。比如，我们可以子类化用于创建程序实例的Flask类，来改变特定的行为：

- - - -




```

from flask import Flask

class MyFlask(Flask)
    pass

app = MyFlask(name)

...

```
- - - -

除了Flask类，我们还可以自定义请求类和响应类。最常用的方式是子类化Flask内置的请求类和响应类，然后改变一些默认的属性。Flask内部在使用这些类时并不直接写死，而是使用了定义在Flask属性上的中间变量，比如请求类存储在Flask.request_class中。如果要使用自己的请求类，那么只需要把请求类赋值给这个属性即可：

- - - -




```

from flask import Flask, Request

class MyRequest(Request):
    pass

app = Flask(name)
app.request_class = MyRequest

```
- - - -

同样，Flask允许你使用自定义的响应类。在其内部，创建响应对象的make_response()并不是直接实例化Response类，而是实例化被存储在Flask.response_class属性上的类，默认为Response类。如果你要自定义响应类，创建后只需赋值给程序实例的response_class属性即可。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 16.3  Flask与WSGI

在开始分析Flask的工作流程与机制前，我们有必要了解一些Web程序的基础——WSGI。在本书的一开始，我们曾经介绍过，Flask的核心扩展Werkzeug是一个WSGI工具库。WSGI指Python Web Server Gateway Interface，它是为了让Web服务器与Python程序能够进行数据交流而定义的一套接口标准/规范。试想一下，如果不统一标准，那么众多的Python Web框架都可能仅被某些Web服务器支持；而Web服务器也没法支持所有的Python Web框架。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20367.png)
提示

WSGI的具体定义在PEP 333（ [https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/) ）中可以看到。WSGI的新版本在PEP 3333中发布，新版本主要增加了Python 3支持（ [https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/) ）。 

我们曾在第2章学习过，客户端和服务器端进行沟通遵循了HTTP协议，可以说HTTP就是它们之间沟通的语言。从HTTP请求到我们的Web程序之间，还有另外一个转换过程——从HTTP报文到WSGI规定的数据格式。WSGI则可以视为WSGI服务器和我们的Web程序进行沟通的语言。

WSGI是开发Python Web程序的标准，所有的Python Web框架都需要按照WSGI的规范来编写程序。当然，Flask在背后自动帮我们完成了这部分工作。下面让我们通过实例来详细学习。

#### 16.3.1  WSGI程序

根据WSGI的规定，Web程序（或被称为WSGI程序）必须是一个可调用对象（callable object）。这个可调用对象接收两个参数：

·environ：包含了请求的所有信息的字典。

·start_response：需要在可调用对象中调用的函数，用来发起响应，参数是状态码、响应头部等。

WSGI服务器会在调用这个可调用对象时传入这两个参数。另外，这个可调用对象还要返回一个可迭代（iterable）的对象。

这个可调用对象可以是函数、方法、类或是实现了__call__方法的类实例，下面我们分别借助简单的实例来了解最主要的两种实现：函数和类。

现在，让我们创建一个新的hello程序，然后暂时把Flask忘掉。一个最简单的WSGI程序如代码清单16-3所示。

代码清单16-3 使用Python函数实现的WSGI程序

- - - -



```

def hello(environ, start_response):
    status = '200 OK'
    response_headers = [('Content-type', 'text/html')]
    start_response(status, response_headers)
    return [b'<h1>Hello, Web</h1>']

```
- - - -

这里的hello()函数就是我们的可调用对象，也就是我们的Web程序。hello()的末尾返回一行问候字符串，注意这是一个列表。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20368.png)
提示

根据WSGI的定义，请求和响应的主体应该为字节串（bytestrings），即Python 2中的str类型。在Python 3中字符串默认为unicode类型，因此需要在字符串前添加b前缀，将字符串声明为bytes类型。这里为了兼容两者，统一添加了b前缀。

类形式的可调用对象如代码清单16-4所示。

代码清单16-4 使用Python类实现的WSGI程序

- - - -



```

class AppClass:

```
def __init__(self, environ, start_response):
    self.environ = environ
    self.start = start_response

def __iter__(self):
    status = '200 OK'
    response_headers = [('Content-type', 'text/html')]
    self.start(status, response_headers)
    yield b'<h1>Hello, Web!</h1>'



```

```
- - - -

注意，类中实现了__iter__方法（类被迭代时将调用这个方法），它返回yield语句。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20237.png)
附注

如果想以类的实例作为WSGI程序，那么这个类必须实现__call__方法。

在上面我们创建了两个简单的WSGI程序，你应该感觉很熟悉吧！事实上，这两个程序的实际功能和我们在本书开始介绍的Flask程序hello完全相同。

Flask也是Python Web框架，自然也要遵循WSGI规范，所以Flask中也会实现类似的WSGI程序，只不过对请求和响应的处理要丰富完善得多。在Flask中，这个可调用对象就是我们的程序实例app，我们创建app实例时调用的Flask类就是另一种可调用对象形式——实现了__call__方法的类：

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def wsgi_app(self, environ, start_response):
        ...
    def call(self, environ, start_response):
        """Shortcut for :attr:wsgi_app."""
        return self.wsgi_app(environ, start_response)

```
- - - -

这个__call__方法内部调用了wsgi_app()方法，请求进入和响应的返回就发生在这里，WSGI服务器通过调用这个方法来传入请求数据，获取返回的响应，后面会详细介绍。

#### 16.3.2  WSGI服务器

程序编写好了，现在我们需要一个WSGI服务器来运行它。作为WSGI服务器的实现示例，Python提供了一个wsgiref库，可以在开发时使用。以hello()函数为例，在函数定义的下面添加如下代码：

- - - -




```

from wsgiref.simple_server import make_server

def hello(environ, start_response):
    ...

server = make_server('localhost', 5000, hello)
server.serve_forever()

```
- - - -

我们这里对于WSGI服务器的具体实现不做深入讨论。这里使用make_server（host，port，application）方法创建了一个本地服务器，分别传入主机地址、端口和可调用对象（即WSGI程序）作为参数。最后使用serve_forever()方法运行它。

WSGI服务器启动后，它会监听本地机的对应端口（我们设置的5000）。当接收到请求时，它会把请求报文解析为一个environ字典，然后调用WSGI程序提供的可调用对象，传递这个字典作为参数，同时传递的另一个参数是一个start_response函数。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20369.png)
提示

我们这里应该会想到Flask提供的请求对象其实就是对environ字典的解析和封装。

我们在命令行使用Python解释器执行hello.py，这会启动我们创建的WSGI服务器：

- - - -




```

$ python hello.py

```
- - - -

然后像以前一样在浏览器中访问 [http://localhost:5000](http://localhost:5000) 时，这个WSGI服务器接收到这个请求，接着调用hello()函数，并传递environ和start_response参数，最后把hello()函数的返回值处理为HTTP响应返回给客户端。这一系列工作完成后，我们就会在浏览器看到一行“Hello，Web！” 

下面是这个程序的变式，通过从environ字典获取请求URL来修改响应的内容。

- - - -




```

def hello(environ, start_response):
    status = '200 OK'
    response_headers = [('Content-type', 'text/html')]
    start_response(status, response_headers)
    name = environ'PATH_INFO' or 'web'
    return [b'<h1>Hello, %s!</h1>' % name]

```
- - - -

我们从environ字典里获取路径中根地址后的字符作为名字：environ['PATH_INFO'][1：]，然后插入到响应的字符串里。这时在浏览器中访问localhost：5000/Grey，则会看到浏览器显示一行“Hello，Grey！”。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20132.png)
注意

和我们在第2章实现同样功能的例子相同，把用户输入的内容未经处理直接插入到响应中会导致XSS攻击，这里只是一个示例，请避免在真实的程序中使用。

不论是Werkzeug内置的用于开发时使用的服务器，还是我们在第14章提及的Gunicorn、uWSGI、Waitress等都是实现了这类规范的WSGI服务器，正是因为遵循统一的WSGI规范，所以这些WSGI服务器都可以用来运行我们的Flask程序。

#### 16.3.3  中间件

WSGI允许使用中间件（Middleware）包装（wrap）程序，为程序在被调用前添加额外的设置和功能。当请求发送来后，会先调用包装在可调用对象外层的中间件。这个特性经常被用来解耦程序的功能，这样可以将不同功能分开维护，达到分层的目的，同时也根据需要嵌套。代码清单16-5是一个简单的例子。

代码清单16-5 为WSGI程序添加中间件

- - - -




```

from wsgiref.simple_server import make_server

def hello(environ, start_response):
    status = '200 OK'
    response_headers = [('Content-type', 'text/html')]
    start_response(status, response_headers)
    return [b'<h1>Hello, web!</h1>']

class MyMiddleware(object):
    def init(self, app):
        self.app = app

```
def __call__(self, environ, start_response):
    def custom_start_response(status, headers, exc_info=None):
        headers.append(('A-CUSTOM-HEADER', 'Nothing'))
        return start_response(status, headers)

    return self.app(environ, custom_start_response)


```

wrapped_app = MyMiddleware(hello)
server = make_server('localhost', 5000, wrapped_app)
server.serve_forever()

```
- - - -

中间件接收可调用对象作为参数。这个可调用对象也可以是被其他中间件包装的可调用对象。中间件可以层层叠加，形成一个“中间件堆栈”，最后才会调用到实际的可调用对象。

使用类定义的中间件必须实现__call__方法，接收environ和start_response对象作为参数，最后调用传入的可调用对象，并传递这两个参数。这个MyMiddleware中间件其实并没有做什么，只是向首部添加了一个无意义的自定义字段。最后传入可调用对象hello函数来实例化这个中间件，获得包装后的程序实例wrapped_app。

因为Flask中实际的WSGI可调用对象是Flask.wsgi_app()方法，因此，如果我们自己实现了中间件，那么最佳的方式是嵌套在这个wsgi_app对象上，比如：

- - - -



```

class MyMiddleware(object):
    pass
app = Flask(name)
app.wsgi_app = MyMiddleware(app.wsgi_app)

```
- - - -

作为WSGI工具集，Werkzeug内置了许多方便的中间件，可以用来为程序添加额外的功能。比如，我们在第14章使用的ProxyFix，可以用来对反向代理转发的请求进行修正；还有能够为程序添加性能分析器的werkzeug.contrib.profiler.ProfilerMiddleware中间件，这个中间件可以在处理请求时进行性能分析，作用和Flask-DebugToolbar提供的分析器基本相同；另外，支持多应用调度的werkzeug.wsgi.DispatcherMiddleware中间件则可以让你将多个WSGI程序作为一个“程序集”同时运行，你需要传入多个程序实例，并为这些程序设置对应的URL前缀或子域名来分发请求。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 16.4  Flask的工作流程与机制

本节我们会深入到Flask的源码来了解请求、响应、路由处理等功能是如何实现的。首先，我们会对Flask应用启动流程和请求响应循环进行分析。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20370.png)
提示

如果有时间，你可以先了解一下Werkzeug，这会有助于理解Flask的代码，因为Flask的很多功能是建立在Werkzeug之上的。在下面的介绍中也会涉及Werkzeug的代码，但由于篇幅所限，会尽量简略介绍这部分的相关内容。

#### 16.4.1  Flask中的请求响应循环

对于Flask的工作流程，最好的了解方法是从启动程序的脚本开始，跟着程序调用的脚步一步步深入代码的内部。在本节，我们会了解请求-响应循环在Flask中是如何处理的：从程序开始运行，第一个请求进入，再到返回生成的响应。

为了方便进行单步调试，在这里我们要和本书开始时一样，先创建一个简单的Flask程序：

- - - -



```

from flask import Flask

app = Flask(name)

@app.route('/')
def hello():
    return 'Hello, Flask!'  # 在这一行设置断点

```
- - - -

我们首先在hello程序的index视图中渲染模板这一行设置断点，然后单击PyCharm右上方的虫子图标运行调试。

1.程序启动

目前我们有两种方法启动开发服务器，一种是在命令行中使用flask run命令（会调用flask.cli.run_command()函数），另一种是使用被弃用的flask.Flask.run()方法。不论是run_command()函数，还是以前用于运行程序的run()函数，它们都在最后调用了werkzeug.serving模块中的run_simple()函数，如代码清单16-6所示。

代码清单16-6 werkzeug/serving.py：使用内置服务器运行WSGI程序

- - - -




```

def run_simple(hostname, port, application, use_reloader=False,
               use_debugger=False, use_evalex=True,
               extra_files=None, reloader_interval=1,
               reloader_type='auto', threaded=False,
               processes=1, request_handler=None, static_files=None,
               passthrough_errors=False, ssl_context=None):

```
if use_debugger:  # 判断是否使用调试器
    from werkzeug.debug import DebuggedApplication
    application = DebuggedApplication(application, use_evalex)
if static_files:
    from werkzeug.wsgi import SharedDataMiddleware
    application = SharedDataMiddleware(application, static_files)
...
def inner():
    try:
        fd = int(os.environ['WERKZEUG_SERVER_FD'])
    except (LookupError, ValueError):
        fd = None
    srv = make_server(hostname, port, application, threaded,
                      processes, request_handler,
                      passthrough_errors, ssl_context,
                      fd=fd)
    if fd is None:
        log_startup(srv.socket)
    srv.serve_forever()

if use_reloader:  # 判断是否使用重载器
    ...
    from werkzeug._reloader import run_with_reloader
    run_with_reloader(inner, extra_files, reloader_interval,
                      reloader_type)
else:
    inner()



```

```
- - - -

在这里使用了两个Werkzeug提供的中间件，如果use_debugger为Ture，也就是开启调试模式，那么就使用DebuggedApplication中间件为程序添加调试功能。如果static_files为True，就使用SharedDataMiddleware中间件为程序添加提供（serve）静态文件的功能。

这个方法最终会调用inner()函数，函数中的代码和我们在上一节创建的WSGI程序末尾很像。它使用make_server()方法创建服务器，然后调用serve_forever()方法运行服务器。为了避免偏离重点，中间在Werkzeug和其他模块的调用我们不再分析。我们在前面学习过WSGI的内容，当接收到请求时，WSGI服务器会调用Web程序中提供的可调用对象，这个对象就是我们的程序实例app。现在，第一个请求进入了。

2.请求In

Flask类实现了__call__()方法，当程序实例被调用时会执行这个方法，而这个方法内部调用了Flask.wsgi_app()方法，如代码清单16-7所示。

代码清单16-7 flask/app.py：Flask.wsgi_app()

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def wsgi_app(self, environ, start_response):
        ctx = self.request_context(environ)
        error = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if self.should_ignore_error(error):
                error = None
            ctx.auto_pop(error)

```
def __call__(self, environ, start_response):
    """wsgi_app的快捷方法."""
    return self.wsgi_app(environ, start_response)



```

```
- - - -

通过wsgi_app()方法接收的参数可以看出来，这个wsgi_app()方法就是隐藏在Flask中的那个WSGI程序。这里将WSGI程序实现在单独的方法中，而不是直接实现在__call__()方法中，主要是为了在方便附加中间件的同时保留对程序实例的引用。

wsgi_app()方法中的try...except...语句是重点。它首先尝试从Flask.full_dispatch_request()方法获取响应，如果出错那么就根据错误类型来生成错误响应。我们来看看处理请求并生成响应的Flask.full_dispatch_request()方法，它负责完整地请求调度（full request dispatching），如代码清单16-8所示。

代码清单16-8 flask/app.py：完整的请求调度

- - - -




```

class Flask(_PackageBoundObject)：
    ...
    def full_dispatch_request(self):
        """分发请求，并对请求进行预处理和后处理。同时捕捉HTPP异常并处理错误
        """
        self.try_trigger_before_first_request_functions()
        try:
            request_started.send(self)  # 发送请求进入信号
            rv = self.preprocess_request()  # 预处理请求
            if rv is None:
                rv = self.dispatch_request()  # 进一步处理请求，获取返回值
        except Exception as e:
            rv = self.handle_user_exception(e)  # 处理异常
        return self.finalize_request(rv)  # 最终处理

```
- - - -

在这个函数中调用了preprocess_request()方法对请求进行预处理（request preprocessing），这会执行所有使用before_request钩子注册的函数。

接着，请求分发的工作会进一步交给dispatch_request()方法，它会匹配并调用对应的视图函数，获取其返回值，在这里赋值给rv，请求调度的具体细节我们会在后面了解。最后，接收视图函数返回值的finalize_request()会使用这个值来生成响应。

3.响应Out

接收到视图函数返回值的finalize_request()函数负责生成响应，即请求的最终处理（request finalizing），如代码清单16-9所示。

代码清单16-9 flask/app.py：请求最终处理

- - - -




```

class Flask(_PackageBoundObject)：
    ...
    def finalize_request(self, rv, from_error_handler=False):
        """把视图函数返回值转换为响应，然后调用后处理函数。
        """
        response = self.make_response(rv)  # 生成响应对象
        try:
            response = self.process_response(response)  # 响应预处理
            request_finished.send(self, response=response)  # 发送信号
        except Exception:
            if not from_error_handler:
                raise
            self.logger.exception('Request finalizing failed with an '
                                  'error while handling an error')
        return response

```
- - - -

这里使用Flask类中的make_response()方法生成响应对象，但这个make_response并不是我们从flask导入并在视图函数中生成响应对象的make_response，我们平时使用的make_response是helpers模块中的make_response()函数，它对传入的参数进行简单处理，然后把参数传递给Flask类的make_response方法并返回。后面我们会详细了解响应对象。

除了创建响应对象，这段代码主要调用了process_response()方法处理响应。这个响应处理方法会在把响应发送给WSGI服务器前执行所有使用after_request钩子注册的函数。另外，这个方法还会根据session对象来设置cookie，后面我们会详细了解。

返回作为响应的response后，代码执行流程就回到了wsgi_app()方法，最后返回响应对象，WSGI服务器接收这个响应对象，并把它转换成HTTP响应报文发送给客户端。

就这样，我们这次Flask中的请求-循环之旅结束了。在下面几节，我们会详细分析这一过程中发生的细节，比如路由处理、请求和响应对象的封装等。

#### 16.4.2  路由系统

1.注册路由

路由系统内部是由Werkzeug实现的，为了更好地了解Flask中的相关代码，我们需要先看一下路由功能在Werkzeug中是如何实现的。下面的代码用于创建路由表Map，并添加三个URL规则：

- - - -




```

> > > m = Map()
> > > rule1 = Rule('/', endpoint='index')
> > > rule2 = Rule('/downloads/', endpoint='downloads/index')
> > > rule3 = Rule('/downloads/<int:id>', endpoint='downloads/show')
> > > m.add(rule1)
> > > m.add(rule2)
> > > m.add(rule3)

```
- - - -

在Flask中，我们使用route()装饰器来将视图函数注册为路由：

- - - -




```

@app.route('/')
def hello():
    return 'Hello, Flask!'

```
- - - -

Flask.route()是Flask类的类方法，如代码清单16-10所示。

代码清单16-10 flask/app.py：Flask.route()方法

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def route(self, rule, options):
        def decorator(f):
            endpoint = options.pop('endpoint', None)
            self.add_url_rule(rule, endpoint, f, options)
            return f
        return decorator

```
- - - -

可以看到route装饰器的内部调用了add_url_rule()来添加URL规则，所以注册路由也可以直接使用add_url_rule实现（0.2版本及之后）。add_url_rule()方法如代码清单16-11所示：

代码清单16-11 flask/app.py：Flask.add_url_rule()方法

- - - -




```

class Flask(_PackageBoundObject):
    ...
    @setupmethod
    def add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options):

# 设置方法和端点

​        ...
​        rule = self.url_rule_class(rule, methods=methods, **options)
​        rule.provide_automatic_options = provide_automatic_options

```
    self.url_map.add(rule)
    if view_func is not None:
        old_func = self.view_functions.get(endpoint)
        if old_func is not None and old_func != view_func:
            raise AssertionError('View function mapping is overwriting an '
                                 'existing endpoint function: %s' % endpoint)
        self.view_functions[endpoint] = view_func



```

```
- - - -

这个方法的重点在下面这两行：

- - - -




```

self.url_map.add(rule)
...
self.view_functions[endpoint] = view_func

```
- - - -

这里引入了两个对象：url_map和view_functions。

url_map是Werkzeug的Map类实例（werkzeug.routing.Map）。它存储了URL规则和相关配置，这里的rule是Werkzeug提供的Rule实例（werkzeug.routing.Rule），其中保存了端点和URL规则的映射关系。

而view_function则是Flask类中定义的一个字典，它存储了端点和视图函数的映射关系。看到这里你大概已经发现端点是如何作为中间人连接起URL规则和视图函数的。

如果你再回过头看本节开始提供的Werkzeug中的路由注册代码，你会发现add_url_rule()方法中的这些代码做了同样的事情：

- - - -




```

rule = self.url_rule_class(rule, methods=methods, **options)
...
self.url_map.add(rule)

```
- - - -

这里的Flask.url_rule_class存储了Rule类，而url_map是Map类实例。

2.URL匹配

在上面的Werkzeug路由注册代码示例中，我们创建了路由表m，并使用add()方法添加了三个路由规则。现在，我们来看看如何在Werkzeug中进行URL匹配，URL匹配的示例如下所示：

- - - -




```

> > > m = Map()
> > > rule1 = Rule('/', endpoint='index')
> > > rule2 = Rule('/downloads/', endpoint='downloads/index')
> > > rule3 = Rule('/downloads/<int:id>', endpoint='downloads/show')
> > > m.add(rule1)
> > > m.add(rule2)
> > > m.add(rule3)
> > >
> > > urls = m.bind('example.com')  # 传入主机地址作为参数
> > > urls.match('/', 'GET')
> > > ('index', {})
> > > urls.match('/downloads/42')
> > > ('downloads/show', {'id': 42})

> > > urls.match('/downloads')
> > > Traceback (most recent call last):
> > > ...
> > > RequestRedirect: http://example.com/downloads/
> > > urls.match('/missing')
> > > Traceback (most recent call last):
> > > ...
> > > NotFound: 404 Not Found

```
- - - -

Map.bind()方法和Map.bind_to_environ()都会返回一个MapAdapter对象，它负责匹配和构建URL。MapAdapter类的match方法用来判断传入的URL是否匹配Map对象中存储的路由规则（存储在self.map._rules列表中）。上面的例子中分别展示了几种常见的匹配情况。匹配成功后会返回一个包含URL端点和URL变量的元组。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20371.png)
提示

为了确保URL的唯一，Werkzeug使用下面的规则来处理尾部斜线问题：当你定义的URL规则添加了尾部斜线时，用户访问未加尾部斜线的URL时会被自动重定向到正确的URL；反过来，如果定义的URL不包含尾部斜线，用户访问的URL添加了尾部斜线则会返回404错误。

MapAdapter类的build()方法用于创建URL，我们用来生成URL的url_for()函数内部就是通过build()方法实现的。下面是一个简单的例子：

- - - -




```

> > > urls.build('index', {})
> > > '/'
> > > urls.build('downloads/show', {'id': 42})
> > > '/downloads/42'
> > > urls.build('downloads/show', {'id': 42}, force_external=True)
> > > 'http://example.com/downloads/42'

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20238.png)
附注

关于Werkzeug的路由系统，这里只是简单介绍，具体你可以查看Werkzeug的文档（ [http://werkzeug.pocoo.org/docs/latest/routing/](http://werkzeug.pocoo.org/docs/latest/routing/) ）及相关代码。 

在上一节，注册路由后，两个对应关系分别存储到url_map和view_functions中，前者存储了URL到端点的映射关系，后者则存储了端点和视图函数的映射关系。下面我们会了解在客户端发送请求时，Flask是如何根据请求的URL找到对应的视图函数的。在上一节分析Flask中的请求响应循环时，我们曾说过，请求的处理最终交给了dispatch_request()方法，这个方法如代码清单16-12所示。

代码清单16-12 flask/app.py：Flask.dispatch_request()

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def dispatch_request(self):
        req = _request_ctx_stack.top.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)
        rule = req.url_rule

# 如果为这个URL提供了自动选项并且方法为OPTIONS，则自动处理

​        if getattr(rule, 'provide_automatic_options', False) \
​           and req.method == 'OPTIONS':
​            return self.make_default_options_response()

# 否则调用对应的视图函数

​        return self.view_functionsrule.endpoint

```
- - - -

从名字可以看出来，这个方法负责请求调度（request dispatching）。正是dispatch_request()方法实现了从请求的URL找到端点，再从端点找到对应的视图函数并调用的过程。在注册路由时，由Rule类表示的rule对象由route()装饰器传入的参数创建。而这里则直接从请求上下文对象（_request_ctx_stack.top.request）的url_rule属性获取。可以得知，URL的匹配工作在请求上下文对象中实现。请求上下文对象RequestContext在ctx.py脚本中定义，如代码清单16-13所示。

代码清单16-13 flask/ctx.py：RequestContext

- - - -




```

class RequestContext(object):

```
def __init__(self, app, environ, request=None):
    self.app = app
    if request is None:
        request = app.request_class(environ)
    self.request = request
    self.url_adapter = app.create_url_adapter(self.request)
    ...
    self.match_request()  # 匹配请求到对应的视图函数



```

```
- - - -

可以看到，请求上下文对象的构造函数中调用了match_request()方法，这会在创建请求上下文对象时调用。顾名思义，这个方法用来匹配请求（request matching），如代码清单16-14所示。

代码清单16-14 flask/ctx.py：RequestContext.match_request()

- - - -




```

class RequestContext(object):
    ...
    def match_request(self):
        try:
            url_rule, self.request.view_args = \
                self.url_adapter.match(return_rule=True)
            self.request.url_rule = url_rule
        except HTTPException as e:
            self.request.routing_exception = e

```
- - - -

可以看到url_rule属性就在这个方法中创建。这个方法调用了self.url_adapter.match（return_rule=True）来获取url_rule和view_args。这里的url_adapter属性在构造函数中定义，其值为app.create_url_adapter（self.request）。create_url_adapter()方法的定义如代码清单16-15所示。

代码清单16-15 flask/app.py：Flask.create_url_adapter()

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def create_url_adapter(self, request):
        if request is not None:

# 如果子域名匹配出于关闭状态（默认值）

# 就在各处使用默认的子域名

​            subdomain = ((self.url_map.default_subdomain or None)
​                         if not self.subdomain_matching else None)
​            return self.url_map.bind_to_environ(
​                request.environ,
​                server_name=self.config['SERVER_NAME'],
​                subdomain=subdomain)

```
    if self.config['SERVER_NAME'] is not None:
        return self.url_map.bind(
            self.config['SERVER_NAME'],
            script_name=self.config['APPLICATION_ROOT'],
            url_scheme=self.config['PREFERRED_URL_SCHEME'])



```

```
- - - -

我们知道url_map属性是一个Map对象，可以看出它最后调用了bind()或bind_to_environ()方法，最终会返回一个MapAdapter类实例。

match_request()方法通过调用MapAdapter.match()方法来匹配请求URL，设置return_rule=True可以在匹配成功后返回表示URL规则的Rule类实例。这个Rule实例包含endpoint属性，存储着匹配成功的端点值。

在dispatch_request()最后这一行代码中，通过在view_functions字典中根据端点作为键即可找到对应的视图函数对象，并调用它：

- - - -




```

self.view_functionsrule.endpoint

```
- - - -

调用视图函数时传递的参数**req.view_args包含URL中解析出的变量值，也就是match()函数返回的第二个值。这时代码执行流程才终于走到视图函数中。

#### 16.4.3  本地上下文

Flask提供了两种上下文，请求上下文和程序上下文，这两种上下文分别包含request、session和current_app、g这四个变量，这些变量是实际对象的本地代理（local proxy），因此被称为本地上下文（context locals）。这些代理对象定义在globals.py脚本中，这个模块还包含了和上下文相关的两个错误信息和三个函数，如代码清单16-16所示。

代码清单16-16 flask/globals.py：上下文全局对象

- - - -




```

from functools import partial
from werkzeug.local import LocalStack, LocalProxy

# 两个错误信息

_request_ctx_err_msg = '''\
Working outside of request context.
...
'''
_app_ctx_err_msg = '''\
Working outside of application context.
...
'''

# 查找请求上下文对象

def lookup_req_object(name):
    top = _request_ctx_stack.top
    if top is None:
        raise RuntimeError(request_ctx_err_msg)
    return getattr(top, name)

# 查找程序上下文对象

def lookup_app_object(name):
    top = _app_ctx_stack.top
    if top is None:
        raise RuntimeError(app_ctx_err_msg)
    return getattr(top, name)

# 查找程序实例

def find_app():
    top = _app_ctx_stack.top
    if top is None:
        raise RuntimeError(app_ctx_err_msg)
    return top.app

# 2个堆栈

_request_ctx_stack = LocalStack()  # 请求上下文堆栈
_app_ctx_stack = LocalStack()  # 程序上下文堆栈

# 4个全局上下文代理对象

current_app = LocalProxy(find_app)
request = LocalProxy(partial(lookup_req_object, 'request'))
session = LocalProxy(partial(lookup_req_object, 'session'))
g = LocalProxy(partial(lookup_app_object, 'g'))

```
- - - -

我们在程序中从flask包直接导入的request和session就是定义在这里的全局对象，这两个对象是对实际的request变量和session变量的代理，后面我们会详细了解代理。

关于Flask的上下文实现原理，我们需要了解的东西都在这个模块中。这里我们暂不展开，只要有个大概的认识就可以了，下面我们来详细剖析这个模块中包含的内容。

1.本地线程与Local

在第9章，我们介绍电子邮件功能时了解过多线程。如果每次只能发送一封电子邮件（单线程），那么在发送大量邮件时会花费很多时间，这时就需要使用多线程技术。处理HTTP请求的服务器也是这样，当我们的程序需要面对大量用户同时发起的访问请求时，我们显然不能一个个地处理。这时就需要使用多线程技术，Werkzeug提供的开发服务器默认会开启多线程支持。

在处理请求时使用多线程后，我们会面临一个问题。当我们直接导入request对象并在视图函数中使用时，如何确保这时的request对象包含的请求信息就是我们需要的那一个？比如A用户和B用户在同一时间访问hello视图，这时服务器分配了两个线程来处理这两个请求，如何确保每个线程内的request对象都是各自对应、互不干扰的？

解决办法就是引入本地线程（Thread Local）的概念，在保存数据的同时记录下对应的线程ID，获取数据时根据所在线程的ID即可获取到对应的数据。就像是超市里的存包柜，每个柜子都有一个号码，每个号码对应一份物品。

Flask中的本地线程使用Werkzeug提供的Local类实现，如代码清单16-17所示。

代码清单16-17 werkzeug/local.py：Local类

- - - -




```

try:
    from greenlet import getcurrent as get_ident
except ImportError:
    try:
        from thread import get_ident
    except ImportError:
        from _thread import get_ident

class Local(object):
    slots = ('storage', 'ident_func')

```
def __init__(self):
    object.__setattr__(self, '__storage__', {})
    object.__setattr__(self, '__ident_func__', get_ident)

def __iter__(self):
    return iter(self.__storage__.items())

def __call__(self, proxy):
    """Create a proxy for a name."""
    return LocalProxy(self, proxy)

def __release_local__(self):
    self.__storage__.pop(self.__ident_func__(), None)
# 获取属性
def __getattr__(self, name):
    try:
        return self.__storage__[self.__ident_func__()][name]
    except KeyError:
        raise AttributeError(name)
# 设置属性
def __setattr__(self, name, value):
    ident = self.__ident_func__()
    storage = self.__storage__
    try:
        storage[ident][name] = value
    except KeyError:
        storage[ident] = {name: value}
# 删除属性
def __delattr__(self, name):
    try:
        del self.__storage__[self.__ident_func__()][name]
    except KeyError:
        raise AttributeError(name)



```

```
- - - -

Local中构造函数定义了两个属性，分别是__storage__属性和__ident_func__属性。__storage__是一个嵌套的字典，外层的字典使用线程ID作为键来匹配内部的字典，内部的字典的值即真实对象。它使用self.__storage__[self.__ident_func__()][name]来获取数据，一个典型的Local实例中的__storage__属性可能会是这样：

- - - -




```

{ 线程ID: { 名称: 实际数据}}

```
- - - -

在存储数据时也会存入对应的线程ID。这里的线程ID使用__ident_func__属性定义的get_ident()方法获取。这就是为什么全局使用的上下文对象不会在多个线程中产生混乱。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20372.png)
提示

这里会优先使用Greenlet提供的协程ID，如果Greenlet不可用再使用thread模块获取线程ID。

类中定义了一些魔法方法来改变默认行为。比如，当类实例被调用时会创建一个LocalProxy对象，我们在后面会详细了解。除此之外，类中还定义了用来释放线程/协程的__release_local__()方法，它会清空当前线程/协程的数据。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20239.png)
附注

在Python类中，前后双下划线的方法常被称为魔法方法（Magic Methods）。它们是Python内置的特殊方法，我们可以通过重写这些方法来改变类的行为。比如，我们熟悉的__init__()方法（构造函数）会在类被实例化时调用，类中的__repr__()方法会在类实例被打印时调用。Local类中定义的__getattr__()、__setattr__()、__delattr__()方法分别会在类属性被访问、设置、删除时调用；__iter__()会在类实例被迭代时调用；__call__()会在类实例被调用时调用。完整的列表可以在Python文档（ [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.xhtml) ）看到。 

2.堆栈与LocalStack

堆栈或栈是一种常见的数据结构，它的主要特点就是后进先出（LIFO，Last In First Out），指针在栈顶（top）位置，如图16-9所示。

堆栈涉及的主要操作有push（推入）、pop（取出）和peek（获取栈顶条目）。其他附加的操作还有获取条目数量，判断堆栈是否为空等。使用Python列表（list）实现的一个典型的堆栈结构如代码清单16-18所示。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAXGEcx23AAAAAEXpgco092189577.jpg)
图16-9 堆栈示意图

代码清单16-18 stack.py：使用列表实现堆栈结构

- - - -



```

class Stack:
    def init(self):
        self.items = []

```
    def push(self, item):  # 推入条目
    self.items.append(item)

def pop(self):  # 移除并返回栈顶条目
    if self.is_empty:
        return None
    return self.items.pop()

@property
def is_empty(self):  # 判断是否为空
    return self.items == []

@property
    def top(self):  # 获取栈顶条目
    if self.is_empty:
        return None
    return self.items[-1]


```

```
- - - -

其中push()方法和pop()方法分别用于向堆栈中推入和删除一个条目。具体的操作示例如下：

- - - -



```

> > > s = Stack()
> > > s.push(42)
> > > s.top
> > > 42
> > > s.push(24)
> > > s.top
> > > 24
> > > s.pop()
> > > 24
> > > s.top
> > > 42

```
- - - -

Flask中的上下文对象正是存储在这一类型的栈结构中，globals模块的这两行代码创建了请求上下文堆栈和程序上下文堆栈。

- - - -




```

_request_ctx_stack = LocalStack()  # 请求上下文堆栈
_app_ctx_stack = LocalStack()  # 程序上下文堆栈

```
- - - -

从这里可以想到，我们平时导入的request对象是保存在堆栈里的一个RequestContext实例，导入的操作相当于获取堆栈的栈顶（top），它会返回栈顶的对象（peek操作），但并不删除它。

这两个堆栈对象使用Werkzeug提供的LocalStack类创建，如代码清单16-19所示。

代码清单16-19 werkzeug/local.py：LocalStack

- - - -




```

class LocalStack(object):
    def init(self):
        self._local = Local()

```
def __release_local__(self):
    self._local.__release_local__()
...
def __call__(self):
    def _lookup():
        rv = self.top
        if rv is None:
            raise RuntimeError('object unbound')
        return rv
    return LocalProxy(_lookup)

def push(self, obj):
    """推入新条目"""
    rv = getattr(self._local, 'stack', None)
    if rv is None:
        self._local.stack = rv = []
    rv.append(obj)
    return rv

def pop(self):
    """移除并返回栈顶条目，如果栈为空则返回None"""
    stack = getattr(self._local, 'stack', None)
    if stack is None:
        return None
    elif len(stack) == 1:
        release_local(self._local)
        return stack[-1]
    else:
        return stack.pop()

@property
def top(self):
    """获取栈顶条目，如果栈为空则返回None"""
    try:
        return self._local.stack[-1]
    except (AttributeError, IndexError):
        return None



```

```
- - - -

简单来说，LocalStack是基于Local实现的栈结构（本地堆栈，即实现了本地线程的堆栈），和我们在前面编写的栈结构一样，有push()、pop()方法以及获取栈顶的top属性。在构造函数中创建了Local()类的实例_local。它把数据存储到Local中，并将数据的字典名称设为'stack'。注意这里和Local类一样也定义了__call__方法，当LocalStack实例被直接调用时，会返回栈顶对象的代理，即LocalProxy类实例。

这时会产生一个疑问，为什么Flask使用LocalStack而不是直接使用Local存储上下文对象。主要的原因是为了支持多程序共存。将程序分离成多个程序很类似蓝本的模块化分离，但它们并不是一回事。前面我们提到过，使用Werkzeug提供的DispatcherMiddleware中间件就可以把多个程序组合成一个WSGI程序运行。

在上面的例子中，Werkzeug会根据请求的URL来分发给对应的程序处理。在这种情况下，就会有多个上下文对象存在，使用栈结构就可以让多个程序上下文存在；而活动的当前上下文总是可以在栈顶获得，所以我们在globals模块中从_request_ctx_stack.top属性来获取当前的请求上下文对象。

3.代理与LocalProxy

代理（Proxy）是一种设计模式，通过创建一个代理对象。我们可以使用这个代理对象来操作实际对象。从字面理解，代理就是使用一个中间人来转发操作。代码清单16-20是使用Python实现一个简单的代理类。

代码清单16-20 proxy.py：代理

- - - -




```

class Proxy(object):
    def init(self, obj):
        object.setattr(self, '_obj', obj)

```
def __getattr__(self, name):
    return getattr(self._obj, name)

def __setattr__(self, name, value):
    self._obj[name] = value

def __delattr__(self, name):
    del self._obj[name]



```

```
- - - -

通过定义__getattr__()方法、__setattr__()方法和__delattr__()方法，它会把相关的获取、设置和删除操作转发给实例化代理类时传入的对象。下面的操作演示了这个代理类的使用方法。

- - - -




```

class Foo(object):
    def init(self, x):
        self.x = x

```
def bar(self, y):
    self.x = y



```

> > > foo = Foo('Peter')
> > > p = Proxy(foo)
> > > p.x
> > > 'Peter'
> > > p
> > > <__main__.Proxy at 0x39d8170>
> > > p._obj
> > > <__main__.Foo at 0x39d8c50>
> > > p.bar('Grey')
> > > p.x
> > > p.bar('Grey')
> > > p.x
> > > 'Grey'
> > > foo.x
> > > 'Grey'

```
- - - -

Flask使用Werkzeug提供的LocalProxy类来实现代理，这是一个基于Local的本地代理。Local类实例和LocalStack实例被调用时都会使用LocalProxy包装成一个代理。因此，下面的代码中的两个堆栈对象都是代理。

- - - -




```

_request_ctx_stack = LocalStack()  # 请求上下文堆栈
_app_ctx_stack = LocalStack()  # 程序上下文堆栈

```
- - - -

如果要直接使用LocalProxy类实现代理，需要在实例化时传入一个可调用对象，比如globals模块中传入的partial（_lookup_req_object，'request'）：

- - - -




```

request = LocalProxy(partial(_lookup_req_object, 'request'))

```
- - - -

LocalProxy的定义如代码清单16-21所示。

代码清单16-21 werkzeug/local.py：LocalProxy

- - - -




```

@implements_bool
class LocalProxy(object):
    slots = ('local', 'dict', 'name', 'wrapped__')

```
def __init__(self, local, name=None):
    object.__setattr__(self, '_LocalProxy__local', local)
    object.__setattr__(self, '__name__', name)
    if callable(local) and not hasattr(local, '__release_local__'):
        # "local" is a callable that is not an instance of Local or
        # LocalManager: mark it as a wrapped function.
        object.__setattr__(self, '__wrapped__', local)

def _get_current_object(self):
    """获取被代理的实际对象。"""
    if not hasattr(self.__local, '__release_local__'):
        return self.__local()
    try:
        return getattr(self.__local, self.__name__)
    except AttributeError:
        raise RuntimeError('no object bound to %s' % self.__name__)

...

def __getattr__(self, name):
    if name == '__members__':
        return dir(self._get_current_object())
    return getattr(self._get_current_object(), name)

def __setitem__(self, key, value):
    self._get_current_object()[key] = value

def __delitem__(self, key):
    del self._get_current_object()[key]
...



```

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20373.png)
提示

在Python类中，__foo形式的属性会被替换为_classname__foo的形式，这种开头加双下划线的属性在Python中表示类私有属性（私有程度强于单下划线）。这也是为什么在LocalProxy类的构造函数设置了一个_LocalProxy__local属性，而在其他方法中却可以简写为__local。

这个代理的实现和我们在上面介绍的简单例子很相似，不过这个代理中定义了更多的魔法方法，大约有50多个，在代码中并没有全部列出来。而且它还定义了一个_get_current_object()方法，可以用来获取被代理的真实对象。这也是我们在本书第二部分，获取被current_user代理的当前用户对象的方法。

那么，为什么Flask需要使用代理？总体来说，在这里使用代理对象是因为这些代理可以在线程间共享，让我们可以以动态的方式获取被代理的实际对象。

具体来说，我们在11.2节介绍过Flask的三种状态，当上下文没被推送时，响应的全局代理对象处于未绑定状态。而如果这里不使用代理，那么在导入这些全局对象时就会尝试获取上下文，然而这时堆栈是空的，所以获取到的全局对象只能是None。当请求进入并调用视图函数时，虽然这时堆栈里已经推入了上下文，但这里导入的全局对象仍然是None。总而言之，上下文的推送和移除是动态进行的，而使用代理可以让我们拥有动态获取上下文对象的能力。

另外，一个动态的全局对象，也让多个程序实例并存有了可能。这样在不同的程序上下文环境中，current_app总是能对应正确的程序实例。

4.请求上下文

在Flask中，请求上下文由RequestContext类表示。当请求进入时，被作为WSGI程序调用的Flask类实例（即我们的程序实例app）会在wsgi_app()方法中调用Flask.request_context()方法。这个方法会实例化RequestContext类作为请求上下文对象，接着wsgi_app()调用它的push()方法来将它推入请求上下文堆栈。RequestContext类的定义如代码清单16-22所示。

代码清单16-22 flask/ctx.py：RequestContext

- - - -




```

class RequestContext(object):

```
def __init__(self, app, environ, request=None):
    self.app = app
    if request is None:
        request = app.request_class(environ)
    self.request = request  # 请求对象
    self.url_adapter = app.create_url_adapter(self.request)
    self.flashes = None  # flash消息列表
    self.session = None  # session字典

    self._implicit_app_ctx_stack = []
    self.preserved = False
    self._preserved_exc = None
    self._after_request_functions = []
    self.match_request()



```

   ...

```
def push(self):
    """Binds the request context to the current context."""

    top = _request_ctx_stack.top  # 获取请求上下文栈顶条目
    if top is not None and top.preserved:
        top.pop(top._preserved_exc)

    if hasattr(sys, 'exc_clear'):
        sys.exc_clear()
    # 把自己推入请求上下文堆栈
    _request_ctx_stack.push(self)
    ...

def pop(self, exc=_sentinel):
    app_ctx = self._implicit_app_ctx_stack.pop()

    try:
        clear_request = False
        if not self._implicit_app_ctx_stack:
            self.preserved = False
            self._preserved_exc = None
            if exc is _sentinel:
                exc = sys.exc_info()[1]
            self.app.do_teardown_request(exc)

            if hasattr(sys, 'exc_clear'):
                sys.exc_clear()

            request_close = getattr(self.request, 'close', None)
            if request_close is not None:
                request_close()
            clear_request = True
    finally:
        rv = _request_ctx_stack.pop()
        ...
def __enter__(self):
    self.push()
    return self

def __exit__(self, exc_type, exc_value, tb):
    self.auto_pop(exc_value)

    if BROKEN_PYPY_CTXMGR_EXIT and exc_type is not None:
        reraise(exc_type, exc_value, tb)



```

```
- - - -

构造函数中创建了request和session属性，request对象使用app.request_class（environ）创建，传入了包含请求信息的environ字典。而session在构造函数中只是None，它会在push()方法中被调用，即在请求上下文被推入请求上下文堆栈时创建。

和我们前面介绍的栈结构相似，push()方法用于把请求上下文对象推入请求上下文堆栈（_request_ctx_stack），而pop()方法用来移出堆栈。

另外，pop()方法中还调用了do_teardown_request()方法，这个方法会执行所有使用teardown_request钩子注册的函数。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20240.png)
附注

魔法方法__enter__()和__exit__()分别在进入和退出with语句时调用，这里用来在with语句调用前后分别推入和移出请求上下文，具体见PEP 343（ [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/) ）。 

请求上下文在Flask类的wsgi_app方法的开头创建，在这个方法的最后没有直接调用pop()方法，而是调用了auto_pop()方法来移除。也就是说，请求上下文的生命周期开始于请求进入调用wsgi_app()时，结束于响应生成后。

auto_pop()方法在RequestContext类中定义，如代码清单16-23所示。

代码清单16-23 flask/ctx.py：RequestContext.auto_pop()

- - - -




```

class RequestContext(object):
    ...
    def auto_pop(self, exc):
        if self.request.environ.get('flask.preserve_context') or \
 (exc is not None and self.app.preserve_context_on_exception):
            self.preserved = True
            self.preserved_exc = exc
        else:
            self.pop(exc)

```
- - - -

这个方法里添加了一个if判断，用来确保没有异常发生时才调用pop()方法移除上下文。异常发生时需要保持上下文以便进行相关操作，比如在页面的交互式调试器中执行操作或是测试。

5.程序上下文

程序上下文对象AppContext类的定义和RequestContext类基本相同，但要更简单一些。它的构造函数里创建了current_app变量指向的app属性和g变量指向的g属性，如代码清单16-24所示。

代码清单16-24 flask/ctx.py：AppContext

- - - -




```

class AppContext(object):
    def init(self, app):
        self.app = app
        self.url_adapter = app.create_url_adapter(None)
        self.g = app.app_ctx_globals_class()
    ...

```
def push(self):
    ...

def pop(self, exc=_sentinel):
    ...



```

   ...

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20374.png)
提示

你也许会困惑代理对象current_app和request命名的不一致，这是因为如果将当前程序的代理对象命名为app会和程序实例的名称相冲突。你可以把request理解成current request（当前请求）。

有两种方式创建程序上下文，一种是自动创建，当请求进入时，程序上下文会随着请求上下文一起被创建。在RequestContext类中，程序上下文在请求上下文推入之前推入，在请求上下文移除之后移除，如代码清单16-25所示。

代码清单16-25 flask/ctx.py：请求上下文和程序上下文的生命周期关系

- - - -



```

class RequestContext(object):
    def init(self, app, environ, request=None):
        self.app = app
        if request is None:
            request = app.request_class(environ)
        self.request = request
        ...

```
def push(self):
    ...
    # 在推入请求上下文前先推入程序上下文
    app_ctx = _app_ctx_stack.top
    if app_ctx is None or app_ctx.app != self.app:
        app_ctx = self.app.app_context()  # 获取程序上下文对象
        app_ctx.push()  # 将程序上下文对象推入堆栈（_app_ctx_stack）
        self._implicit_app_ctx_stack.append(app_ctx)
    else:
        ...


```

```
- - - -

而在没有请求处理的时候，你就需要手动创建上下文。你可以使用程序上下文对象中的push()方法，也可以使用with语句。

我们用来构建URL的url_for()函数会优先使用请求上下文对象提供的url_adapter，如果请求上下文没有被推送，则使用程序上下文提供的url_adapter。所以AppContext的构造函数里也同样创建了url_adapter属性。

g使用保存在app_ctx_globals_class属性的_AppCtxGlobals类表示，只是一个普通的类字典对象。我们可以把它看作“增加了本地线程支持的全局变量”。有一个常见的疑问是，为什么说每次请求都会重设g？这是因为g保存在程序上下文中，而程序上下文的生命周期是伴随着请求上下文产生和销毁的。每个请求都会创建新的请求上下文堆栈，同样也会创建新的程序上下文堆栈，所以g会在每个新请求中被重设。

程序上下文和请求上下文的联系非常紧密（在代码中就可以看出）。如果你在前面阅读了0.1版本的代码，你会发现在flask.py底部，全局对象创建时只存在一个请求上下文堆栈。四个全局对象都从请求上下文中获取。可以说，程序上下文是请求上下文的衍生物。这样做的原因主要是为了更加灵活。程序中确实存在着两种明显的状态，分离开可以让上下文的结构更加清晰合理。这也方便了测试等不需要请求存在的使用场景，这时只需要单独推送程序上下文，而且这个分离催生出了Flask的程序运行状态。

6.总结

Flask中的上下文由表示请求上下文的RequestContext类实例和表示程序上下文的AppContext类实例组成。请求上下文对象存储在请求上下文堆栈（_request_ctx_stack）中，程序上下文对象存储在程序上下文堆栈（_app_ctx_stack）中。而request、session则是保存在RequestContext中的变量，相对地，current_app和g则是保存在AppContext中的变量。当然，request、session、current_app、g变量所指向的实际对象都有相应的类：

·request——Request

·session——SecureCookieSession

·current_app——Flask

·g——_AppCtxGlobals

看到这里，想必你已经对上下文有了比较深入的认识。现在你再回头看globals模块的代码，应该就会非常容易理解了。我们可以来总结一下，这一系列事物为什么要存在。当第一个请求发来的时候：

1）需要保存请求相关的信息——有了请求上下文。

2）为了更好地分离程序的状态，应用起来更加灵活——有了程序上下文。

3）为了让上下文对象可以在全局动态访问，而不用显式地传入视图函数，同时确保线程安全——有了Local（本地线程）。

4）为了支持多个程序——有了LocalStack（本地堆栈）。

5）为了支持动态获取上下文对象——有了LocalProxy（本地代理）。

6）……

7）为了让这一切愉快的工作在一起——有了Flask。

#### 16.4.4  请求与响应对象

1.请求对象

一个请求从客户端发出，假如忽略掉更深的细节，它大致经过了这些变化：从HTTP请求报文，到符合WSGI规定的Python字典，再到Werkzeug中的werkzeug.wrappers.Request对象，最后再到Flask中我们熟悉的请求对象request。

前面我们说过，从flask中导入的request是代理，被代理的实际对象是请求上下文RequestContext对象的request属性，这个属性存储的是Request类实例，这个Request才是表示请求的请求对象，如代码清单16-26所示。

代码清单16-26 flask/wrappers.py：Request

- - - -




```

from werkzeug.wrappers import Request as RequestBase

class JSONMixin(object):
    ...  # 定义is_json、json属性和get_json()方法

class Request(RequestBase, JSONMixin):

```
url_rule = None
view_args = None
routing_exception = None

@property
def max_content_length(self):
    """返回配置变量MAX_CONTENT_LENGTH的值"""
    if current_app:
        return current_app.config['MAX_CONTENT_LENGTH']

@property
def endpoint(self):
    """与请求相匹配的端点。"""
    if self.url_rule is not None:
        return self.url_rule.endpoint

@property
def blueprint(self):
    """当前蓝本名称。"""
    if self.url_rule and '.' in self.url_rule.endpoint:
        return self.url_rule.endpoint.rsplit('.', 1)[0]

...



```

```
- - - -

Request类继承Werkzeug提供的Request类和添加JSON支持的JSONMixin类。请求对象request的大部分属性都直接继承Werkzeug中Request类的属性，比如method、args等。Flask中的这个Request类主要添加了一些Flask特有的属性，比如表示所在蓝本的blueprint属性，或是为了方便获取当前端点的endpoint属性等。

Flask允许我们自定义请求类，通常情况下，我们会子类化这个Request类，并添加一些自定义的设置，然后把这个自定义请求类赋值给程序实例的request_class属性。

2.响应对象

一般情况下，在编写程序时我们并不需要直接与响应打交道。在Flask中的请求-响应循环中，我们知道响应是由finalize_request()方法生成的，它调用了flask.Flask.make_response()方法生成响应对象，传入的rv参数是dispatch_request()的返回值，也就是视图函数的返回值。

我们在前面介绍过，视图函数可以返回多种类型的返回值。完整的合法返回值如表16-3所示。

表16-3 视图函数的允许返回值

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAXGERHyEAAAAAFUOaww058617699.jpg)

这个Flask.make_response()方法主要的工作就是判断返回值是表16-3中的哪一种类型，最后根据类型做相应处理，最后生成一个响应对象并返回它。响应对象为Response类的实例，Response类在wrappers.py脚本中定义，如代码清单16-27所示。

代码清单16-27 flask/wrappers.py：Response

- - - -




```

from werkzeug.wrappers import Response as ResponseBase

class JSONMixin(object):
    ...

class Response(ResponseBase, JSONMixin):

```
default_mimetype = 'text/html'

def _get_data_for_json(self, cache):
    return self.get_data()

@property
def max_cookie_size(self):
    """返回配置变量MAX_COOKIE_SIZE的值"""
    if current_app:
        return current_app.config['MAX_COOKIE_SIZE']
    # 上下文未推送时返回Werkzeug中Response类的默认值
    return super(Response, self).max_cookie_size



```

```
- - - -

和Request类相似，这个响应对象继承Werkzeug中的Response类和添加JSON支持的JSONMixin类。这个类比Request类更简单，只是设置了默认的MIME类型。

Flask也允许你自定义响应类，自定义的响应类通常会继承自内置的Response类，然后赋值给flask.Flask.response_class属性。

#### 16.4.5  session

在开始介绍session的实现之前，我们有必要再重申一下措辞问题。我会使用下面的方式来表述三个与session相关的内容：Flask提供了“session变量/对象”来操作“用户会话（Session）”，它把用户会话保存在“一块名/键为session的cookie”中。

我们在第2章对session进行过简单的介绍，现在我们来深入了解它的一些具体细节。在Flask中使用session非常简单，只需要设置好密钥，就可以在视图函数中操作session对象：

- - - -




```

from flask import Flask, session

app = Flask(name)
app.secret_key = 'secret string'

@app.route('/')
def hello():
    session['answer'] = 42
    return '<h1>Hello, Flask!</h1>'

```
- - - -

当第一次介绍session时我们曾说它“可以记住请求间的值”，很多人会对这句话感到困惑。就这个例子来说，当用户访问hello视图时，会把数字42存储到session对象里，以answer作为键。假如我再定义一个bingo视图，当用户访问bingo视图时，我们可以在bingo视图里再次从session通过answer键获取这个数字。这一存一取背后的逻辑是这样的：

向session中存储值时，会生成加密的cookie加入响应。这时用户的浏览器接收到响应会将cookie存储起来。当用户再次发起请求时，浏览器会自动在请求报文中加入这个cookie值。Flask接收到请求会把session cookie的值解析到session对象里。这时我们就可以再次从session中读取内容。

我们在向session中存数字的这行代码设置断点：

- - - -




```

session['answer'] = 42

```
- - - -

下面我们来看看这个数字会经历怎样的一段旅程！

1.操作session

在前面我们学习过，session变量在globals模块中定义：

- - - -




```

session = LocalProxy(partial(_lookup_req_object, 'session'))

```
- - - -

它会调用_lookup_req_object()函数，传入name参数的值为'session'：

- - - -




```

def lookup_req_object(name):
    top = _request_ctx_stack.top
    if top is None:
        raise RuntimeError(request_ctx_err_msg)
    return getattr(top, name)

- - - -

从上面的代码中可以看到Flask从请求上下文堆栈的栈顶（_request_ctx_stack.top）获取请求上下文，从用于获取属性的内置函数getattr()可以看出session是请求上下文对象（即RequestContext）的一个属性，这也就意味着，session变量是在生成请求上下文的时候创建的，后面我们会详细了解它的生成过程。

继续步进代码后，会执行LocalProxy类的__setitem__()方法，它会把设置操作转发给真实的session对象：

- - - -





class LocalProxy(object):
    ...
    def setitem(self, key, value):
        self._get_current_object()[key] = value

```
- - - -

这时在调试工具栏右侧的变量列表中可以看到已经被代理的session对象实际上是sessions模块中的SecureCookieSession类的实例。

在Werkzeug中进行一系列查询工作后，最终执行了SecureCookieSession类中的on_update()方法，这个方法会将两个属性self.modified和self.accessed设为True，说明更新（modify）并使用（access）了session。这两个标志会在保存session的方法中使用，我们下面会了解到。

那么session是否被更新是如何判断的？这个on_update()方法又是如何被执行的呢？要解答这些问题，我们需要先停止步进，在SecureCookieSession中探索一下。首先可以看到Secure-CookieSession类继承了CallbackDict类，CallbackDict在Werkzeug中定义，如代码清单16-28所示。

代码清单16-28 werkzeug/datastructures.py：CallbackDict

- - - -




```

class CallbackDict(UpdateDictMixin, dict):
    """一个字典，每当产生改变化时会调用传入的函数"""

def __init__(self, initial=None, on_update=None):
    dict.__init__(self, initial or ())
    self.on_update = on_update
...



- - - -

我们之前曾说session对象可以像字典一样操作，这里可以看到SecureCookieSession的父类CallbackDict其实继承了dict。

CallbackDict的构造方法接收一个on_update参数，并赋值给on_update属性。我们可以看到SecureCookieSession类在构造函数中定义了一个on_update函数，并赋值给on_update参数，这个类在sessions.py脚本中定义，如代码清单16-29所示。

代码清单16-29 flask/sessions.py：SecureCookieSession

- - - -





class SecureCookieSession(CallbackDict, SessionMixin):
    """Base class for sessions based on signed cookies."""

def __init__(self, initial=None):
    def on_update(self):
        self.modified = True
        self.accessed = True

​    super(SecureCookieSession, self).__init__(initial, on_update)
...



- - - -

CallbackDict中并没有其他内容，我们找到它的父类UpdateDictMixin，会发现原来秘密在这里，这个类的定义如代码清单16-30所示。

代码清单16-30 werkzeug/datastructures.py：UpdateDictMixin

- - - -





class UpdateDictMixin(object):
    """当字典被修改时调用self.on_update"""
    on_update = None

def calls_update(name):
    def oncall(self, *args, **kw):
        rv = getattr(super(UpdateDictMixin, self), name)(*args, **kw)
        if self.on_update is not None:
            self.on_update(self)
        return rv
    oncall.__name__ = name
    return oncall

def setdefault(self, key, default=None):
    ...

def pop(self, key, default=_missing):
    ...

__setitem__ = calls_update('__setitem__')
__delitem__ = calls_update('__delitem__')
clear = calls_update('clear')
popitem = calls_update('popitem')
update = calls_update('update')
del calls_update



```
- - - -

可以看到它重载了所有的字典操作（__setitem__、__delitem__、clear、popitem、update、pop、setdefault），并在这些操作中调用了on_update函数。也就是说，一旦继承了CallbackDict类的对象发生了字典操作，就会执行on_update属性指向的函数。

我们在视图函数中执行的写入操作会触发这里的__setitem__方法，进而执行了calls_update（'__setitem__'），最后才得以调用SecureCookieSession类中定义的on_update()函数。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20375.png)
提示

Werkzeug提供了很多有用的数据结构，比如我们在第2章了解的ImmutableMultiDict，这些数据结构都定义在werkzeug.datastructures模块中。

当我们对session进行写入和更新操作时，Flask需要将新的值写入到cookie中，这是如何做到的呢？我们再返回到调用流程，视图函数执行完毕后会返回到dispatch_request()方法中，而dispatch_request()方法执行完毕后会返回到full_dispatch_request()方法中。full_dispatch_request()最后调用finalize_request()方法来生成响应对象，session的更新操作就在finalize_request()方法中。finalize_request()调用了process_response()对响应对象进行预处理，如代码清单16-31所示。

代码清单16-31 flask/app.py：将session保存为cookie

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def process_response(self, response):
        ctx = _request_ctx_stack.top
        ...
        if not self.session_interface.is_null_session(ctx.session):
            self.session_interface.save_session(self, ctx.session, response)
        return response

- - - -

从代码中可以看到session操作使用了中间变量session_interface，它默认的值在Flask类中定义，为SecureCookieSessionInterface类。Flask使用了很多这样的中间变量，比如请求类和响应类。这是为了方便开发者自定义这些类。比如，可以这样自定义session接口类。

- - - -





class MySessionInterface:
    pass

app = Flask(name)
app.session_interface = MySessionInterface()

- - - -

回到正题，process_response()方法首先获取请求上下文对象，然后会先使用is_null_session()方法检查session是不是无效的。这个方法定义在SecureCookieSessionInterface继承的SessionInterface类中，它会比较session对象是不是NullSession的实例，我们后面会介绍Null-Session。如果返回True就调用save_session()方法来保存session，如代码清单16-32所示。

代码清单16-32 flask/sessions.py：保存session

- - - -





class SecureCookieSessionInterface(SessionInterface):
    ...
    def save_session(self, app, session, response):
        domain = self.get_cookie_domain(app)
        path = self.get_cookie_path(app)

    # 如果session被清空，删除cookie
    # 如果session为空，不设置cookie，直接返回
​    if not session:
​        if session.modified:
​            response.delete_cookie(
​                app.session_cookie_name,
​                domain=domain,
​                path=path
​            )

​        return

    # 如果session被访问，添加一个Vary: Cookie首部字段
​    if session.accessed:
​        response.vary.add('Cookie')

    # 检查session是否被修改，如果没修改则返回空值
​    if not self.should_set_cookie(app, session):
​        return

​    httponly = self.get_cookie_httponly(app)
​    secure = self.get_cookie_secure(app)
​    expires = self.get_expiration_time(app, session)
​    val = self.get_signing_serializer(app).dumps(dict(session))
​    response.set_cookie(
​        app.session_cookie_name,
​        val,
​        expires=expires,
​        httponly=httponly,
​        domain=domain,
​        path=path,
​        secure=secure
​    )



- - - -

在save_session()方法的最后对传入的请求对象调用set_cookie方法设置cookie，这个方法的定义在werkzeug.wrappers.BaseResponse类中，也就是Flask中的响应类的父类。

set_cookie()接收的一系列设置参数都是通过Flask内置的配置键设置的，如表16-4所示。

表16-4 set_cookie()方法接收的参数及说明

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRaIVvHAXGELxg1AAAAADmogoc160043793.jpg)

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20376.png)
提示

在这些配置键中，SESSION_COOKIE_NAME和PERMANENT_SESSION_LIFETIME也可以通过Flask类的属性来设置，分别为session_cookie_name和permanent_session_lifetime。

session cookie的值（value）由下面这行代码生成：

- - - -





val = self.get_signing_serializer(app).dumps(dict(session))

- - - -

签名的序列化器使用get_signing_serializer()生成，传入app对象用于获取用于签名的密钥，如代码清单16-33所示。

代码清单16-33 flask/sessions.py：get_signing_serializer()获取序列化器

- - - -





class SecureCookieSessionInterface(SessionInterface):
    salt = 'cookie-session'  # 为计算增加随机性的“盐”
    digest_method = staticmethod(hashlib.sha1)  # 签名的摘要方法
    key_derivation = 'hmac'  # 衍生密钥的算法
    serializer = session_json_serializer  # 序列化器
    session_class = SecureCookieSession

def get_signing_serializer(self, app):
    if not app.secret_key:
        return None
    signer_kwargs = dict(
        key_derivation=self.key_derivation,
        digest_method=self.digest_method
    )
    return URLSafeTimedSerializer(app.secret_key, salt=self.salt,
                                  serializer=self.serializer,
                                  signer_kwargs=signer_kwargs)



- - - -

这部分操作和我们第9章用户确认令牌的过程基本相同。唯一不同的是这次使用的序列化类是itsdangerous.URLSafeTimedSerializer类，这会创建一个具有过期时间且URL安全的令牌（字符串）。

最后，这个数字变成了下面的字符串：

- - - -





u'eyJjc3JmX3Rva2VuIjp7IiBiIjoiWXpFek5qUTNNVFUwWldVMFlUSm1NR0V4T0Rka056UTBZalJqWlRZeE5URmxNRFF3BPT0ifX0.DdsYjw.sNmOF9eJ3OKsWHYnu_cEEDXgQGg'

- - - -

从这个字符串的形式，你大概可以猜出这就是我们之前介绍的JSON Web签名。这个字符串会被作为answer键的值存储到一块名为session的cookie中。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20241.png)
附注

在0.10版本以前，session序列化为cookie的格式为pickle。更换为JSON格式是为了增强安全性，避免密钥泄露导致的攻击。

2.session起源

在上一节我们知道，session变量在请求上下文中创建，因此，为了探寻session的起源，我们需要将断点设置到创建请求上下文之前，比如在Flask类的__call__方法中。不过，这样的话整个过程就掺杂了太多不相关的操作，我们需要频繁使用Step Out按钮，作为替代，我们可以采取手动探索的方式来探寻session的起源。

既然session变量在RequestContext中创建，那么生成session对象的操作也应该在这里。我们打开搜索功能，找到RequestContext的定义后发现相关的代码在push()方法中，如代码清单16-34所示。

代码清单16-34 flask/ctx.py：在push()方法中创建session

- - - -





class RequestContext(object):
    def init(self, app, environ, request=None):
        ...
        self.session = None
        ...
    ...
    def push(self):
        ...
        if self.session is None:
            session_interface = self.app.session_interface
            self.session = session_interface.open_session(
                self.app, self.request
            )
            if self.session is None:
                self.session = session_interface.make_null_session(self.app)
    ...

- - - -

推送请求上下文的push()方法中调用了open_session()方法来创建session，也就是说，一旦接收到请求，就会创建session对象。

open_session()方法接收程序实例和请求对象作为参数，我们可以猜想到，程序实例是用来获取密钥验证session值，而请求对象参数是用于获取请求中的cookie。open_session()方法的定义如代码清单16-35所示。

代码清单16-35 flask/sessions.py：从cookie中读取session

- - - -





class SecureCookieSessionInterface(SessionInterface):
    ...
    def open_session(self, app, request):
        s = self.get_signing_serializer(app)
        if s is None:
            return None
        val = request.cookies.get(app.session_cookie_name)
        if not val:
            return self.session_class()
        max_age = total_seconds(app.permanent_session_lifetime)
        try:
            data = s.loads(val, max_age=max_age)
            return self.session_class(data)
        except BadSignature:
            return self.session_class()

- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20242.png)
附注

SecureCookieSessionInterface类实现了session操作的主要接口，它继承SessionInterface类，后者实现了一些辅助方法。

在这个方法中，如果请求的cookie里包含session数据，就解析数据到session对象里，否则就生成一个空的session。这里要注意的是，如果没有设置秘钥，open_session()会返回None，这时在push()方法中会调用make_null_session来生成一个无效的session对象（NullSession类），对其执行字典操作时会显示警告。

最终返回的session，就是我们一开始在视图函数里使用的那个session对象，这就是session的整个生命轨迹。

签名可以确保session cookie的内容不被篡改，但这并不意味着没法获取加密前的原始数据。事实上，session cookie的值可以轻易地被解析出来（即使不知道密钥），这就是为什么我们曾频繁提到session中不能存入敏感数据。下面是使用itsdangerous解析session内容的示例：

- - - -





> > > from itsdangerous import base64_decode
> > > s = 'eyJjc3JmX3Rva2VuIjp7IiBiI...'
> > > data, timstamp, secret = s.split('.')
> > > base64_decode(data)
> > > '{"answer":42}'

- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20243.png)
附注

Flask提供的session将用户会话存储在客户端，和这种存储在客户端的方式相反，另一种实现用户会话的方式是在服务器端存储用户会话，而客户端只存储一个session ID。当接收到客户端的请求时，可以根据cookie中的session ID来找到对应的用户会话内容。这种方法更为安全和强健，你可以使用扩展Flask-Session（ [https://github.com/fengsp/flask-session](https://github.com/fengsp/flask-session) ）来实现这种方式的session。 

#### 16.4.6  蓝本

在Flask中，我们使用Blueprint类来创建蓝本。你可以把蓝本理解成另一个简化版的Flask类，它实现了许多和Flask类相似的方法，并定义了一些蓝本专用的方法。比如，注册仅仅在蓝本范围内起作用的错误处理器。

我们曾在第8章介绍过，每一个蓝本都是一个休眠的操作子集，只有注册到程序上才会获得生命。那么，这种休眠状态是如何实现的呢？

如果仔细观察Blueprint类中实现的一些功能方法，你会发现除了一般的装饰器，大多数方法并不直接执行逻辑代码，而是把执行操作的函数作为参数传递给Blueprint.record()方法或Blueprint.record_once()方法。record()方法及Blueprint类在blueprints.py脚本中定义，如代码清单16-36所示。

代码清单16-36 flask/blueprints.py：record()方法

- - - -





class Blueprint(PackageBoundObject):
    ...
    def record(self, func):
        if self.got_registered_once and self.warn_on_modifications:
            from warnings import warn
            warn(Warning('The blueprint was already registered once '
                         'but is getting modified now.  These changes '
                         'will not show up.'))
        self.deferred_functions.append(func)

- - - -

这个方法主要的作用是把传入的函数添加到deferred_functions属性中，这是一个存储所有延迟执行的函数的列表。

我们知道，蓝本可以被注册多次，但是这并不代表蓝本中的其他函数可以被注册多次。比如模板上下文装饰器context_processor。为了避免重复写入deferred_functions列表，这些函数使用record_once()函数来录入，它会在调用前进行检查，如代码清单16-37所示。

代码清单16-37 flask/blueprints.py：record_once()

- - - -





class Blueprint(_PackageBoundObject):
    ...
    def record_once(self, func):
        def wrapper(state):
            if state.first_registration:
                func(state)
        return self.record(update_wrapper(wrapper, func))

- - - -

这个方法内实现了一个wrapper函数，它接收state参数，通过state对象的first_registration属性来判断蓝本是否是第一次注册，以决定是否将函数加入deferred_functions列表。这里的state我们会在下面详细了解。

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20377.png)
提示

update_wrapper是Python标准库functools模块提供的工具函数，用来更新封装（wrapper）函数。

蓝本中的视图函数和其他处理函数（回调函数）都使用这种方式临时保存到deferred_functions属性对应的列表中。可以猜想到，在注册蓝本时会依次执行这个列表包含的函数。

在程序中，我们使用Flask.register_blueprint()方法将蓝本注册到程序实例上，这个方法的定义如代码清单16-38所示。

代码清单16-38 flask/blueprints.py：Flask.register_blueprint()

- - - -





Flask.register_blueprint()
class Flask(_PackageBoundObject):
    ...
    @setupmethod
    def register_blueprint(self, blueprint, **options):
        first_registration = False

​    if blueprint.name in self.blueprints:
​        assert self.blueprints[blueprint.name] is blueprint, (
​            'A name collision occurred between blueprints %r and %r. Both'
​            ' share the same name "%s". Blueprints that are created on the'
​            ' fly need unique names.' % (
​                blueprint, self.blueprints[blueprint.name], blueprint.name
​            )
​        )
​    else:
​        self.blueprints[blueprint.name] = blueprint
​        self._blueprint_order.append(blueprint)
​        first_registration = True

​    blueprint.register(self, options, first_registration)



- - - -

蓝本注册后将保存在Flask类的blueprints属性中，它是一个存储蓝本名称与对应的蓝本对象的字典。

register_blueprint()方法会先检查要注册的蓝本名称是否和已注册的非同一蓝本的名称是否冲突（因为蓝本可以注册多次），如果没有冲突就把蓝本对象存进Flask.blueprints字典，并将表示第一次注册的标志first_registration设为True，最后调用蓝本对象Blueprint类的register()方法，如代码清单16-39所示。

代码清单16-39 flask/blueprints.py：注册蓝本的register()方法

- - - -





class Blueprint(PackageBoundObject):
    ...
    def register(self, app, options, first_registration=False):
        self.got_registered_once = True
        state = self.make_setup_state(app, options, first_registration)

​    if self.has_static_folder:
​        state.add_url_rule(
​            self.static_url_path + '/<path:filename>',
​            view_func=self.send_static_file, endpoint='static'
​        )

​    for deferred in self.deferred_functions:
​        deferred(state)



- - - -

这里使用Blueprint.make_setup_state()方法创建了一个state对象。根据传入的参数我们可以猜到，这个对象包含了当前蓝本的状态信息，比如是否是第一次被注册。因为在最后迭代deferred_functions列表并执行时传入了这个参数，所以record_once()方法能在state对象上获取first_registration变量，其他方法也可以通过state.app获取程序实例对象。

这个state对象其实是BlueprintSetupState类的实例。从名字可以看出，这个类用来保存注册时的蓝本状态信息，如代码清单16-40所示。

代码清单16-40 flask/blueprints.py：BlueprintSetupState

- - - -





class BlueprintSetupState(object):
    def init(self, blueprint, app, options, first_registration):
        self.app = app
        self.blueprint = blueprint
        self.options = options

​    self.first_registration = first_registration

​    subdomain = self.options.get('subdomain')
​    if subdomain is None:
​        subdomain = self.blueprint.subdomain

​    self.subdomain = subdomain

​    url_prefix = self.options.get('url_prefix')
​    if url_prefix is None:
​        url_prefix = self.blueprint.url_prefix

​    self.url_prefix = url_prefix

​    self.url_defaults = dict(self.blueprint.url_values_defaults)
​    self.url_defaults.update(self.options.get('url_defaults', ()))

def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
    if self.url_prefix:
        rule = self.url_prefix + rule
    options.setdefault('subdomain', self.subdomain)
    if endpoint is None:
        endpoint = _endpoint_from_view_func(view_func)
    defaults = self.url_defaults
    if 'defaults' in options:
        defaults = dict(defaults, **options.pop('defaults'))
    self.app.add_url_rule(rule, '%s.%s' % (self.blueprint.name, endpoint),
                          view_func, defaults=defaults, **options)



```
- - - -

除了定义存储蓝本信息的几个属性外，这个类还实现了add_url_rule()方法，它会在进行相关参数设置后调用程序实例上的Flask.add_url_rule()方法来添加URL规则。

#### 16.4.7  模板渲染

在视图函数中，我们使用render_template()函数来渲染模板，传入模板的名称和需要注入模板的关键词参数：

- - - -




```

from flask import Flask, render_template
app = Flask(name)

@app.route('/hello')
def hello():
    name = 'Flask'
    return render_template('hello.html', name=name)

```
- - - -

我们在return语句这一行设置断点，程序运行到断点后的第一次步进会调用render_template()函数。render_template()函数的定义在templating.py脚本中，如代码清单16-41所示。

代码清单16-41 flask/templating.py：render_template()

- - - -




```

def render_template(template_name_or_list, **context):
    ctx = _app_ctx_stack.top
    ctx.app.update_template_context(context)  # 更新模板上下文
    return _render(ctx.app.jinja_env.get_or_select_template(template_name_or_list),
                   context, ctx.app)

```
- - - -

这个函数接收的template_name_or_list参数是文件名或是包含文件名的列表，而**context参数是我们调用render_template()函数时传入的上下文参数。

这个函数先获取程序上下文，然后调用程序实例的Flask.update_template_context()方法更新模板上下文，update_template_context()的定义如代码清单16-42所示。

代码清单16-42 flask/app.py：update_template_context()

- - - -




```

class Flask(_PackageBoundObject):
    ...
  def update_template_context(self, context):

# 获取全局的模板上下文处理函数

​        funcs = self.template_context_processors[None]
​        reqctx = _request_ctx_stack.top
​        if reqctx is not None:
​            bp = reqctx.request.blueprint
​            if bp is not None and bp in self.template_context_processors:

# 获取蓝本下的模板上下文处理函数

​                funcs = chain(funcs, self.template_context_processors[bp])
​        orig_ctx = context.copy()
​        for func in funcs:
​            context.update(func())
​        context.update(orig_ctx)

```
- - - -

我们使用context_processor装饰器注册模板上下文处理函数，这些处理函数被存储在Flask.template_context_processors字典里：

- - - -




```

self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }

```
- - - -

字典的键为蓝本的名称，全局的处理函数则使用None作为键。默认的处理函数是templa-ting._default_template_ctx_processor()，它把当前上下文中的request、session和g注入模板上下文。

这个update_template_context()方法的主要任务就是调用这些模板上下文处理函数，获取返回的字典，然后统一添加到context字典。这里先复制原始的context并在最后更新了它，这是为了确保最初设置的值不被覆盖，即视图函数中使用render_template()函数传入的上下文参数优先。

render_template()函数最后使用这个context字典调用了_render()函数。传入的第一个参数为ctx.app.jinja_env.get_or_select_template（template_name_or_list）。这里对程序实例app调用的Flask.jinja_env()方法如代码清单16-43所示。

代码清单16-43 flask/app.py：jinja_env()

- - - -




```

class Flask(_PackageBoundObject):
    ...
    @locked_cached_property
    def jinja_env(self):
        """用来加载模板的Jinja2环境（templating.Environment类实例）"""
        return self.create_jinja_environment()

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWqEYPMNAAAAAMfNRvk563882759%20378.png)
提示

这里的locked_cached_property装饰器定义在flask.helpers.locked_cached_property中，它的作用是将被装饰的函数转变成一个延迟函数，也就是它的返回值会在第一次获取后被缓存。同时为了线程安全添加了基于RLock的可重入线程锁。

它调用Flask.create_jinja_environment()方法创建了一个Jinja2环境（templating.Environ-ment类，继承自jinja2.Environment），用于加载模板。这个方法完成了Jinja2环境在Flask中的初始化，向模板上下文中添加了一些全局对象（比如url_for()函数、get_flashed_messages()函数以及config对象等），更新了一些渲染设置，还添加了一个tojson过滤器，如代码清单16-44所示。

代码清单16-44 flask/app.py：Flask.create_jinja_environment()

- - - -




```

class Flask(_PackageBoundObject):
    ...
    def create_jinja_environment(self):
        options = dict(self.jinja_options)

```
    if 'autoescape' not in options:  # 设置转义
        options['autoescape'] = self.select_jinja_autoescape

    if 'auto_reload' not in options:  # 设置自动重载选项
        options['auto_reload'] = self.templates_auto_reload

    rv = self.jinja_environment(self, **options)
    rv.globals.update(  # 添加多个全局对象
        url_for=url_for,
        get_flashed_messages=get_flashed_messages,
        config=self.config,
        request=request,
        session=session,
        g=g
    )
    rv.filters['tojson'] = json.tojson_filter  # 添加tojson过滤器
    return rv



```

```
- - - -

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUN1vHAWuEZ7XSAAAAAD-Mp70385305921%20133.png)
注意

虽然之前已经通过调用update_template_context()方法向模板上下文中添加了request、session、g（由_default_template_ctx_processor()获取），这里再次添加是为了让导入的模板也包含这些变量。

最后调用的_render()函数如代码清单16-45所示。

代码清单16-45 flask/templating.py：_render()

- - - -




```

def _render(template, context, app):
    before_render_template.send(app, template=template, context=context)
    rv = template.render(context)
    template_rendered.send(app, template=template, context=context)
    return rv

```
- - - -

在调用_render()函数前，经过了一段非常漫长的调用过程：模板文件定位、加载、解析等。这个函数调用Jinja2的render函数渲染模板，并在渲染前后发送相应的信号。渲染工作结束后会返回渲染好的unicode字符串，这个字符串就是最终的视图函数返回值，即响应的主体，也就是返回给浏览器的HTML页面。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

 

### 16.5  本章小结

经过这一段漫长的源码探险，你应该对Flask的工作机制有了比较深刻的了解，这一定会让你的开发更加得心应手。

在阅读Flask源码/文档的过程中，如果你发现了Bug，或是更好的实现方案，甚至仅仅是代码注释和文档的拼写错误，都可以在Flask的Github仓库（ [https://github.com/pallets/flask/](https://github.com/pallets/flask/) ）中提交Issue进行讨论（在创建新Issue前，请尝试搜索是否已经包含相同主题的Issue），或是在修改代码后创建Pull Request，Flask会因为你的参与而变得更好。 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmQUNlvHAWqEWoC7AAAAAFl9CWc668141697%20244.png)
附注

关于提交Pull Request的注意事项与代码风格，请参考Flask项目的《贡献注意事项》（ [https://github.com/pallets/flask/blob/master/CONTRIBUTING.rst](https://github.com/pallets/flask/blob/master/CONTRIBUTING.rst) ）和《Pocco风格指南（Styleguide）》（ [http://flask.pocoo.org/docs/latest/styleguide/](http://flask.pocoo.org/docs/latest/styleguide/) ）。 Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA== 

 

![](Flask_Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98_%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/CmRablvHAXGEbvfYAAAAAFsS8GU014526581%202.png)





```

# 附录A

# Flask资源

附录A列出了目前质量相对较高的Flask资源，可以作为进一步学习的参考资料。

#### A.1 本书配套资源

helloflask.com是一个由本书催生出的关于Flask的网站。本书所有配套资源索引可以在本书的主页—— http://helloflask.com/book 上看到，其中包含了所有资源的具体使用方法和相关链接。 

本书的项目仓库托管在GitHub上，地址为 https://github.com/greyli/helloflask ，仓库中包含本书除第二部分以外的所有示例程序和勘误表等资源。如果你发现了书中的错误，欢迎在勘误表添加内容并提交Pull Request。另外，关于本书的反馈信息、改进和疑问，最佳的发布方式就是在这个项目中创建Issue。 

本书一共提供了13个示例程序，每个程序都专注不同的技术主题，这些示例程序的GitHub链接如下所示：

·第1～6章和第13章示例程序： https://github.com/greyli/helloflask 

·SayHello： https://github.com/greyli/sayhello 

·Bluelog： https://github.com/greyli/bluelog 

·Albumy： https://github.com/greyli/albumy 

·Todoism： https://github.com/greyli/todoism 

·CatChat： https://github.com/greyli/catchat 

另外，本书附带的Flask 0.1版本源码注解可以在 https://github.com/greyli/flask-origin 看到。 

#### A.2 优秀的Flask开源程序

·Flaskr（ https://github.com/pallets/flask/tree/master/examples/flaskr ）：官方文档的教程的示例程序，一个简单的博客程序。 

·MiniTwit（ https://github.com/pallets/flask/tree/master/examples/minitwit ）：官方示例程序，一个类Twitter的社交程序。 

·Flasky（ https://github.com/miguelgrinberg/flasky ）：Flasky是Miguel Grinberg撰写的《Flask Web Development》（中文版译名《Flask Web开发》）一书的配套程序，当前版本为第二版。 

·Microblog（ https://github.com/miguelgrinberg/microblog ）：Microblog是Miguel Grinberg撰写的在线教程《Flask Mega-Tutorial》的配套程序。 

·FlaskBB（ https://flaskbb.org/ ）：一个基于Flask实现的论坛程序，包含丰富全面的特性。运行中的程序示例可以在 https://forums.flaskbb.org/ 看到，源码在 https://github.com/sh4nks/flaskbb ，作者为Peter Justin。 

·Zerqu（ https://github.com/lepture/zerqu ）：一个使用Flask编写的论坛API，程序的应用实例在 http://python-china.org/ ，作者是Hsiaoming Yang。 

·Quokka（ www.quokkaproject.org ）：一个CMS（Content Management System，内容管理系统），项目源码在 https://github.com/quokkaproject/quokka ，轻量重构版可以在 https://github.com/rochacbruno/quokka_ng 看到，作者为Bruno Rocha。 

·flask.pocoo.org（ https://github.com/pallets/flask-website ）：Flask官方网站的源码。 

更多的Flask项目可以到PyPI（ https://pypi.org/ ）、Github（ https://github.com/ ）以及Bit-Bucket（ https://bitbucket.com ）上进行搜索。 

#### A.3 优秀的在线资源

·Flask的官方文档

链接： http://flask.pocoo.org/docs 。 

官方文档结构清晰，包含了丰富的内容，非常值得阅读。除了各类专题章节，尤其推荐下面这几个部分：

·Quickstart（ http://flask.pocoo.org/docs/latest/quickstart/ ）：简明扼要但又不失全面地介绍了Flask的基础内容。 

·Tutorial（ http://flask.pocoo.org/docs/latest/tutorial/ ）：这个教程通过示例程序Flaskr的开发过程介绍了Flask开发的各种技巧和最佳实践。 

·Patterns（ http://flask.pocoo.org/docs/latest/patterns/ ）：介绍了Flask的各种进阶模式。 

·Flask snippets

链接： http://flask.pocoo.org/snippets/ 。 

由开发者贡献的关于Flask的各类主题的代码片段。注意，虽然部署在官方网站上，但这不是官方维护的内容，而且有些内容已经过时，所以仅用于参考。

·Flask Mega-Tutorial。

链接： https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world 。 

Miguel Grinberg撰写的Flask教程，这个教程的配套程序可以在 https://github.com/migue-lgrinberg/microblog 看到。 

·Explore Flask

链接： https://exploreflask.com 。 

这个教程由作者Robert Picard在Kickstarter上发起，包含了开发Flask程序的最佳实践和常见模式。教程的源码可以在GitHub（ https://github.com/rpicard/explore-flask ）上看到。 

·Armin Ronacher’s Thoughts and Writings

链接： http://lucumr.pocoo.org/ 。 

Flask主要作者Armin Ronacher的博客，其中Talks页面（ http://lucumr.pocoo.org/talks/ ）列出了Armin Ronacher自2009年以来年大部分的演讲以及相关的资源链接，大多与Flask相关。 

·miguelgrinberg.com

链接： https://blog.miguelgrinberg.com/index 。 

《Flask Web Development》作者Miguel Grinberg的博客，包含许多关于Flask的文章和教程。

·Hello，Flask！

链接： https://zhuanlan.zhihu.com/flask 。 

一个关于Flask的知乎专栏，包含许多关于Flask的教程和文章。

#### A.4 讨论与问题求助

遇到问题后，第一步是通过错误堆栈和异常信息来尝试解决问题，排除简单的问题，比如语法错误。如果自己无法解决，那么就提取问题关键词到Google等搜索引擎搜索相关网页，寻找答案。如果最终还是没有找到相应的解决方法，这时再考虑进行提问。

###### A.4.1 提问前的准备

要想解决自己的问题，获得优秀的答案，那么你得先提一个好问题。关于如何提一个好问题，你可以阅读Eric S.Raymond和Rick Moen合著的《How To Ask Questions The Smart Way》（ http://www.catb.org/%7Eesr/faqs/smart-questions.html ），或是Stack Overflow上的文章《How do I ask a good questioin？》（ https://stackoverflow.com/help/how-to-ask ）来了解。简单来说，一个好的编程问题应该包含下面这些内容： 

·期望效

果。

·实际效果。

·你的操作步骤和尝试过的解决办法。

·相关的代码和错误输出。

·使用的操作系统、Python版本、相关的库的版本等环境信息。

###### A.4.2 在哪里提问

在准备好提问后，可以从下面的途径进行提问：

·Stack Overflow（ https://stackoverflow.com ）。 

·Reddit的Flask板块（ https://www.reddit.com/r/flask/ ）。 

·邮件组（ https://mail.python.org/mailman/listinfo/flask/ ）。 

·IRC（#pocoo）：你可以使用客户端，也可以使用Web版（ http://webchat.freenode.net/?channels=pocoo ）。 

·中文Flask问题讨论项目：Flask-China（ https://github.com/greyli/flask-china ）。 

·相关论坛和聊天组。

·通过Email请教别人。

###### A.4.3 Bug与改进建议

如果你遇到的问题和Flask或其他项目本身有关，你可以到Flask在GitHub上的Issues页面（ http://github.com/pallets/flask/issues ）创建新的Issue，或是改进代码后提交Pull Request，其他项目亦同。 

#### A.5 为Flask社区贡献

Flask之所以能吸引越来越多的人使用，离不开社区参与者的贡献。如果你也打算为此贡献一份力量，可以考虑通过下面的方式参与进来：

·在Stack Overflow、Quora、知乎等网站上回答Flask相关的问题。

·撰写Flask教程与文章。

·开源Flask程序。

·编写Flask扩展。

·在Reddit的Flask板块、Flask邮件组以及相关项目的Issues中参与讨论。

·为Flask相关项目创建Issues报告Bug和改进建议。

·为Flask相关项目创建Pull Request贡献代码。

如果你已经这样做了，感谢你为社区做出的贡献！ Upps9muijsW2utBoJtm7hTfEhvLzvsBdqkN3+RDpmL89d1MJAnFs9G4+sg/1aWUNAJyDKokNOcfvcBsG/4AZpA==

